# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
AppDef module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_appdef.html
"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _AppDef
else:
    import _AppDef

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _AppDef.SWIG_PyInstanceMethod_New
_swig_new_static_method = _AppDef.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _AppDef.delete_SwigPyIterator
    value = _swig_new_instance_method(_AppDef.SwigPyIterator_value)
    incr = _swig_new_instance_method(_AppDef.SwigPyIterator_incr)
    decr = _swig_new_instance_method(_AppDef.SwigPyIterator_decr)
    distance = _swig_new_instance_method(_AppDef.SwigPyIterator_distance)
    equal = _swig_new_instance_method(_AppDef.SwigPyIterator_equal)
    copy = _swig_new_instance_method(_AppDef.SwigPyIterator_copy)
    next = _swig_new_instance_method(_AppDef.SwigPyIterator_next)
    __next__ = _swig_new_instance_method(_AppDef.SwigPyIterator___next__)
    previous = _swig_new_instance_method(_AppDef.SwigPyIterator_previous)
    advance = _swig_new_instance_method(_AppDef.SwigPyIterator_advance)
    __eq__ = _swig_new_instance_method(_AppDef.SwigPyIterator___eq__)
    __ne__ = _swig_new_instance_method(_AppDef.SwigPyIterator___ne__)
    __iadd__ = _swig_new_instance_method(_AppDef.SwigPyIterator___iadd__)
    __isub__ = _swig_new_instance_method(_AppDef.SwigPyIterator___isub__)
    __add__ = _swig_new_instance_method(_AppDef.SwigPyIterator___add__)
    __sub__ = _swig_new_instance_method(_AppDef.SwigPyIterator___sub__)
    def __iter__(self):
        return self

# Register SwigPyIterator in _AppDef:
_AppDef.SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.math
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.Message
import OCC.Core.gp
import OCC.Core.AppParCurves
import OCC.Core.TColgp
import OCC.Core.Approx
import OCC.Core.Adaptor3d
import OCC.Core.Geom
import OCC.Core.GeomAbs
import OCC.Core.TopAbs
import OCC.Core.Adaptor2d
import OCC.Core.Geom2d
import OCC.Core.AppCont
import OCC.Core.FEmTool
import OCC.Core.PLib
Handle_AppDef_SmoothCriterion_Create = _AppDef.Handle_AppDef_SmoothCriterion_Create
Handle_AppDef_SmoothCriterion_DownCast = _AppDef.Handle_AppDef_SmoothCriterion_DownCast
Handle_AppDef_SmoothCriterion_IsNull = _AppDef.Handle_AppDef_SmoothCriterion_IsNull
Handle_AppDef_LinearCriteria_Create = _AppDef.Handle_AppDef_LinearCriteria_Create
Handle_AppDef_LinearCriteria_DownCast = _AppDef.Handle_AppDef_LinearCriteria_DownCast
Handle_AppDef_LinearCriteria_IsNull = _AppDef.Handle_AppDef_LinearCriteria_IsNull
Handle_AppDef_HArray1OfMultiPointConstraint_Create = _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_Create
Handle_AppDef_HArray1OfMultiPointConstraint_DownCast = _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_DownCast
Handle_AppDef_HArray1OfMultiPointConstraint_IsNull = _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_IsNull
class AppDef_Array1OfMultiPointConstraint(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    begin = _swig_new_instance_method(_AppDef.AppDef_Array1OfMultiPointConstraint_begin)
    end = _swig_new_instance_method(_AppDef.AppDef_Array1OfMultiPointConstraint_end)
    cbegin = _swig_new_instance_method(_AppDef.AppDef_Array1OfMultiPointConstraint_cbegin)
    cend = _swig_new_instance_method(_AppDef.AppDef_Array1OfMultiPointConstraint_cend)

    def __init__(self, *args):
        _AppDef.AppDef_Array1OfMultiPointConstraint_swiginit(self, _AppDef.new_AppDef_Array1OfMultiPointConstraint(*args))
    Init = _swig_new_instance_method(_AppDef.AppDef_Array1OfMultiPointConstraint_Init)
    Size = _swig_new_instance_method(_AppDef.AppDef_Array1OfMultiPointConstraint_Size)
    Length = _swig_new_instance_method(_AppDef.AppDef_Array1OfMultiPointConstraint_Length)
    IsEmpty = _swig_new_instance_method(_AppDef.AppDef_Array1OfMultiPointConstraint_IsEmpty)
    Lower = _swig_new_instance_method(_AppDef.AppDef_Array1OfMultiPointConstraint_Lower)
    Upper = _swig_new_instance_method(_AppDef.AppDef_Array1OfMultiPointConstraint_Upper)
    IsDeletable = _swig_new_instance_method(_AppDef.AppDef_Array1OfMultiPointConstraint_IsDeletable)
    IsAllocated = _swig_new_instance_method(_AppDef.AppDef_Array1OfMultiPointConstraint_IsAllocated)
    Assign = _swig_new_instance_method(_AppDef.AppDef_Array1OfMultiPointConstraint_Assign)
    Move = _swig_new_instance_method(_AppDef.AppDef_Array1OfMultiPointConstraint_Move)
    Set = _swig_new_instance_method(_AppDef.AppDef_Array1OfMultiPointConstraint_Set)
    First = _swig_new_instance_method(_AppDef.AppDef_Array1OfMultiPointConstraint_First)
    ChangeFirst = _swig_new_instance_method(_AppDef.AppDef_Array1OfMultiPointConstraint_ChangeFirst)
    Last = _swig_new_instance_method(_AppDef.AppDef_Array1OfMultiPointConstraint_Last)
    ChangeLast = _swig_new_instance_method(_AppDef.AppDef_Array1OfMultiPointConstraint_ChangeLast)
    Value = _swig_new_instance_method(_AppDef.AppDef_Array1OfMultiPointConstraint_Value)
    ChangeValue = _swig_new_instance_method(_AppDef.AppDef_Array1OfMultiPointConstraint_ChangeValue)
    __call__ = _swig_new_instance_method(_AppDef.AppDef_Array1OfMultiPointConstraint___call__)
    SetValue = _swig_new_instance_method(_AppDef.AppDef_Array1OfMultiPointConstraint_SetValue)
    Resize = _swig_new_instance_method(_AppDef.AppDef_Array1OfMultiPointConstraint_Resize)
    __swig_destroy__ = _AppDef.delete_AppDef_Array1OfMultiPointConstraint

    def __getitem__(self, index):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            return self.Value(index + self.Lower())

    def __setitem__(self, index, value):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            self.SetValue(index + self.Lower(), value)

    def __len__(self):
        return self.Length()

    def __iter__(self):
        self.low = self.Lower()
        self.up = self.Upper()
        self.current = self.Lower() - 1
        return self

    def next(self):
        if self.current >= self.Upper():
            raise StopIteration
        else:
            self.current += 1
        return self.Value(self.current)

    __next__ = next


# Register AppDef_Array1OfMultiPointConstraint in _AppDef:
_AppDef.AppDef_Array1OfMultiPointConstraint_swigregister(AppDef_Array1OfMultiPointConstraint)

class AppDef_BSpGradient_BFGSOfMyBSplGradientOfBSplineCompute(OCC.Core.math.math_BFGS):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        :param F:
        	:type F: math_MultipleVarFunctionWithGradient
        	:param StartingPoint:
        	:type StartingPoint: math_Vector
        	:param Tolerance3d:
        	:type Tolerance3d: float
        	:param Tolerance2d:
        	:type Tolerance2d: float
        	:param Eps:
        	:type Eps: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:rtype: None
        """
        _AppDef.AppDef_BSpGradient_BFGSOfMyBSplGradientOfBSplineCompute_swiginit(self, _AppDef.new_AppDef_BSpGradient_BFGSOfMyBSplGradientOfBSplineCompute(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_BSpGradient_BFGSOfMyBSplGradientOfBSplineCompute

# Register AppDef_BSpGradient_BFGSOfMyBSplGradientOfBSplineCompute in _AppDef:
_AppDef.AppDef_BSpGradient_BFGSOfMyBSplGradientOfBSplineCompute_swigregister(AppDef_BSpGradient_BFGSOfMyBSplGradientOfBSplineCompute)

class AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute(OCC.Core.math.math_MultipleVarFunctionWithGradient):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * initializes the fields of the function. The approximating curve has <NbPol> control points.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        """
        _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_swiginit(self, _AppDef.new_AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute(*args))
    CurveValue = _swig_new_instance_method(_AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_CurveValue)
    DerivativeFunctionMatrix = _swig_new_instance_method(_AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_DerivativeFunctionMatrix)
    Error = _swig_new_instance_method(_AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_Error)
    FirstConstraint = _swig_new_instance_method(_AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_FirstConstraint)
    FunctionMatrix = _swig_new_instance_method(_AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_FunctionMatrix)
    Index = _swig_new_instance_method(_AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_Index)
    LastConstraint = _swig_new_instance_method(_AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_LastConstraint)
    MaxError2d = _swig_new_instance_method(_AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_MaxError2d)
    MaxError3d = _swig_new_instance_method(_AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_MaxError3d)
    NewParameters = _swig_new_instance_method(_AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_NewParameters)
    SetFirstLambda = _swig_new_instance_method(_AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_SetFirstLambda)
    SetLastLambda = _swig_new_instance_method(_AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_SetLastLambda)

    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute

# Register AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute in _AppDef:
_AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_swigregister(AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute)

class AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. NbPol is the number of control points wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the Bernstein matrix computed with the parameters, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None* Initializes the fields of the object.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None* given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. Deg is the degree wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the BSpline functions matrix computed with <parameters>, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None* Initializes the fields of the object.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        """
        _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_swiginit(self, _AppDef.new_AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute(*args))
    BSplineValue = _swig_new_instance_method(_AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_BSplineValue)
    BezierValue = _swig_new_instance_method(_AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_BezierValue)
    DerivativeFunctionMatrix = _swig_new_instance_method(_AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_DerivativeFunctionMatrix)
    Distance = _swig_new_instance_method(_AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_Distance)
    Error = _swig_new_instance_method(_AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_Error)
    ErrorGradient = _swig_new_instance_method(_AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_ErrorGradient)
    FirstLambda = _swig_new_instance_method(_AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_FirstLambda)
    FunctionMatrix = _swig_new_instance_method(_AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_FunctionMatrix)
    IsDone = _swig_new_instance_method(_AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_IsDone)
    KIndex = _swig_new_instance_method(_AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_KIndex)
    LastLambda = _swig_new_instance_method(_AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_LastLambda)
    Perform = _swig_new_instance_method(_AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_Perform)
    Points = _swig_new_instance_method(_AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_Points)
    Poles = _swig_new_instance_method(_AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_Poles)

    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute

# Register AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute in _AppDef:
_AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_swigregister(AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute)

class AppDef_BSplineCompute(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * The MultiLine <Line> will be approximated until tolerances will be reached. The approximation will be done from degreemin to degreemax with a cutting if the corresponding boolean is True. If <Squares> is True, the computation will be done with no iteration at all. //! The multiplicities of the internal knots is set by default.
        	:param Line:
        	:type Line: AppDef_MultiLine
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-3
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-6
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param parametrization: default value is Approx_ChordLength
        	:type parametrization: Approx_ParametrizationType
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None* The MultiLine <Line> will be approximated until tolerances will be reached. The approximation will be done from degreemin to degreemax with a cutting if the corresponding boolean is True. If <Squares> is True, the computation will be done with no iteration at all.
        	:param Line:
        	:type Line: AppDef_MultiLine
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None* Initializes the fields of the algorithm.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None* Initializes the fields of the algorithm.
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param parametrization: default value is Approx_ChordLength
        	:type parametrization: Approx_ParametrizationType
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        """
        _AppDef.AppDef_BSplineCompute_swiginit(self, _AppDef.new_AppDef_BSplineCompute(*args))
    ChangeValue = _swig_new_instance_method(_AppDef.AppDef_BSplineCompute_ChangeValue)
    Error = _swig_new_instance_method(_AppDef.AppDef_BSplineCompute_Error)
    Init = _swig_new_instance_method(_AppDef.AppDef_BSplineCompute_Init)
    Interpol = _swig_new_instance_method(_AppDef.AppDef_BSplineCompute_Interpol)
    IsAllApproximated = _swig_new_instance_method(_AppDef.AppDef_BSplineCompute_IsAllApproximated)
    IsToleranceReached = _swig_new_instance_method(_AppDef.AppDef_BSplineCompute_IsToleranceReached)
    Parameters = _swig_new_instance_method(_AppDef.AppDef_BSplineCompute_Parameters)
    Perform = _swig_new_instance_method(_AppDef.AppDef_BSplineCompute_Perform)
    SetConstraints = _swig_new_instance_method(_AppDef.AppDef_BSplineCompute_SetConstraints)
    SetContinuity = _swig_new_instance_method(_AppDef.AppDef_BSplineCompute_SetContinuity)
    SetDegrees = _swig_new_instance_method(_AppDef.AppDef_BSplineCompute_SetDegrees)
    SetKnots = _swig_new_instance_method(_AppDef.AppDef_BSplineCompute_SetKnots)
    SetKnotsAndMultiplicities = _swig_new_instance_method(_AppDef.AppDef_BSplineCompute_SetKnotsAndMultiplicities)
    SetParameters = _swig_new_instance_method(_AppDef.AppDef_BSplineCompute_SetParameters)
    SetPeriodic = _swig_new_instance_method(_AppDef.AppDef_BSplineCompute_SetPeriodic)
    SetTolerances = _swig_new_instance_method(_AppDef.AppDef_BSplineCompute_SetTolerances)
    Value = _swig_new_instance_method(_AppDef.AppDef_BSplineCompute_Value)

    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_BSplineCompute

# Register AppDef_BSplineCompute in _AppDef:
_AppDef.AppDef_BSplineCompute_swigregister(AppDef_BSplineCompute)

class AppDef_Compute(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * The MultiLine <Line> will be approximated until tolerances will be reached. The approximation will be done from degreemin to degreemax with a cutting if the corresponding boolean is True. If <Squares> is True, the computation will be done with no iteration at all.
        	:param Line:
        	:type Line: AppDef_MultiLine
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-3
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-6
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param parametrization: default value is Approx_ChordLength
        	:type parametrization: Approx_ParametrizationType
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None* The MultiLine <Line> will be approximated until tolerances will be reached. The approximation will be done from degreemin to degreemax with a cutting if the corresponding boolean is True. If <Squares> is True, the computation will be done with no iteration at all.
        	:param Line:
        	:type Line: AppDef_MultiLine
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None* Initializes the fields of the algorithm.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None* Initializes the fields of the algorithm.
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param parametrization: default value is Approx_ChordLength
        	:type parametrization: Approx_ParametrizationType
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        """
        _AppDef.AppDef_Compute_swiginit(self, _AppDef.new_AppDef_Compute(*args))
    ChangeValue = _swig_new_instance_method(_AppDef.AppDef_Compute_ChangeValue)
    Error = _swig_new_instance_method(_AppDef.AppDef_Compute_Error)
    Init = _swig_new_instance_method(_AppDef.AppDef_Compute_Init)
    IsAllApproximated = _swig_new_instance_method(_AppDef.AppDef_Compute_IsAllApproximated)
    IsToleranceReached = _swig_new_instance_method(_AppDef.AppDef_Compute_IsToleranceReached)
    NbMultiCurves = _swig_new_instance_method(_AppDef.AppDef_Compute_NbMultiCurves)
    Parameters = _swig_new_instance_method(_AppDef.AppDef_Compute_Parameters)
    Parametrization = _swig_new_instance_method(_AppDef.AppDef_Compute_Parametrization)
    Perform = _swig_new_instance_method(_AppDef.AppDef_Compute_Perform)
    SetConstraints = _swig_new_instance_method(_AppDef.AppDef_Compute_SetConstraints)
    SetDegrees = _swig_new_instance_method(_AppDef.AppDef_Compute_SetDegrees)
    SetTolerances = _swig_new_instance_method(_AppDef.AppDef_Compute_SetTolerances)
    SplineValue = _swig_new_instance_method(_AppDef.AppDef_Compute_SplineValue)
    Value = _swig_new_instance_method(_AppDef.AppDef_Compute_Value)

    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_Compute

# Register AppDef_Compute in _AppDef:
_AppDef.AppDef_Compute_swigregister(AppDef_Compute)

class AppDef_Gradient_BFGSOfMyGradientOfCompute(OCC.Core.math.math_BFGS):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        :param F:
        	:type F: math_MultipleVarFunctionWithGradient
        	:param StartingPoint:
        	:type StartingPoint: math_Vector
        	:param Tolerance3d:
        	:type Tolerance3d: float
        	:param Tolerance2d:
        	:type Tolerance2d: float
        	:param Eps:
        	:type Eps: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:rtype: None
        """
        _AppDef.AppDef_Gradient_BFGSOfMyGradientOfCompute_swiginit(self, _AppDef.new_AppDef_Gradient_BFGSOfMyGradientOfCompute(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_Gradient_BFGSOfMyGradientOfCompute

# Register AppDef_Gradient_BFGSOfMyGradientOfCompute in _AppDef:
_AppDef.AppDef_Gradient_BFGSOfMyGradientOfCompute_swigregister(AppDef_Gradient_BFGSOfMyGradientOfCompute)

class AppDef_Gradient_BFGSOfMyGradientbisOfBSplineCompute(OCC.Core.math.math_BFGS):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        :param F:
        	:type F: math_MultipleVarFunctionWithGradient
        	:param StartingPoint:
        	:type StartingPoint: math_Vector
        	:param Tolerance3d:
        	:type Tolerance3d: float
        	:param Tolerance2d:
        	:type Tolerance2d: float
        	:param Eps:
        	:type Eps: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:rtype: None
        """
        _AppDef.AppDef_Gradient_BFGSOfMyGradientbisOfBSplineCompute_swiginit(self, _AppDef.new_AppDef_Gradient_BFGSOfMyGradientbisOfBSplineCompute(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_Gradient_BFGSOfMyGradientbisOfBSplineCompute

# Register AppDef_Gradient_BFGSOfMyGradientbisOfBSplineCompute in _AppDef:
_AppDef.AppDef_Gradient_BFGSOfMyGradientbisOfBSplineCompute_swigregister(AppDef_Gradient_BFGSOfMyGradientbisOfBSplineCompute)

class AppDef_Gradient_BFGSOfTheGradient(OCC.Core.math.math_BFGS):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        :param F:
        	:type F: math_MultipleVarFunctionWithGradient
        	:param StartingPoint:
        	:type StartingPoint: math_Vector
        	:param Tolerance3d:
        	:type Tolerance3d: float
        	:param Tolerance2d:
        	:type Tolerance2d: float
        	:param Eps:
        	:type Eps: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:rtype: None
        """
        _AppDef.AppDef_Gradient_BFGSOfTheGradient_swiginit(self, _AppDef.new_AppDef_Gradient_BFGSOfTheGradient(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_Gradient_BFGSOfTheGradient

# Register AppDef_Gradient_BFGSOfTheGradient in _AppDef:
_AppDef.AppDef_Gradient_BFGSOfTheGradient_swigregister(AppDef_Gradient_BFGSOfTheGradient)

class AppDef_MultiLine(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * creates an undefined MultiLine.
        	:rtype: None* given the number NbMult of MultiPointConstraints of this MultiLine , it initializes all the fields.SetValue must be called in order for the values of the multipoint constraint to be taken into account. An exception is raised if NbMult < 0.
        	:param NbMult:
        	:type NbMult: int
        	:rtype: None* Constructs a MultiLine with an array of MultiPointConstraints.
        	:param tabMultiP:
        	:type tabMultiP: AppDef_Array1OfMultiPointConstraint
        	:rtype: None* The MultiLine constructed will have one line of 3d points without their tangencies.
        	:param tabP3d:
        	:type tabP3d: TColgp_Array1OfPnt
        	:rtype: None* The MultiLine constructed will have one line of 2d points without their tangencies.
        	:param tabP2d:
        	:type tabP2d: TColgp_Array1OfPnt2d
        	:rtype: None
        """
        _AppDef.AppDef_MultiLine_swiginit(self, _AppDef.new_AppDef_MultiLine(*args))
    DumpToString = _swig_new_instance_method(_AppDef.AppDef_MultiLine_DumpToString)
    NbMultiPoints = _swig_new_instance_method(_AppDef.AppDef_MultiLine_NbMultiPoints)
    NbPoints = _swig_new_instance_method(_AppDef.AppDef_MultiLine_NbPoints)
    SetValue = _swig_new_instance_method(_AppDef.AppDef_MultiLine_SetValue)
    Value = _swig_new_instance_method(_AppDef.AppDef_MultiLine_Value)

    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_MultiLine

# Register AppDef_MultiLine in _AppDef:
_AppDef.AppDef_MultiLine_swigregister(AppDef_MultiLine)

class AppDef_MultiPointConstraint(OCC.Core.AppParCurves.AppParCurves_MultiPoint):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * creates an undefined MultiPointConstraint.
        	:rtype: None* constructs a set of Points used to approximate a Multiline. These Points can be of 2 or 3 dimensions. Points will be initialized with SetPoint and SetPoint2d.
        	:param NbPoints:
        	:type NbPoints: int
        	:param NbPoints2d:
        	:type NbPoints2d: int
        	:rtype: None* creates a MultiPoint only composed of 3D points.
        	:param tabP:
        	:type tabP: TColgp_Array1OfPnt
        	:rtype: None* creates a MultiPoint only composed of 2D points.
        	:param tabP:
        	:type tabP: TColgp_Array1OfPnt2d
        	:rtype: None* constructs a set of Points used to approximate a Multiline. These Points can be of 2 or 3 dimensions. Points will be initialized with SetPoint and SetPoint2d.
        	:param tabP:
        	:type tabP: TColgp_Array1OfPnt
        	:param tabP2d:
        	:type tabP2d: TColgp_Array1OfPnt2d
        	:rtype: None* creates a MultiPointConstraint with a constraint of Curvature. An exception is raised if (length of <tabP> + length of <tabP2d> ) is different from (length of <tabVec> + length of <tabVec2d> ) or from (length of <tabCur> + length of <tabCur2d> )
        	:param tabP:
        	:type tabP: TColgp_Array1OfPnt
        	:param tabP2d:
        	:type tabP2d: TColgp_Array1OfPnt2d
        	:param tabVec:
        	:type tabVec: TColgp_Array1OfVec
        	:param tabVec2d:
        	:type tabVec2d: TColgp_Array1OfVec2d
        	:param tabCur:
        	:type tabCur: TColgp_Array1OfVec
        	:param tabCur2d:
        	:type tabCur2d: TColgp_Array1OfVec2d
        	:rtype: None* creates a MultiPointConstraint with a constraint of Tangency. An exception is raised if (length of <tabP> + length of <tabP2d> ) is different from (length of <tabVec> + length of <tabVec2d> )
        	:param tabP:
        	:type tabP: TColgp_Array1OfPnt
        	:param tabP2d:
        	:type tabP2d: TColgp_Array1OfPnt2d
        	:param tabVec:
        	:type tabVec: TColgp_Array1OfVec
        	:param tabVec2d:
        	:type tabVec2d: TColgp_Array1OfVec2d
        	:rtype: None* creates a MultiPointConstraint only composed of 3d points with constraints of curvature. An exception is raised if the length of tabP is different from the length of tabVec or from tabCur.
        	:param tabP:
        	:type tabP: TColgp_Array1OfPnt
        	:param tabVec:
        	:type tabVec: TColgp_Array1OfVec
        	:param tabCur:
        	:type tabCur: TColgp_Array1OfVec
        	:rtype: None* creates a MultiPointConstraint only composed of 3d points with constraints of tangency. An exception is raised if the length of tabP is different from the length of tabVec.
        	:param tabP:
        	:type tabP: TColgp_Array1OfPnt
        	:param tabVec:
        	:type tabVec: TColgp_Array1OfVec
        	:rtype: None* creates a MultiPointConstraint only composed of 2d points with constraints of tangency. An exception is raised if the length of tabP is different from the length of tabVec2d.
        	:param tabP2d:
        	:type tabP2d: TColgp_Array1OfPnt2d
        	:param tabVec2d:
        	:type tabVec2d: TColgp_Array1OfVec2d
        	:rtype: None* creates a MultiPointConstraint only composed of 2d points with constraints of curvature. An exception is raised if the length of tabP is different from the length of tabVec2d or from tabCur2d.
        	:param tabP2d:
        	:type tabP2d: TColgp_Array1OfPnt2d
        	:param tabVec2d:
        	:type tabVec2d: TColgp_Array1OfVec2d
        	:param tabCur2d:
        	:type tabCur2d: TColgp_Array1OfVec2d
        	:rtype: None
        """
        _AppDef.AppDef_MultiPointConstraint_swiginit(self, _AppDef.new_AppDef_MultiPointConstraint(*args))
    Curv = _swig_new_instance_method(_AppDef.AppDef_MultiPointConstraint_Curv)
    Curv2d = _swig_new_instance_method(_AppDef.AppDef_MultiPointConstraint_Curv2d)
    DumpToString = _swig_new_instance_method(_AppDef.AppDef_MultiPointConstraint_DumpToString)
    IsCurvaturePoint = _swig_new_instance_method(_AppDef.AppDef_MultiPointConstraint_IsCurvaturePoint)
    IsTangencyPoint = _swig_new_instance_method(_AppDef.AppDef_MultiPointConstraint_IsTangencyPoint)
    SetCurv = _swig_new_instance_method(_AppDef.AppDef_MultiPointConstraint_SetCurv)
    SetCurv2d = _swig_new_instance_method(_AppDef.AppDef_MultiPointConstraint_SetCurv2d)
    SetTang = _swig_new_instance_method(_AppDef.AppDef_MultiPointConstraint_SetTang)
    SetTang2d = _swig_new_instance_method(_AppDef.AppDef_MultiPointConstraint_SetTang2d)
    Tang = _swig_new_instance_method(_AppDef.AppDef_MultiPointConstraint_Tang)
    Tang2d = _swig_new_instance_method(_AppDef.AppDef_MultiPointConstraint_Tang2d)

    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_MultiPointConstraint

# Register AppDef_MultiPointConstraint in _AppDef:
_AppDef.AppDef_MultiPointConstraint_swigregister(AppDef_MultiPointConstraint)

class AppDef_MyBSplGradientOfBSplineCompute(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Tries to minimize the sum (square(||Qui - Bi*Pi||)) where Pui describe the approximating BSpline curves'Poles and Qi the MultiLine points with a parameter ui. In this algorithm, the parameters ui are the unknowns. The tolerance required on this sum is given by Tol. The desired degree of the resulting curve is Deg.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param Deg:
        	:type Deg: int
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tol2d:
        	:type Tol2d: float
        	:param NbIterations: default value is 1
        	:type NbIterations: int
        	:rtype: None* Tries to minimize the sum (square(||Qui - Bi*Pi||)) where Pui describe the approximating BSpline curves'Poles and Qi the MultiLine points with a parameter ui. In this algorithm, the parameters ui are the unknowns. The tolerance required on this sum is given by Tol. The desired degree of the resulting curve is Deg.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param Deg:
        	:type Deg: int
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tol2d:
        	:type Tol2d: float
        	:param NbIterations:
        	:type NbIterations: int
        	:param lambda1:
        	:type lambda1: float
        	:param lambda2:
        	:type lambda2: float
        	:rtype: None
        """
        _AppDef.AppDef_MyBSplGradientOfBSplineCompute_swiginit(self, _AppDef.new_AppDef_MyBSplGradientOfBSplineCompute(*args))
    AverageError = _swig_new_instance_method(_AppDef.AppDef_MyBSplGradientOfBSplineCompute_AverageError)
    Error = _swig_new_instance_method(_AppDef.AppDef_MyBSplGradientOfBSplineCompute_Error)
    IsDone = _swig_new_instance_method(_AppDef.AppDef_MyBSplGradientOfBSplineCompute_IsDone)
    MaxError2d = _swig_new_instance_method(_AppDef.AppDef_MyBSplGradientOfBSplineCompute_MaxError2d)
    MaxError3d = _swig_new_instance_method(_AppDef.AppDef_MyBSplGradientOfBSplineCompute_MaxError3d)
    Value = _swig_new_instance_method(_AppDef.AppDef_MyBSplGradientOfBSplineCompute_Value)

    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_MyBSplGradientOfBSplineCompute

# Register AppDef_MyBSplGradientOfBSplineCompute in _AppDef:
_AppDef.AppDef_MyBSplGradientOfBSplineCompute_swigregister(AppDef_MyBSplGradientOfBSplineCompute)

class AppDef_MyGradientOfCompute(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Tries to minimize the sum (square(||Qui - Bi*Pi||)) where Pui describe the approximating Bezier curves'Poles and Qi the MultiLine points with a parameter ui. In this algorithm, the parameters ui are the unknowns. The tolerance required on this sum is given by Tol. The desired degree of the resulting curve is Deg.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tol2d:
        	:type Tol2d: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:rtype: None
        """
        _AppDef.AppDef_MyGradientOfCompute_swiginit(self, _AppDef.new_AppDef_MyGradientOfCompute(*args))
    AverageError = _swig_new_instance_method(_AppDef.AppDef_MyGradientOfCompute_AverageError)
    Error = _swig_new_instance_method(_AppDef.AppDef_MyGradientOfCompute_Error)
    IsDone = _swig_new_instance_method(_AppDef.AppDef_MyGradientOfCompute_IsDone)
    MaxError2d = _swig_new_instance_method(_AppDef.AppDef_MyGradientOfCompute_MaxError2d)
    MaxError3d = _swig_new_instance_method(_AppDef.AppDef_MyGradientOfCompute_MaxError3d)
    Value = _swig_new_instance_method(_AppDef.AppDef_MyGradientOfCompute_Value)

    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_MyGradientOfCompute

# Register AppDef_MyGradientOfCompute in _AppDef:
_AppDef.AppDef_MyGradientOfCompute_swigregister(AppDef_MyGradientOfCompute)

class AppDef_MyGradientbisOfBSplineCompute(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Tries to minimize the sum (square(||Qui - Bi*Pi||)) where Pui describe the approximating Bezier curves'Poles and Qi the MultiLine points with a parameter ui. In this algorithm, the parameters ui are the unknowns. The tolerance required on this sum is given by Tol. The desired degree of the resulting curve is Deg.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tol2d:
        	:type Tol2d: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:rtype: None
        """
        _AppDef.AppDef_MyGradientbisOfBSplineCompute_swiginit(self, _AppDef.new_AppDef_MyGradientbisOfBSplineCompute(*args))
    AverageError = _swig_new_instance_method(_AppDef.AppDef_MyGradientbisOfBSplineCompute_AverageError)
    Error = _swig_new_instance_method(_AppDef.AppDef_MyGradientbisOfBSplineCompute_Error)
    IsDone = _swig_new_instance_method(_AppDef.AppDef_MyGradientbisOfBSplineCompute_IsDone)
    MaxError2d = _swig_new_instance_method(_AppDef.AppDef_MyGradientbisOfBSplineCompute_MaxError2d)
    MaxError3d = _swig_new_instance_method(_AppDef.AppDef_MyGradientbisOfBSplineCompute_MaxError3d)
    Value = _swig_new_instance_method(_AppDef.AppDef_MyGradientbisOfBSplineCompute_Value)

    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_MyGradientbisOfBSplineCompute

# Register AppDef_MyGradientbisOfBSplineCompute in _AppDef:
_AppDef.AppDef_MyGradientbisOfBSplineCompute_swigregister(AppDef_MyGradientbisOfBSplineCompute)

class AppDef_MyLineTool(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Curvature = _swig_new_static_method(_AppDef.AppDef_MyLineTool_Curvature)
    FirstPoint = _swig_new_static_method(_AppDef.AppDef_MyLineTool_FirstPoint)
    LastPoint = _swig_new_static_method(_AppDef.AppDef_MyLineTool_LastPoint)
    MakeMLBetween = _swig_new_static_method(_AppDef.AppDef_MyLineTool_MakeMLBetween)
    MakeMLOneMorePoint = _swig_new_static_method(_AppDef.AppDef_MyLineTool_MakeMLOneMorePoint)
    NbP2d = _swig_new_static_method(_AppDef.AppDef_MyLineTool_NbP2d)
    NbP3d = _swig_new_static_method(_AppDef.AppDef_MyLineTool_NbP3d)
    Tangency = _swig_new_static_method(_AppDef.AppDef_MyLineTool_Tangency)
    Value = _swig_new_static_method(_AppDef.AppDef_MyLineTool_Value)
    WhatStatus = _swig_new_static_method(_AppDef.AppDef_MyLineTool_WhatStatus)

    __repr__ = _dumps_object


    def __init__(self):
        _AppDef.AppDef_MyLineTool_swiginit(self, _AppDef.new_AppDef_MyLineTool())
    __swig_destroy__ = _AppDef.delete_AppDef_MyLineTool

# Register AppDef_MyLineTool in _AppDef:
_AppDef.AppDef_MyLineTool_swigregister(AppDef_MyLineTool)
AppDef_MyLineTool_Curvature = _AppDef.AppDef_MyLineTool_Curvature
AppDef_MyLineTool_FirstPoint = _AppDef.AppDef_MyLineTool_FirstPoint
AppDef_MyLineTool_LastPoint = _AppDef.AppDef_MyLineTool_LastPoint
AppDef_MyLineTool_MakeMLBetween = _AppDef.AppDef_MyLineTool_MakeMLBetween
AppDef_MyLineTool_MakeMLOneMorePoint = _AppDef.AppDef_MyLineTool_MakeMLOneMorePoint
AppDef_MyLineTool_NbP2d = _AppDef.AppDef_MyLineTool_NbP2d
AppDef_MyLineTool_NbP3d = _AppDef.AppDef_MyLineTool_NbP3d
AppDef_MyLineTool_Tangency = _AppDef.AppDef_MyLineTool_Tangency
AppDef_MyLineTool_Value = _AppDef.AppDef_MyLineTool_Value
AppDef_MyLineTool_WhatStatus = _AppDef.AppDef_MyLineTool_WhatStatus

class AppDef_ParFunctionOfMyGradientOfCompute(OCC.Core.math.math_MultipleVarFunctionWithGradient):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * initializes the fields of the function. The approximating curve has the desired degree Deg.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:rtype: None
        """
        _AppDef.AppDef_ParFunctionOfMyGradientOfCompute_swiginit(self, _AppDef.new_AppDef_ParFunctionOfMyGradientOfCompute(*args))
    CurveValue = _swig_new_instance_method(_AppDef.AppDef_ParFunctionOfMyGradientOfCompute_CurveValue)
    Error = _swig_new_instance_method(_AppDef.AppDef_ParFunctionOfMyGradientOfCompute_Error)
    FirstConstraint = _swig_new_instance_method(_AppDef.AppDef_ParFunctionOfMyGradientOfCompute_FirstConstraint)
    LastConstraint = _swig_new_instance_method(_AppDef.AppDef_ParFunctionOfMyGradientOfCompute_LastConstraint)
    MaxError2d = _swig_new_instance_method(_AppDef.AppDef_ParFunctionOfMyGradientOfCompute_MaxError2d)
    MaxError3d = _swig_new_instance_method(_AppDef.AppDef_ParFunctionOfMyGradientOfCompute_MaxError3d)
    NewParameters = _swig_new_instance_method(_AppDef.AppDef_ParFunctionOfMyGradientOfCompute_NewParameters)

    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_ParFunctionOfMyGradientOfCompute

# Register AppDef_ParFunctionOfMyGradientOfCompute in _AppDef:
_AppDef.AppDef_ParFunctionOfMyGradientOfCompute_swigregister(AppDef_ParFunctionOfMyGradientOfCompute)

class AppDef_ParFunctionOfMyGradientbisOfBSplineCompute(OCC.Core.math.math_MultipleVarFunctionWithGradient):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * initializes the fields of the function. The approximating curve has the desired degree Deg.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:rtype: None
        """
        _AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_swiginit(self, _AppDef.new_AppDef_ParFunctionOfMyGradientbisOfBSplineCompute(*args))
    CurveValue = _swig_new_instance_method(_AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_CurveValue)
    Error = _swig_new_instance_method(_AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_Error)
    FirstConstraint = _swig_new_instance_method(_AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_FirstConstraint)
    LastConstraint = _swig_new_instance_method(_AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_LastConstraint)
    MaxError2d = _swig_new_instance_method(_AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_MaxError2d)
    MaxError3d = _swig_new_instance_method(_AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_MaxError3d)
    NewParameters = _swig_new_instance_method(_AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_NewParameters)

    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_ParFunctionOfMyGradientbisOfBSplineCompute

# Register AppDef_ParFunctionOfMyGradientbisOfBSplineCompute in _AppDef:
_AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_swigregister(AppDef_ParFunctionOfMyGradientbisOfBSplineCompute)

class AppDef_ParFunctionOfTheGradient(OCC.Core.math.math_MultipleVarFunctionWithGradient):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * initializes the fields of the function. The approximating curve has the desired degree Deg.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:rtype: None
        """
        _AppDef.AppDef_ParFunctionOfTheGradient_swiginit(self, _AppDef.new_AppDef_ParFunctionOfTheGradient(*args))
    CurveValue = _swig_new_instance_method(_AppDef.AppDef_ParFunctionOfTheGradient_CurveValue)
    Error = _swig_new_instance_method(_AppDef.AppDef_ParFunctionOfTheGradient_Error)
    FirstConstraint = _swig_new_instance_method(_AppDef.AppDef_ParFunctionOfTheGradient_FirstConstraint)
    LastConstraint = _swig_new_instance_method(_AppDef.AppDef_ParFunctionOfTheGradient_LastConstraint)
    MaxError2d = _swig_new_instance_method(_AppDef.AppDef_ParFunctionOfTheGradient_MaxError2d)
    MaxError3d = _swig_new_instance_method(_AppDef.AppDef_ParFunctionOfTheGradient_MaxError3d)
    NewParameters = _swig_new_instance_method(_AppDef.AppDef_ParFunctionOfTheGradient_NewParameters)

    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_ParFunctionOfTheGradient

# Register AppDef_ParFunctionOfTheGradient in _AppDef:
_AppDef.AppDef_ParFunctionOfTheGradient_swigregister(AppDef_ParFunctionOfTheGradient)

class AppDef_ParLeastSquareOfMyGradientOfCompute(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. NbPol is the number of control points wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the Bernstein matrix computed with the parameters, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None* Initializes the fields of the object.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None* given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. Deg is the degree wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the BSpline functions matrix computed with <parameters>, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None* Initializes the fields of the object.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        """
        _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_swiginit(self, _AppDef.new_AppDef_ParLeastSquareOfMyGradientOfCompute(*args))
    BSplineValue = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_BSplineValue)
    BezierValue = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_BezierValue)
    DerivativeFunctionMatrix = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_DerivativeFunctionMatrix)
    Distance = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_Distance)
    Error = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_Error)
    ErrorGradient = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_ErrorGradient)
    FirstLambda = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_FirstLambda)
    FunctionMatrix = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_FunctionMatrix)
    IsDone = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_IsDone)
    KIndex = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_KIndex)
    LastLambda = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_LastLambda)
    Perform = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_Perform)
    Points = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_Points)
    Poles = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_Poles)

    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_ParLeastSquareOfMyGradientOfCompute

# Register AppDef_ParLeastSquareOfMyGradientOfCompute in _AppDef:
_AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_swigregister(AppDef_ParLeastSquareOfMyGradientOfCompute)

class AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. NbPol is the number of control points wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the Bernstein matrix computed with the parameters, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None* Initializes the fields of the object.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None* given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. Deg is the degree wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the BSpline functions matrix computed with <parameters>, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None* Initializes the fields of the object.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        """
        _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_swiginit(self, _AppDef.new_AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute(*args))
    BSplineValue = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_BSplineValue)
    BezierValue = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_BezierValue)
    DerivativeFunctionMatrix = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_DerivativeFunctionMatrix)
    Distance = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_Distance)
    Error = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_Error)
    ErrorGradient = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_ErrorGradient)
    FirstLambda = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_FirstLambda)
    FunctionMatrix = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_FunctionMatrix)
    IsDone = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_IsDone)
    KIndex = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_KIndex)
    LastLambda = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_LastLambda)
    Perform = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_Perform)
    Points = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_Points)
    Poles = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_Poles)

    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute

# Register AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute in _AppDef:
_AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_swigregister(AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute)

class AppDef_ParLeastSquareOfTheGradient(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. NbPol is the number of control points wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the Bernstein matrix computed with the parameters, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None* Initializes the fields of the object.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None* given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. Deg is the degree wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the BSpline functions matrix computed with <parameters>, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None* Initializes the fields of the object.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        """
        _AppDef.AppDef_ParLeastSquareOfTheGradient_swiginit(self, _AppDef.new_AppDef_ParLeastSquareOfTheGradient(*args))
    BSplineValue = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfTheGradient_BSplineValue)
    BezierValue = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfTheGradient_BezierValue)
    DerivativeFunctionMatrix = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfTheGradient_DerivativeFunctionMatrix)
    Distance = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfTheGradient_Distance)
    Error = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfTheGradient_Error)
    ErrorGradient = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfTheGradient_ErrorGradient)
    FirstLambda = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfTheGradient_FirstLambda)
    FunctionMatrix = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfTheGradient_FunctionMatrix)
    IsDone = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfTheGradient_IsDone)
    KIndex = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfTheGradient_KIndex)
    LastLambda = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfTheGradient_LastLambda)
    Perform = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfTheGradient_Perform)
    Points = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfTheGradient_Points)
    Poles = _swig_new_instance_method(_AppDef.AppDef_ParLeastSquareOfTheGradient_Poles)

    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_ParLeastSquareOfTheGradient

# Register AppDef_ParLeastSquareOfTheGradient in _AppDef:
_AppDef.AppDef_ParLeastSquareOfTheGradient_swigregister(AppDef_ParLeastSquareOfTheGradient)

class AppDef_ResConstraintOfMyGradientOfCompute(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Given a MultiLine SSP with constraints points, this algorithm finds the best curve solution to approximate it. The poles from SCurv issued for example from the least squares are used as a guess solution for the uzawa algorithm. The tolerance used in the Uzawa algorithms is Tolerance. A is the Bernstein matrix associated to the MultiLine and DA is the derivative bernstein matrix.(They can come from an approximation with ParLeastSquare.) The MultiCurve is modified. New MultiPoles are given.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param SCurv:
        	:type SCurv: AppParCurves_MultiCurve
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param Constraints:
        	:type Constraints: AppParCurves_HArray1OfConstraintCouple
        	:param Bern:
        	:type Bern: math_Matrix
        	:param DerivativeBern:
        	:type DerivativeBern: math_Matrix
        	:param Tolerance: default value is 1.0e-10
        	:type Tolerance: float
        	:rtype: None
        """
        _AppDef.AppDef_ResConstraintOfMyGradientOfCompute_swiginit(self, _AppDef.new_AppDef_ResConstraintOfMyGradientOfCompute(*args))
    ConstraintDerivative = _swig_new_instance_method(_AppDef.AppDef_ResConstraintOfMyGradientOfCompute_ConstraintDerivative)
    ConstraintMatrix = _swig_new_instance_method(_AppDef.AppDef_ResConstraintOfMyGradientOfCompute_ConstraintMatrix)
    Duale = _swig_new_instance_method(_AppDef.AppDef_ResConstraintOfMyGradientOfCompute_Duale)
    InverseMatrix = _swig_new_instance_method(_AppDef.AppDef_ResConstraintOfMyGradientOfCompute_InverseMatrix)
    IsDone = _swig_new_instance_method(_AppDef.AppDef_ResConstraintOfMyGradientOfCompute_IsDone)

    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_ResConstraintOfMyGradientOfCompute

# Register AppDef_ResConstraintOfMyGradientOfCompute in _AppDef:
_AppDef.AppDef_ResConstraintOfMyGradientOfCompute_swigregister(AppDef_ResConstraintOfMyGradientOfCompute)

class AppDef_ResConstraintOfMyGradientbisOfBSplineCompute(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Given a MultiLine SSP with constraints points, this algorithm finds the best curve solution to approximate it. The poles from SCurv issued for example from the least squares are used as a guess solution for the uzawa algorithm. The tolerance used in the Uzawa algorithms is Tolerance. A is the Bernstein matrix associated to the MultiLine and DA is the derivative bernstein matrix.(They can come from an approximation with ParLeastSquare.) The MultiCurve is modified. New MultiPoles are given.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param SCurv:
        	:type SCurv: AppParCurves_MultiCurve
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param Constraints:
        	:type Constraints: AppParCurves_HArray1OfConstraintCouple
        	:param Bern:
        	:type Bern: math_Matrix
        	:param DerivativeBern:
        	:type DerivativeBern: math_Matrix
        	:param Tolerance: default value is 1.0e-10
        	:type Tolerance: float
        	:rtype: None
        """
        _AppDef.AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_swiginit(self, _AppDef.new_AppDef_ResConstraintOfMyGradientbisOfBSplineCompute(*args))
    ConstraintDerivative = _swig_new_instance_method(_AppDef.AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_ConstraintDerivative)
    ConstraintMatrix = _swig_new_instance_method(_AppDef.AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_ConstraintMatrix)
    Duale = _swig_new_instance_method(_AppDef.AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_Duale)
    InverseMatrix = _swig_new_instance_method(_AppDef.AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_InverseMatrix)
    IsDone = _swig_new_instance_method(_AppDef.AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_IsDone)

    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_ResConstraintOfMyGradientbisOfBSplineCompute

# Register AppDef_ResConstraintOfMyGradientbisOfBSplineCompute in _AppDef:
_AppDef.AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_swigregister(AppDef_ResConstraintOfMyGradientbisOfBSplineCompute)

class AppDef_ResConstraintOfTheGradient(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Given a MultiLine SSP with constraints points, this algorithm finds the best curve solution to approximate it. The poles from SCurv issued for example from the least squares are used as a guess solution for the uzawa algorithm. The tolerance used in the Uzawa algorithms is Tolerance. A is the Bernstein matrix associated to the MultiLine and DA is the derivative bernstein matrix.(They can come from an approximation with ParLeastSquare.) The MultiCurve is modified. New MultiPoles are given.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param SCurv:
        	:type SCurv: AppParCurves_MultiCurve
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param Constraints:
        	:type Constraints: AppParCurves_HArray1OfConstraintCouple
        	:param Bern:
        	:type Bern: math_Matrix
        	:param DerivativeBern:
        	:type DerivativeBern: math_Matrix
        	:param Tolerance: default value is 1.0e-10
        	:type Tolerance: float
        	:rtype: None
        """
        _AppDef.AppDef_ResConstraintOfTheGradient_swiginit(self, _AppDef.new_AppDef_ResConstraintOfTheGradient(*args))
    ConstraintDerivative = _swig_new_instance_method(_AppDef.AppDef_ResConstraintOfTheGradient_ConstraintDerivative)
    ConstraintMatrix = _swig_new_instance_method(_AppDef.AppDef_ResConstraintOfTheGradient_ConstraintMatrix)
    Duale = _swig_new_instance_method(_AppDef.AppDef_ResConstraintOfTheGradient_Duale)
    InverseMatrix = _swig_new_instance_method(_AppDef.AppDef_ResConstraintOfTheGradient_InverseMatrix)
    IsDone = _swig_new_instance_method(_AppDef.AppDef_ResConstraintOfTheGradient_IsDone)

    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_ResConstraintOfTheGradient

# Register AppDef_ResConstraintOfTheGradient in _AppDef:
_AppDef.AppDef_ResConstraintOfTheGradient_swigregister(AppDef_ResConstraintOfTheGradient)

class AppDef_SmoothCriterion(OCC.Core.Standard.Standard_Transient):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    AssemblyTable = _swig_new_instance_method(_AppDef.AppDef_SmoothCriterion_AssemblyTable)
    DependenceTable = _swig_new_instance_method(_AppDef.AppDef_SmoothCriterion_DependenceTable)
    ErrorValues = _swig_new_instance_method(_AppDef.AppDef_SmoothCriterion_ErrorValues)
    EstLength = _swig_new_instance_method(_AppDef.AppDef_SmoothCriterion_EstLength)
    GetCurve = _swig_new_instance_method(_AppDef.AppDef_SmoothCriterion_GetCurve)
    GetEstimation = _swig_new_instance_method(_AppDef.AppDef_SmoothCriterion_GetEstimation)
    GetWeight = _swig_new_instance_method(_AppDef.AppDef_SmoothCriterion_GetWeight)
    Gradient = _swig_new_instance_method(_AppDef.AppDef_SmoothCriterion_Gradient)
    Hessian = _swig_new_instance_method(_AppDef.AppDef_SmoothCriterion_Hessian)
    InputVector = _swig_new_instance_method(_AppDef.AppDef_SmoothCriterion_InputVector)
    QualityValues = _swig_new_instance_method(_AppDef.AppDef_SmoothCriterion_QualityValues)
    SetCurve = _swig_new_instance_method(_AppDef.AppDef_SmoothCriterion_SetCurve)
    SetEstimation = _swig_new_instance_method(_AppDef.AppDef_SmoothCriterion_SetEstimation)
    SetParameters = _swig_new_instance_method(_AppDef.AppDef_SmoothCriterion_SetParameters)
    SetWeight = _swig_new_instance_method(_AppDef.AppDef_SmoothCriterion_SetWeight)


    @staticmethod
    def DownCast(t):
      return Handle_AppDef_SmoothCriterion_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_SmoothCriterion

# Register AppDef_SmoothCriterion in _AppDef:
_AppDef.AppDef_SmoothCriterion_swigregister(AppDef_SmoothCriterion)

class AppDef_TheFunction(OCC.Core.math.math_MultipleVarFunctionWithGradient):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * initializes the fields of the function. The approximating curve has the desired degree Deg.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:rtype: None
        """
        _AppDef.AppDef_TheFunction_swiginit(self, _AppDef.new_AppDef_TheFunction(*args))
    CurveValue = _swig_new_instance_method(_AppDef.AppDef_TheFunction_CurveValue)
    Error = _swig_new_instance_method(_AppDef.AppDef_TheFunction_Error)
    FirstConstraint = _swig_new_instance_method(_AppDef.AppDef_TheFunction_FirstConstraint)
    LastConstraint = _swig_new_instance_method(_AppDef.AppDef_TheFunction_LastConstraint)
    MaxError2d = _swig_new_instance_method(_AppDef.AppDef_TheFunction_MaxError2d)
    MaxError3d = _swig_new_instance_method(_AppDef.AppDef_TheFunction_MaxError3d)
    NewParameters = _swig_new_instance_method(_AppDef.AppDef_TheFunction_NewParameters)

    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_TheFunction

# Register AppDef_TheFunction in _AppDef:
_AppDef.AppDef_TheFunction_swigregister(AppDef_TheFunction)

class AppDef_TheGradient(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Tries to minimize the sum (square(||Qui - Bi*Pi||)) where Pui describe the approximating Bezier curves'Poles and Qi the MultiLine points with a parameter ui. In this algorithm, the parameters ui are the unknowns. The tolerance required on this sum is given by Tol. The desired degree of the resulting curve is Deg.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tol2d:
        	:type Tol2d: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:rtype: None
        """
        _AppDef.AppDef_TheGradient_swiginit(self, _AppDef.new_AppDef_TheGradient(*args))
    AverageError = _swig_new_instance_method(_AppDef.AppDef_TheGradient_AverageError)
    Error = _swig_new_instance_method(_AppDef.AppDef_TheGradient_Error)
    IsDone = _swig_new_instance_method(_AppDef.AppDef_TheGradient_IsDone)
    MaxError2d = _swig_new_instance_method(_AppDef.AppDef_TheGradient_MaxError2d)
    MaxError3d = _swig_new_instance_method(_AppDef.AppDef_TheGradient_MaxError3d)
    Value = _swig_new_instance_method(_AppDef.AppDef_TheGradient_Value)

    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_TheGradient

# Register AppDef_TheGradient in _AppDef:
_AppDef.AppDef_TheGradient_swigregister(AppDef_TheGradient)

class AppDef_TheLeastSquares(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. NbPol is the number of control points wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the Bernstein matrix computed with the parameters, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None* Initializes the fields of the object.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None* given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. Deg is the degree wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the BSpline functions matrix computed with <parameters>, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None* Initializes the fields of the object.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        """
        _AppDef.AppDef_TheLeastSquares_swiginit(self, _AppDef.new_AppDef_TheLeastSquares(*args))
    BSplineValue = _swig_new_instance_method(_AppDef.AppDef_TheLeastSquares_BSplineValue)
    BezierValue = _swig_new_instance_method(_AppDef.AppDef_TheLeastSquares_BezierValue)
    DerivativeFunctionMatrix = _swig_new_instance_method(_AppDef.AppDef_TheLeastSquares_DerivativeFunctionMatrix)
    Distance = _swig_new_instance_method(_AppDef.AppDef_TheLeastSquares_Distance)
    Error = _swig_new_instance_method(_AppDef.AppDef_TheLeastSquares_Error)
    ErrorGradient = _swig_new_instance_method(_AppDef.AppDef_TheLeastSquares_ErrorGradient)
    FirstLambda = _swig_new_instance_method(_AppDef.AppDef_TheLeastSquares_FirstLambda)
    FunctionMatrix = _swig_new_instance_method(_AppDef.AppDef_TheLeastSquares_FunctionMatrix)
    IsDone = _swig_new_instance_method(_AppDef.AppDef_TheLeastSquares_IsDone)
    KIndex = _swig_new_instance_method(_AppDef.AppDef_TheLeastSquares_KIndex)
    LastLambda = _swig_new_instance_method(_AppDef.AppDef_TheLeastSquares_LastLambda)
    Perform = _swig_new_instance_method(_AppDef.AppDef_TheLeastSquares_Perform)
    Points = _swig_new_instance_method(_AppDef.AppDef_TheLeastSquares_Points)
    Poles = _swig_new_instance_method(_AppDef.AppDef_TheLeastSquares_Poles)

    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_TheLeastSquares

# Register AppDef_TheLeastSquares in _AppDef:
_AppDef.AppDef_TheLeastSquares_swigregister(AppDef_TheLeastSquares)

class AppDef_TheResol(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Given a MultiLine SSP with constraints points, this algorithm finds the best curve solution to approximate it. The poles from SCurv issued for example from the least squares are used as a guess solution for the uzawa algorithm. The tolerance used in the Uzawa algorithms is Tolerance. A is the Bernstein matrix associated to the MultiLine and DA is the derivative bernstein matrix.(They can come from an approximation with ParLeastSquare.) The MultiCurve is modified. New MultiPoles are given.
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param SCurv:
        	:type SCurv: AppParCurves_MultiCurve
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param Constraints:
        	:type Constraints: AppParCurves_HArray1OfConstraintCouple
        	:param Bern:
        	:type Bern: math_Matrix
        	:param DerivativeBern:
        	:type DerivativeBern: math_Matrix
        	:param Tolerance: default value is 1.0e-10
        	:type Tolerance: float
        	:rtype: None
        """
        _AppDef.AppDef_TheResol_swiginit(self, _AppDef.new_AppDef_TheResol(*args))
    ConstraintDerivative = _swig_new_instance_method(_AppDef.AppDef_TheResol_ConstraintDerivative)
    ConstraintMatrix = _swig_new_instance_method(_AppDef.AppDef_TheResol_ConstraintMatrix)
    Duale = _swig_new_instance_method(_AppDef.AppDef_TheResol_Duale)
    InverseMatrix = _swig_new_instance_method(_AppDef.AppDef_TheResol_InverseMatrix)
    IsDone = _swig_new_instance_method(_AppDef.AppDef_TheResol_IsDone)

    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_TheResol

# Register AppDef_TheResol in _AppDef:
_AppDef.AppDef_TheResol_swigregister(AppDef_TheResol)

class AppDef_Variational(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Constructor. Initialization of the fields. warning : Nc0 : number of PassagePoint consraints Nc2 : number of TangencyPoint constraints Nc3 : number of CurvaturePoint constraints if ((MaxDegree-Continuity)*MaxSegment -Nc0 - 2*Nc1 -3*Nc2) is negative The problem is over-constrained. //! Limitation : The MultiLine from AppDef has to be composed by only one Line ( Dimension 2 or 3).
        	:param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param MaxDegree: default value is 14
        	:type MaxDegree: int
        	:param MaxSegment: default value is 100
        	:type MaxSegment: int
        	:param Continuity: default value is GeomAbs_C2
        	:type Continuity: GeomAbs_Shape
        	:param WithMinMax: default value is Standard_False
        	:type WithMinMax: bool
        	:param WithCutting: default value is Standard_True
        	:type WithCutting: bool
        	:param Tolerance: default value is 1.0
        	:type Tolerance: float
        	:param NbIterations: default value is 2
        	:type NbIterations: int
        	:rtype: None
        """
        _AppDef.AppDef_Variational_swiginit(self, _AppDef.new_AppDef_Variational(*args))
    Approximate = _swig_new_instance_method(_AppDef.AppDef_Variational_Approximate)
    AverageError = _swig_new_instance_method(_AppDef.AppDef_Variational_AverageError)
    Continuity = _swig_new_instance_method(_AppDef.AppDef_Variational_Continuity)
    Criterium = _swig_new_instance_method(_AppDef.AppDef_Variational_Criterium)
    CriteriumWeight = _swig_new_instance_method(_AppDef.AppDef_Variational_CriteriumWeight)
    Distance = _swig_new_instance_method(_AppDef.AppDef_Variational_Distance)
    DumpToString = _swig_new_instance_method(_AppDef.AppDef_Variational_DumpToString)
    IsCreated = _swig_new_instance_method(_AppDef.AppDef_Variational_IsCreated)
    IsDone = _swig_new_instance_method(_AppDef.AppDef_Variational_IsDone)
    IsOverConstrained = _swig_new_instance_method(_AppDef.AppDef_Variational_IsOverConstrained)
    Knots = _swig_new_instance_method(_AppDef.AppDef_Variational_Knots)
    MaxDegree = _swig_new_instance_method(_AppDef.AppDef_Variational_MaxDegree)
    MaxError = _swig_new_instance_method(_AppDef.AppDef_Variational_MaxError)
    MaxErrorIndex = _swig_new_instance_method(_AppDef.AppDef_Variational_MaxErrorIndex)
    MaxSegment = _swig_new_instance_method(_AppDef.AppDef_Variational_MaxSegment)
    NbIterations = _swig_new_instance_method(_AppDef.AppDef_Variational_NbIterations)
    Parameters = _swig_new_instance_method(_AppDef.AppDef_Variational_Parameters)
    QuadraticError = _swig_new_instance_method(_AppDef.AppDef_Variational_QuadraticError)
    SetConstraints = _swig_new_instance_method(_AppDef.AppDef_Variational_SetConstraints)
    SetContinuity = _swig_new_instance_method(_AppDef.AppDef_Variational_SetContinuity)
    SetCriteriumWeight = _swig_new_instance_method(_AppDef.AppDef_Variational_SetCriteriumWeight)
    SetKnots = _swig_new_instance_method(_AppDef.AppDef_Variational_SetKnots)
    SetMaxDegree = _swig_new_instance_method(_AppDef.AppDef_Variational_SetMaxDegree)
    SetMaxSegment = _swig_new_instance_method(_AppDef.AppDef_Variational_SetMaxSegment)
    SetNbIterations = _swig_new_instance_method(_AppDef.AppDef_Variational_SetNbIterations)
    SetParameters = _swig_new_instance_method(_AppDef.AppDef_Variational_SetParameters)
    SetTolerance = _swig_new_instance_method(_AppDef.AppDef_Variational_SetTolerance)
    SetWithCutting = _swig_new_instance_method(_AppDef.AppDef_Variational_SetWithCutting)
    SetWithMinMax = _swig_new_instance_method(_AppDef.AppDef_Variational_SetWithMinMax)
    Tolerance = _swig_new_instance_method(_AppDef.AppDef_Variational_Tolerance)
    Value = _swig_new_instance_method(_AppDef.AppDef_Variational_Value)
    WithCutting = _swig_new_instance_method(_AppDef.AppDef_Variational_WithCutting)
    WithMinMax = _swig_new_instance_method(_AppDef.AppDef_Variational_WithMinMax)

    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_Variational

# Register AppDef_Variational in _AppDef:
_AppDef.AppDef_Variational_swigregister(AppDef_Variational)

class AppDef_LinearCriteria(AppDef_SmoothCriterion):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        :param SSP:
        	:type SSP: AppDef_MultiLine
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:rtype: None
        """
        _AppDef.AppDef_LinearCriteria_swiginit(self, _AppDef.new_AppDef_LinearCriteria(*args))
    GetEstLength = _swig_new_instance_method(_AppDef.AppDef_LinearCriteria_GetEstLength)
    SetEstLength = _swig_new_instance_method(_AppDef.AppDef_LinearCriteria_SetEstLength)
    SetWeight = _swig_new_instance_method(_AppDef.AppDef_LinearCriteria_SetWeight)


    @staticmethod
    def DownCast(t):
      return Handle_AppDef_LinearCriteria_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_LinearCriteria

# Register AppDef_LinearCriteria in _AppDef:
_AppDef.AppDef_LinearCriteria_swigregister(AppDef_LinearCriteria)

class AppDef_HArray1OfMultiPointConstraint(AppDef_Array1OfMultiPointConstraint, OCC.Core.Standard.Standard_Transient):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _AppDef.AppDef_HArray1OfMultiPointConstraint_swiginit(self, _AppDef.new_AppDef_HArray1OfMultiPointConstraint(*args))
    Array1 = _swig_new_instance_method(_AppDef.AppDef_HArray1OfMultiPointConstraint_Array1)
    ChangeArray1 = _swig_new_instance_method(_AppDef.AppDef_HArray1OfMultiPointConstraint_ChangeArray1)


    @staticmethod
    def DownCast(t):
      return Handle_AppDef_HArray1OfMultiPointConstraint_DownCast(t)

    __swig_destroy__ = _AppDef.delete_AppDef_HArray1OfMultiPointConstraint

# Register AppDef_HArray1OfMultiPointConstraint in _AppDef:
_AppDef.AppDef_HArray1OfMultiPointConstraint_swigregister(AppDef_HArray1OfMultiPointConstraint)



