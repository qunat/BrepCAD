# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
GccAna module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_gccana.html
"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _GccAna
else:
    import _GccAna

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _GccAna.SWIG_PyInstanceMethod_New
_swig_new_static_method = _GccAna.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _GccAna.delete_SwigPyIterator
    value = _swig_new_instance_method(_GccAna.SwigPyIterator_value)
    incr = _swig_new_instance_method(_GccAna.SwigPyIterator_incr)
    decr = _swig_new_instance_method(_GccAna.SwigPyIterator_decr)
    distance = _swig_new_instance_method(_GccAna.SwigPyIterator_distance)
    equal = _swig_new_instance_method(_GccAna.SwigPyIterator_equal)
    copy = _swig_new_instance_method(_GccAna.SwigPyIterator_copy)
    next = _swig_new_instance_method(_GccAna.SwigPyIterator_next)
    __next__ = _swig_new_instance_method(_GccAna.SwigPyIterator___next__)
    previous = _swig_new_instance_method(_GccAna.SwigPyIterator_previous)
    advance = _swig_new_instance_method(_GccAna.SwigPyIterator_advance)
    __eq__ = _swig_new_instance_method(_GccAna.SwigPyIterator___eq__)
    __ne__ = _swig_new_instance_method(_GccAna.SwigPyIterator___ne__)
    __iadd__ = _swig_new_instance_method(_GccAna.SwigPyIterator___iadd__)
    __isub__ = _swig_new_instance_method(_GccAna.SwigPyIterator___isub__)
    __add__ = _swig_new_instance_method(_GccAna.SwigPyIterator___add__)
    __sub__ = _swig_new_instance_method(_GccAna.SwigPyIterator___sub__)
    def __iter__(self):
        return self

# Register SwigPyIterator in _GccAna:
_GccAna.SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.gp
import OCC.Core.GccEnt
import OCC.Core.GccInt
class GccAna_Circ2d2TanOn(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    CenterOn3 = _swig_new_instance_method(_GccAna.GccAna_Circ2d2TanOn_CenterOn3)

    def __init__(self, *args):
        r"""
        * This method implements the algorithms used to create 2d circles TANgent to two 2d circles and having the center ON a 2d line.
        	:param Qualified1:
        	:type Qualified1: GccEnt_QualifiedCirc
        	:param Qualified2:
        	:type Qualified2: GccEnt_QualifiedCirc
        	:param OnLine:
        	:type OnLine: gp_Lin2d
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None* This method implements the algorithms used to create 2d circles TANgent to a 2d circle and a 2d line having the center ON a 2d line.
        	:param Qualified1:
        	:type Qualified1: GccEnt_QualifiedCirc
        	:param Qualified2:
        	:type Qualified2: GccEnt_QualifiedLin
        	:param OnLine:
        	:type OnLine: gp_Lin2d
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None* This method implements the algorithms used to create 2d circles TANgent to two 2d lines having the center ON a 2d line.
        	:param Qualified1:
        	:type Qualified1: GccEnt_QualifiedLin
        	:param Qualified2:
        	:type Qualified2: GccEnt_QualifiedLin
        	:param OnLine:
        	:type OnLine: gp_Lin2d
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None* This method implements the algorithms used to create 2d circles TANgent to a 2d circle and a point having the center ON a 2d line.
        	:param Qualified1:
        	:type Qualified1: GccEnt_QualifiedCirc
        	:param Point2:
        	:type Point2: gp_Pnt2d
        	:param OnLine:
        	:type OnLine: gp_Lin2d
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None* This method implements the algorithms used to create 2d circles TANgent to a 2d line and a point having the center ON a 2d line.
        	:param Qualified1:
        	:type Qualified1: GccEnt_QualifiedLin
        	:param Point2:
        	:type Point2: gp_Pnt2d
        	:param OnLine:
        	:type OnLine: gp_Lin2d
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None* This method implements the algorithms used to create 2d circles TANgent to two points having the center ON a 2d line.
        	:param Point1:
        	:type Point1: gp_Pnt2d
        	:param Point2:
        	:type Point2: gp_Pnt2d
        	:param OnLine:
        	:type OnLine: gp_Lin2d
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None* This method implements the algorithms used to create 2d circles TANgent to two 2d circles and having the center ON a 2d circle.
        	:param Qualified1:
        	:type Qualified1: GccEnt_QualifiedCirc
        	:param Qualified2:
        	:type Qualified2: GccEnt_QualifiedCirc
        	:param OnCirc:
        	:type OnCirc: gp_Circ2d
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None* This method implements the algorithms used to create 2d circles TANgent to a circle and a line having the center ON a 2d circle.
        	:param Qualified1:
        	:type Qualified1: GccEnt_QualifiedCirc
        	:param Qualified2:
        	:type Qualified2: GccEnt_QualifiedLin
        	:param OnCirc:
        	:type OnCirc: gp_Circ2d
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None* This method implements the algorithms used to create 2d circles TANgent to a circle and a point having the center ON a 2d circle.
        	:param Qualified1:
        	:type Qualified1: GccEnt_QualifiedCirc
        	:param Point2:
        	:type Point2: gp_Pnt2d
        	:param OnCirc:
        	:type OnCirc: gp_Circ2d
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None* This method implements the algorithms used to create 2d circles TANgent to two 2d lines having the center ON a 2d circle.
        	:param Qualified1:
        	:type Qualified1: GccEnt_QualifiedLin
        	:param Qualified2:
        	:type Qualified2: GccEnt_QualifiedLin
        	:param OnCirc:
        	:type OnCirc: gp_Circ2d
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None* This method implements the algorithms used to create 2d circles TANgent to a line and a point having the center ON a 2d circle.
        	:param Qualified1:
        	:type Qualified1: GccEnt_QualifiedLin
        	:param Point2:
        	:type Point2: gp_Pnt2d
        	:param OnCirc:
        	:type OnCirc: gp_Circ2d
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None* This method implements the algorithms used to create 2d circles TANgent to two points having the center ON a 2d circle.
        	:param Point1:
        	:type Point1: gp_Pnt2d
        	:param Point2:
        	:type Point2: gp_Pnt2d
        	:param OnCirc:
        	:type OnCirc: gp_Circ2d
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None
        """
        _GccAna.GccAna_Circ2d2TanOn_swiginit(self, _GccAna.new_GccAna_Circ2d2TanOn(*args))
    IsDone = _swig_new_instance_method(_GccAna.GccAna_Circ2d2TanOn_IsDone)
    IsTheSame1 = _swig_new_instance_method(_GccAna.GccAna_Circ2d2TanOn_IsTheSame1)
    IsTheSame2 = _swig_new_instance_method(_GccAna.GccAna_Circ2d2TanOn_IsTheSame2)
    NbSolutions = _swig_new_instance_method(_GccAna.GccAna_Circ2d2TanOn_NbSolutions)
    Tangency1 = _swig_new_instance_method(_GccAna.GccAna_Circ2d2TanOn_Tangency1)
    Tangency2 = _swig_new_instance_method(_GccAna.GccAna_Circ2d2TanOn_Tangency2)
    ThisSolution = _swig_new_instance_method(_GccAna.GccAna_Circ2d2TanOn_ThisSolution)
    WhichQualifier = _swig_new_instance_method(_GccAna.GccAna_Circ2d2TanOn_WhichQualifier)

    __repr__ = _dumps_object

    __swig_destroy__ = _GccAna.delete_GccAna_Circ2d2TanOn

# Register GccAna_Circ2d2TanOn in _GccAna:
_GccAna.GccAna_Circ2d2TanOn_swigregister(GccAna_Circ2d2TanOn)

class GccAna_Circ2d2TanRad(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * This method implements the algorithms used to create 2d circles TANgent to two 2d circle with a radius of Radius. It raises NegativeValue if Radius is lower than zero.
        	:param Qualified1:
        	:type Qualified1: GccEnt_QualifiedCirc
        	:param Qualified2:
        	:type Qualified2: GccEnt_QualifiedCirc
        	:param Radius:
        	:type Radius: float
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None* This method implements the algorithms used to create 2d circles TANgent to a 2d circle and a 2d line with a radius of Radius. It raises NegativeValue if Radius is lower than zero.
        	:param Qualified1:
        	:type Qualified1: GccEnt_QualifiedCirc
        	:param Qualified2:
        	:type Qualified2: GccEnt_QualifiedLin
        	:param Radius:
        	:type Radius: float
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None* This method implements the algorithms used to create 2d circles TANgent to a 2d circle and a point with a radius of Radius. It raises NegativeValue if Radius is lower than zero.
        	:param Qualified1:
        	:type Qualified1: GccEnt_QualifiedCirc
        	:param Point2:
        	:type Point2: gp_Pnt2d
        	:param Radius:
        	:type Radius: float
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None* This method implements the algorithms used to create 2d circles TANgent to a 2d line and a point with a radius of Radius. It raises NegativeValue if Radius is lower than zero.
        	:param Qualified1:
        	:type Qualified1: GccEnt_QualifiedLin
        	:param Point2:
        	:type Point2: gp_Pnt2d
        	:param Radius:
        	:type Radius: float
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None* This method implements the algorithms used to create 2d circles TANgent to two 2d lines with a radius of Radius. It raises NegativeValue if Radius is lower than zero.
        	:param Qualified1:
        	:type Qualified1: GccEnt_QualifiedLin
        	:param Qualified2:
        	:type Qualified2: GccEnt_QualifiedLin
        	:param Radius:
        	:type Radius: float
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None* This method implements the algorithms used to create 2d circles passing through two points with a radius of Radius. It raises NegativeValue if Radius is lower than zero.
        	:param Point1:
        	:type Point1: gp_Pnt2d
        	:param Point2:
        	:type Point2: gp_Pnt2d
        	:param Radius:
        	:type Radius: float
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None
        """
        _GccAna.GccAna_Circ2d2TanRad_swiginit(self, _GccAna.new_GccAna_Circ2d2TanRad(*args))
    IsDone = _swig_new_instance_method(_GccAna.GccAna_Circ2d2TanRad_IsDone)
    IsTheSame1 = _swig_new_instance_method(_GccAna.GccAna_Circ2d2TanRad_IsTheSame1)
    IsTheSame2 = _swig_new_instance_method(_GccAna.GccAna_Circ2d2TanRad_IsTheSame2)
    NbSolutions = _swig_new_instance_method(_GccAna.GccAna_Circ2d2TanRad_NbSolutions)
    Tangency1 = _swig_new_instance_method(_GccAna.GccAna_Circ2d2TanRad_Tangency1)
    Tangency2 = _swig_new_instance_method(_GccAna.GccAna_Circ2d2TanRad_Tangency2)
    ThisSolution = _swig_new_instance_method(_GccAna.GccAna_Circ2d2TanRad_ThisSolution)
    WhichQualifier = _swig_new_instance_method(_GccAna.GccAna_Circ2d2TanRad_WhichQualifier)

    __repr__ = _dumps_object

    __swig_destroy__ = _GccAna.delete_GccAna_Circ2d2TanRad

# Register GccAna_Circ2d2TanRad in _GccAna:
_GccAna.GccAna_Circ2d2TanRad_swigregister(GccAna_Circ2d2TanRad)

class GccAna_Circ2d3Tan(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * This method implements the algorithms used to create 2d circles tangent to 3 circles. ConstructionError is raised if there is a problem during the computation.
        	:param Qualified1:
        	:type Qualified1: GccEnt_QualifiedCirc
        	:param Qualified2:
        	:type Qualified2: GccEnt_QualifiedCirc
        	:param Qualified3:
        	:type Qualified3: GccEnt_QualifiedCirc
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None* This method implements the algorithms used to create 2d circles tangent to 2 circles and 1 line. ConstructionError is raised if there is a problem during the computation.
        	:param Qualified1:
        	:type Qualified1: GccEnt_QualifiedCirc
        	:param Qualified2:
        	:type Qualified2: GccEnt_QualifiedCirc
        	:param Qualified3:
        	:type Qualified3: GccEnt_QualifiedLin
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None* This method implements the algorithms used to create 2d circles tangent to 1 circle and 2 lines. ConstructionError is raised if there is a problem during the computation.
        	:param Qualified1:
        	:type Qualified1: GccEnt_QualifiedCirc
        	:param Qualified2:
        	:type Qualified2: GccEnt_QualifiedLin
        	:param Qualified3:
        	:type Qualified3: GccEnt_QualifiedLin
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None* This method implements the algorithms used to create 2d circles tangent to 3 lines. ConstructionError is raised if there is a problem during the computation.
        	:param Qualified1:
        	:type Qualified1: GccEnt_QualifiedLin
        	:param Qualified2:
        	:type Qualified2: GccEnt_QualifiedLin
        	:param Qualified3:
        	:type Qualified3: GccEnt_QualifiedLin
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None* This method implements the algorithms used to create 2d circles tangent to 2 circles and 1 Point. ConstructionError is raised if there is a problem during the computation.
        	:param Qualified1:
        	:type Qualified1: GccEnt_QualifiedCirc
        	:param Qualified2:
        	:type Qualified2: GccEnt_QualifiedCirc
        	:param Point3:
        	:type Point3: gp_Pnt2d
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None* This method implements the algorithms used to create 2d circles tangent to a circle and a line and 1 Point. ConstructionError is raised if there is a problem during the computation.
        	:param Qualified1:
        	:type Qualified1: GccEnt_QualifiedCirc
        	:param Qualified2:
        	:type Qualified2: GccEnt_QualifiedLin
        	:param Point3:
        	:type Point3: gp_Pnt2d
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None* This method implements the algorithms used to create 2d circles tangent to 2 lines and 1 Point. ConstructionError is raised if there is a problem during the computation.
        	:param Qualified1:
        	:type Qualified1: GccEnt_QualifiedLin
        	:param Qualified2:
        	:type Qualified2: GccEnt_QualifiedLin
        	:param Point3:
        	:type Point3: gp_Pnt2d
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None* This method implements the algorithms used to create 2d circles tangent to a circle and passing thrue 2 Points. ConstructionError is raised if there is a problem during the computation.
        	:param Qualified1:
        	:type Qualified1: GccEnt_QualifiedCirc
        	:param Point2:
        	:type Point2: gp_Pnt2d
        	:param Point3:
        	:type Point3: gp_Pnt2d
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None* This method implements the algorithms used to create 2d circles tangent to a line and passing thrue 2 Points. ConstructionError is raised if there is a problem during the computation.
        	:param Qualified1:
        	:type Qualified1: GccEnt_QualifiedLin
        	:param Point2:
        	:type Point2: gp_Pnt2d
        	:param Point3:
        	:type Point3: gp_Pnt2d
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None* This method implements the algorithms used to create 2d circles passing thrue 3 Points. ConstructionError is raised if there is a problem during the computation.
        	:param Point1:
        	:type Point1: gp_Pnt2d
        	:param Point2:
        	:type Point2: gp_Pnt2d
        	:param Point3:
        	:type Point3: gp_Pnt2d
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None
        """
        _GccAna.GccAna_Circ2d3Tan_swiginit(self, _GccAna.new_GccAna_Circ2d3Tan(*args))
    IsDone = _swig_new_instance_method(_GccAna.GccAna_Circ2d3Tan_IsDone)
    IsTheSame1 = _swig_new_instance_method(_GccAna.GccAna_Circ2d3Tan_IsTheSame1)
    IsTheSame2 = _swig_new_instance_method(_GccAna.GccAna_Circ2d3Tan_IsTheSame2)
    IsTheSame3 = _swig_new_instance_method(_GccAna.GccAna_Circ2d3Tan_IsTheSame3)
    NbSolutions = _swig_new_instance_method(_GccAna.GccAna_Circ2d3Tan_NbSolutions)
    Tangency1 = _swig_new_instance_method(_GccAna.GccAna_Circ2d3Tan_Tangency1)
    Tangency2 = _swig_new_instance_method(_GccAna.GccAna_Circ2d3Tan_Tangency2)
    Tangency3 = _swig_new_instance_method(_GccAna.GccAna_Circ2d3Tan_Tangency3)
    ThisSolution = _swig_new_instance_method(_GccAna.GccAna_Circ2d3Tan_ThisSolution)
    WhichQualifier = _swig_new_instance_method(_GccAna.GccAna_Circ2d3Tan_WhichQualifier)

    __repr__ = _dumps_object

    __swig_destroy__ = _GccAna.delete_GccAna_Circ2d3Tan

# Register GccAna_Circ2d3Tan in _GccAna:
_GccAna.GccAna_Circ2d3Tan_swigregister(GccAna_Circ2d3Tan)

class GccAna_Circ2dBisec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Constructs bisecting curves between the two circles Circ1 and Circ2.
        	:param Circ1:
        	:type Circ1: gp_Circ2d
        	:param Circ2:
        	:type Circ2: gp_Circ2d
        	:rtype: None
        """
        _GccAna.GccAna_Circ2dBisec_swiginit(self, _GccAna.new_GccAna_Circ2dBisec(*args))
    IsDone = _swig_new_instance_method(_GccAna.GccAna_Circ2dBisec_IsDone)
    NbSolutions = _swig_new_instance_method(_GccAna.GccAna_Circ2dBisec_NbSolutions)
    ThisSolution = _swig_new_instance_method(_GccAna.GccAna_Circ2dBisec_ThisSolution)

    __repr__ = _dumps_object

    __swig_destroy__ = _GccAna.delete_GccAna_Circ2dBisec

# Register GccAna_Circ2dBisec in _GccAna:
_GccAna.GccAna_Circ2dBisec_swigregister(GccAna_Circ2dBisec)

class GccAna_Circ2dTanCen(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * This method implements the algorithms used to create 2d circles tangent to a circle and centered on a point.
        	:param Qualified1:
        	:type Qualified1: GccEnt_QualifiedCirc
        	:param Pcenter:
        	:type Pcenter: gp_Pnt2d
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None* This method implements the algorithms used to create 2d circles tangent to a line and centered on a point.
        	:param Linetan:
        	:type Linetan: gp_Lin2d
        	:param Pcenter:
        	:type Pcenter: gp_Pnt2d
        	:rtype: None* This method implements the algorithms used to create 2d circles passing thrue a point and centered on a point. Tolerance is a tolerance criterion used by the algorithm to find a solution when, mathematically, the problem posed does not have a solution, but where there is numeric uncertainty attached to the arguments. In these algorithms Tolerance is only used in very specific cases where the center of the solution is very close to the circle to which it is tangential, and where the solution is therefore a very small circle. Exceptions GccEnt_BadQualifier if a qualifier is inconsistent with the argument it qualifies (for example, enclosing for a line).
        	:param Point1:
        	:type Point1: gp_Pnt2d
        	:param Pcenter:
        	:type Pcenter: gp_Pnt2d
        	:rtype: None
        """
        _GccAna.GccAna_Circ2dTanCen_swiginit(self, _GccAna.new_GccAna_Circ2dTanCen(*args))
    IsDone = _swig_new_instance_method(_GccAna.GccAna_Circ2dTanCen_IsDone)
    IsTheSame1 = _swig_new_instance_method(_GccAna.GccAna_Circ2dTanCen_IsTheSame1)
    NbSolutions = _swig_new_instance_method(_GccAna.GccAna_Circ2dTanCen_NbSolutions)
    Tangency1 = _swig_new_instance_method(_GccAna.GccAna_Circ2dTanCen_Tangency1)
    ThisSolution = _swig_new_instance_method(_GccAna.GccAna_Circ2dTanCen_ThisSolution)
    WhichQualifier = _swig_new_instance_method(_GccAna.GccAna_Circ2dTanCen_WhichQualifier)

    __repr__ = _dumps_object

    __swig_destroy__ = _GccAna.delete_GccAna_Circ2dTanCen

# Register GccAna_Circ2dTanCen in _GccAna:
_GccAna.GccAna_Circ2dTanCen_swigregister(GccAna_Circ2dTanCen)

class GccAna_Circ2dTanOnRad(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    CenterOn3 = _swig_new_instance_method(_GccAna.GccAna_Circ2dTanOnRad_CenterOn3)

    def __init__(self, *args):
        r"""
        * This methods implements the algorithms used to create 2d Circles tangent to a circle and centered on a 2d Line with a given radius. Tolerance is used to find solution in every limit cases. For example Tolerance is used in the case of EnclosedCirc when Radius-R1+dist is greater Tolerance (dist is the distance between the line and the location of the circ, R1 is the radius of the circ) because there is no solution. raises NegativeValue in case of NegativeRadius.
        	:param Qualified1:
        	:type Qualified1: GccEnt_QualifiedCirc
        	:param OnLine:
        	:type OnLine: gp_Lin2d
        	:param Radius:
        	:type Radius: float
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None* This methods implements the algorithms used to create 2d Circles tangent to a 2d Line and centered on a 2d Line with a given radius. Tolerance is used to find solution in every limit cases. raises NegativeValue in case of NegativeRadius.
        	:param Qualified1:
        	:type Qualified1: GccEnt_QualifiedLin
        	:param OnLine:
        	:type OnLine: gp_Lin2d
        	:param Radius:
        	:type Radius: float
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None* This methods implements the algorithms used to create 2d Circles passing through a 2d Point and centered on a 2d Line with a given radius. Tolerance is used to find solution in every limit cases.
        	:param Point1:
        	:type Point1: gp_Pnt2d
        	:param OnLine:
        	:type OnLine: gp_Lin2d
        	:param Radius:
        	:type Radius: float
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None* This methods implements the algorithms used to create 2d Circles tangent to a circle and centered on a 2d Circle with a given radius. Tolerance is used to find solution in every limit cases. raises NegativeValue in case of NegativeRadius.
        	:param Qualified1:
        	:type Qualified1: GccEnt_QualifiedCirc
        	:param OnCirc:
        	:type OnCirc: gp_Circ2d
        	:param Radius:
        	:type Radius: float
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None* This methods implements the algorithms used to create 2d Circles tangent to a 2d Line and centered on a 2d Line with a given radius. Tolerance is used to find solution in every limit cases. raises NegativeValue in case of NegativeRadius.
        	:param Qualified1:
        	:type Qualified1: GccEnt_QualifiedLin
        	:param OnCirc:
        	:type OnCirc: gp_Circ2d
        	:param Radius:
        	:type Radius: float
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None* This methods implements the algorithms used to create 2d Circles passing through a 2d Point and centered on a 2d Line with a given radius. Tolerance is used to find solution in every limit cases. raises NegativeValue in case of NegativeRadius.
        	:param Point1:
        	:type Point1: gp_Pnt2d
        	:param OnCirc:
        	:type OnCirc: gp_Circ2d
        	:param Radius:
        	:type Radius: float
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None
        """
        _GccAna.GccAna_Circ2dTanOnRad_swiginit(self, _GccAna.new_GccAna_Circ2dTanOnRad(*args))
    IsDone = _swig_new_instance_method(_GccAna.GccAna_Circ2dTanOnRad_IsDone)
    IsTheSame1 = _swig_new_instance_method(_GccAna.GccAna_Circ2dTanOnRad_IsTheSame1)
    NbSolutions = _swig_new_instance_method(_GccAna.GccAna_Circ2dTanOnRad_NbSolutions)
    Tangency1 = _swig_new_instance_method(_GccAna.GccAna_Circ2dTanOnRad_Tangency1)
    ThisSolution = _swig_new_instance_method(_GccAna.GccAna_Circ2dTanOnRad_ThisSolution)
    WhichQualifier = _swig_new_instance_method(_GccAna.GccAna_Circ2dTanOnRad_WhichQualifier)

    __repr__ = _dumps_object

    __swig_destroy__ = _GccAna.delete_GccAna_Circ2dTanOnRad

# Register GccAna_Circ2dTanOnRad in _GccAna:
_GccAna.GccAna_Circ2dTanOnRad_swigregister(GccAna_Circ2dTanOnRad)

class GccAna_CircLin2dBisec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Constructs bisecting curves between the circle Circle and the line Line.
        	:param Circle:
        	:type Circle: gp_Circ2d
        	:param Line:
        	:type Line: gp_Lin2d
        	:rtype: None
        """
        _GccAna.GccAna_CircLin2dBisec_swiginit(self, _GccAna.new_GccAna_CircLin2dBisec(*args))
    IsDone = _swig_new_instance_method(_GccAna.GccAna_CircLin2dBisec_IsDone)
    NbSolutions = _swig_new_instance_method(_GccAna.GccAna_CircLin2dBisec_NbSolutions)
    ThisSolution = _swig_new_instance_method(_GccAna.GccAna_CircLin2dBisec_ThisSolution)

    __repr__ = _dumps_object

    __swig_destroy__ = _GccAna.delete_GccAna_CircLin2dBisec

# Register GccAna_CircLin2dBisec in _GccAna:
_GccAna.GccAna_CircLin2dBisec_swigregister(GccAna_CircLin2dBisec)

class GccAna_CircPnt2dBisec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Constructs bisecting curves between the circle Circle1 and the point Point2.
        	:param Circle1:
        	:type Circle1: gp_Circ2d
        	:param Point2:
        	:type Point2: gp_Pnt2d
        	:rtype: None* Constructs bisecting curves between the circle Circle1 and the point Point2. Tolerance is used.
        	:param Circle1:
        	:type Circle1: gp_Circ2d
        	:param Point2:
        	:type Point2: gp_Pnt2d
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None
        """
        _GccAna.GccAna_CircPnt2dBisec_swiginit(self, _GccAna.new_GccAna_CircPnt2dBisec(*args))
    IsDone = _swig_new_instance_method(_GccAna.GccAna_CircPnt2dBisec_IsDone)
    NbSolutions = _swig_new_instance_method(_GccAna.GccAna_CircPnt2dBisec_NbSolutions)
    ThisSolution = _swig_new_instance_method(_GccAna.GccAna_CircPnt2dBisec_ThisSolution)

    __repr__ = _dumps_object

    __swig_destroy__ = _GccAna.delete_GccAna_CircPnt2dBisec

# Register GccAna_CircPnt2dBisec in _GccAna:
_GccAna.GccAna_CircPnt2dBisec_swigregister(GccAna_CircPnt2dBisec)

class GccAna_Lin2d2Tan(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * This methods implements the algorithms used to create 2d lines passing thrue 2 points. Tolerance is used because we can't create a line when the distance between the two points is too small.
        	:param ThePoint1:
        	:type ThePoint1: gp_Pnt2d
        	:param ThePoint2:
        	:type ThePoint2: gp_Pnt2d
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None* This methods implements the algorithms used to create 2d lines tangent to one circle and passing thrue a point. Exception BadQualifier is raised in the case of EnclosedCirc Tolerance is used because there is no solution when the point is inside the solution according to the tolerance.
        	:param Qualified1:
        	:type Qualified1: GccEnt_QualifiedCirc
        	:param ThePoint:
        	:type ThePoint: gp_Pnt2d
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None* This methods implements the algorithms used to create 2d lines tangent to 2 circles. Exception BadQualifier is raised in the case of EnclosedCirc
        	:param Qualified1:
        	:type Qualified1: GccEnt_QualifiedCirc
        	:param Qualified2:
        	:type Qualified2: GccEnt_QualifiedCirc
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None
        """
        _GccAna.GccAna_Lin2d2Tan_swiginit(self, _GccAna.new_GccAna_Lin2d2Tan(*args))
    IsDone = _swig_new_instance_method(_GccAna.GccAna_Lin2d2Tan_IsDone)
    NbSolutions = _swig_new_instance_method(_GccAna.GccAna_Lin2d2Tan_NbSolutions)
    Tangency1 = _swig_new_instance_method(_GccAna.GccAna_Lin2d2Tan_Tangency1)
    Tangency2 = _swig_new_instance_method(_GccAna.GccAna_Lin2d2Tan_Tangency2)
    ThisSolution = _swig_new_instance_method(_GccAna.GccAna_Lin2d2Tan_ThisSolution)
    WhichQualifier = _swig_new_instance_method(_GccAna.GccAna_Lin2d2Tan_WhichQualifier)

    __repr__ = _dumps_object

    __swig_destroy__ = _GccAna.delete_GccAna_Lin2d2Tan

# Register GccAna_Lin2d2Tan in _GccAna:
_GccAna.GccAna_Lin2d2Tan_swigregister(GccAna_Lin2d2Tan)

class GccAna_Lin2dBisec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Constructs bisecting lines between the two lines Lin1 and Lin2.
        	:param Lin1:
        	:type Lin1: gp_Lin2d
        	:param Lin2:
        	:type Lin2: gp_Lin2d
        	:rtype: None
        """
        _GccAna.GccAna_Lin2dBisec_swiginit(self, _GccAna.new_GccAna_Lin2dBisec(*args))
    Intersection1 = _swig_new_instance_method(_GccAna.GccAna_Lin2dBisec_Intersection1)
    Intersection2 = _swig_new_instance_method(_GccAna.GccAna_Lin2dBisec_Intersection2)
    IsDone = _swig_new_instance_method(_GccAna.GccAna_Lin2dBisec_IsDone)
    NbSolutions = _swig_new_instance_method(_GccAna.GccAna_Lin2dBisec_NbSolutions)
    ThisSolution = _swig_new_instance_method(_GccAna.GccAna_Lin2dBisec_ThisSolution)

    __repr__ = _dumps_object

    __swig_destroy__ = _GccAna.delete_GccAna_Lin2dBisec

# Register GccAna_Lin2dBisec in _GccAna:
_GccAna.GccAna_Lin2dBisec_swigregister(GccAna_Lin2dBisec)

class GccAna_Lin2dTanObl(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * This class implements the algorithms used to create 2d line passing through a point and making an angle with a line.
        	:param ThePoint:
        	:type ThePoint: gp_Pnt2d
        	:param TheLine:
        	:type TheLine: gp_Lin2d
        	:param TheAngle:
        	:type TheAngle: float
        	:rtype: None* This class implements the algorithms used to create 2d line tangent to a circle and making an angle with a line. Exceptions GccEnt_BadQualifier if a qualifier is inconsistent with the argument it qualifies (for example, enclosed for a circle).
        	:param Qualified1:
        	:type Qualified1: GccEnt_QualifiedCirc
        	:param TheLine:
        	:type TheLine: gp_Lin2d
        	:param TheAngle:
        	:type TheAngle: float
        	:rtype: None
        """
        _GccAna.GccAna_Lin2dTanObl_swiginit(self, _GccAna.new_GccAna_Lin2dTanObl(*args))
    Intersection2 = _swig_new_instance_method(_GccAna.GccAna_Lin2dTanObl_Intersection2)
    IsDone = _swig_new_instance_method(_GccAna.GccAna_Lin2dTanObl_IsDone)
    NbSolutions = _swig_new_instance_method(_GccAna.GccAna_Lin2dTanObl_NbSolutions)
    Tangency1 = _swig_new_instance_method(_GccAna.GccAna_Lin2dTanObl_Tangency1)
    ThisSolution = _swig_new_instance_method(_GccAna.GccAna_Lin2dTanObl_ThisSolution)
    WhichQualifier = _swig_new_instance_method(_GccAna.GccAna_Lin2dTanObl_WhichQualifier)

    __repr__ = _dumps_object

    __swig_destroy__ = _GccAna.delete_GccAna_Lin2dTanObl

# Register GccAna_Lin2dTanObl in _GccAna:
_GccAna.GccAna_Lin2dTanObl_swigregister(GccAna_Lin2dTanObl)

class GccAna_Lin2dTanPar(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * This method implements the algorithms used to create a 2d line passing through a point and parallel to another line.
        	:param ThePoint:
        	:type ThePoint: gp_Pnt2d
        	:param Lin1:
        	:type Lin1: gp_Lin2d
        	:rtype: None* This method implements the algorithms used to create a 2d line tangent to a circle and parallel to another line. It raises BadQualifier in case of EnclosedCirc. Exceptions GccEnt_BadQualifier if a qualifier is inconsistent with the argument it qualifies (for example, enclosed for a circle).
        	:param Qualified1:
        	:type Qualified1: GccEnt_QualifiedCirc
        	:param Lin1:
        	:type Lin1: gp_Lin2d
        	:rtype: None
        """
        _GccAna.GccAna_Lin2dTanPar_swiginit(self, _GccAna.new_GccAna_Lin2dTanPar(*args))
    IsDone = _swig_new_instance_method(_GccAna.GccAna_Lin2dTanPar_IsDone)
    NbSolutions = _swig_new_instance_method(_GccAna.GccAna_Lin2dTanPar_NbSolutions)
    Tangency1 = _swig_new_instance_method(_GccAna.GccAna_Lin2dTanPar_Tangency1)
    ThisSolution = _swig_new_instance_method(_GccAna.GccAna_Lin2dTanPar_ThisSolution)
    WhichQualifier = _swig_new_instance_method(_GccAna.GccAna_Lin2dTanPar_WhichQualifier)

    __repr__ = _dumps_object

    __swig_destroy__ = _GccAna.delete_GccAna_Lin2dTanPar

# Register GccAna_Lin2dTanPar in _GccAna:
_GccAna.GccAna_Lin2dTanPar_swigregister(GccAna_Lin2dTanPar)

class GccAna_Lin2dTanPer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * This method implements the algorithms used to create 2d lines passing through a point and perpendicular to a line.
        	:param ThePnt:
        	:type ThePnt: gp_Pnt2d
        	:param TheLin:
        	:type TheLin: gp_Lin2d
        	:rtype: None* This method implements the algorithms used to create 2d lines passing through a point and perpendicular to a circle.
        	:param ThePnt:
        	:type ThePnt: gp_Pnt2d
        	:param TheCircle:
        	:type TheCircle: gp_Circ2d
        	:rtype: None* This method implements the algorithms used to create 2d lines tangent to a circle and perpendicular to a line.
        	:param Qualified1:
        	:type Qualified1: GccEnt_QualifiedCirc
        	:param TheLin:
        	:type TheLin: gp_Lin2d
        	:rtype: None* This method implements the algorithms used to create 2d lines tangent to a circle and perpendicular to a circle.
        	:param Qualified1:
        	:type Qualified1: GccEnt_QualifiedCirc
        	:param TheCircle:
        	:type TheCircle: gp_Circ2d
        	:rtype: None
        """
        _GccAna.GccAna_Lin2dTanPer_swiginit(self, _GccAna.new_GccAna_Lin2dTanPer(*args))
    Intersection2 = _swig_new_instance_method(_GccAna.GccAna_Lin2dTanPer_Intersection2)
    IsDone = _swig_new_instance_method(_GccAna.GccAna_Lin2dTanPer_IsDone)
    NbSolutions = _swig_new_instance_method(_GccAna.GccAna_Lin2dTanPer_NbSolutions)
    Tangency1 = _swig_new_instance_method(_GccAna.GccAna_Lin2dTanPer_Tangency1)
    ThisSolution = _swig_new_instance_method(_GccAna.GccAna_Lin2dTanPer_ThisSolution)
    WhichQualifier = _swig_new_instance_method(_GccAna.GccAna_Lin2dTanPer_WhichQualifier)

    __repr__ = _dumps_object

    __swig_destroy__ = _GccAna.delete_GccAna_Lin2dTanPer

# Register GccAna_Lin2dTanPer in _GccAna:
_GccAna.GccAna_Lin2dTanPer_swigregister(GccAna_Lin2dTanPer)

class GccAna_LinPnt2dBisec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Constructs a bisecting curve between the line Line1 and the point Point2.
        	:param Line1:
        	:type Line1: gp_Lin2d
        	:param Point2:
        	:type Point2: gp_Pnt2d
        	:rtype: None
        """
        _GccAna.GccAna_LinPnt2dBisec_swiginit(self, _GccAna.new_GccAna_LinPnt2dBisec(*args))
    IsDone = _swig_new_instance_method(_GccAna.GccAna_LinPnt2dBisec_IsDone)
    ThisSolution = _swig_new_instance_method(_GccAna.GccAna_LinPnt2dBisec_ThisSolution)

    __repr__ = _dumps_object

    __swig_destroy__ = _GccAna.delete_GccAna_LinPnt2dBisec

# Register GccAna_LinPnt2dBisec in _GccAna:
_GccAna.GccAna_LinPnt2dBisec_swigregister(GccAna_LinPnt2dBisec)

class GccAna_Pnt2dBisec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Constructs a bisecting line between the points Point1 and Point2.
        	:param Point1:
        	:type Point1: gp_Pnt2d
        	:param Point2:
        	:type Point2: gp_Pnt2d
        	:rtype: None
        """
        _GccAna.GccAna_Pnt2dBisec_swiginit(self, _GccAna.new_GccAna_Pnt2dBisec(*args))
    HasSolution = _swig_new_instance_method(_GccAna.GccAna_Pnt2dBisec_HasSolution)
    IsDone = _swig_new_instance_method(_GccAna.GccAna_Pnt2dBisec_IsDone)
    ThisSolution = _swig_new_instance_method(_GccAna.GccAna_Pnt2dBisec_ThisSolution)

    __repr__ = _dumps_object

    __swig_destroy__ = _GccAna.delete_GccAna_Pnt2dBisec

# Register GccAna_Pnt2dBisec in _GccAna:
_GccAna.GccAna_Pnt2dBisec_swigregister(GccAna_Pnt2dBisec)



