# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
Geom2d module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_geom2d.html
"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _Geom2d
else:
    import _Geom2d

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _Geom2d.SWIG_PyInstanceMethod_New
_swig_new_static_method = _Geom2d.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Geom2d.delete_SwigPyIterator
    value = _swig_new_instance_method(_Geom2d.SwigPyIterator_value)
    incr = _swig_new_instance_method(_Geom2d.SwigPyIterator_incr)
    decr = _swig_new_instance_method(_Geom2d.SwigPyIterator_decr)
    distance = _swig_new_instance_method(_Geom2d.SwigPyIterator_distance)
    equal = _swig_new_instance_method(_Geom2d.SwigPyIterator_equal)
    copy = _swig_new_instance_method(_Geom2d.SwigPyIterator_copy)
    next = _swig_new_instance_method(_Geom2d.SwigPyIterator_next)
    __next__ = _swig_new_instance_method(_Geom2d.SwigPyIterator___next__)
    previous = _swig_new_instance_method(_Geom2d.SwigPyIterator_previous)
    advance = _swig_new_instance_method(_Geom2d.SwigPyIterator_advance)
    __eq__ = _swig_new_instance_method(_Geom2d.SwigPyIterator___eq__)
    __ne__ = _swig_new_instance_method(_Geom2d.SwigPyIterator___ne__)
    __iadd__ = _swig_new_instance_method(_Geom2d.SwigPyIterator___iadd__)
    __isub__ = _swig_new_instance_method(_Geom2d.SwigPyIterator___isub__)
    __add__ = _swig_new_instance_method(_Geom2d.SwigPyIterator___add__)
    __sub__ = _swig_new_instance_method(_Geom2d.SwigPyIterator___sub__)
    def __iter__(self):
        return self

# Register SwigPyIterator in _Geom2d:
_Geom2d.SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.gp
import OCC.Core.GeomAbs
import OCC.Core.TColgp
import OCC.Core.TColStd
import OCC.Core.TCollection
Handle_Geom2d_Geometry_Create = _Geom2d.Handle_Geom2d_Geometry_Create
Handle_Geom2d_Geometry_DownCast = _Geom2d.Handle_Geom2d_Geometry_DownCast
Handle_Geom2d_Geometry_IsNull = _Geom2d.Handle_Geom2d_Geometry_IsNull
Handle_Geom2d_Transformation_Create = _Geom2d.Handle_Geom2d_Transformation_Create
Handle_Geom2d_Transformation_DownCast = _Geom2d.Handle_Geom2d_Transformation_DownCast
Handle_Geom2d_Transformation_IsNull = _Geom2d.Handle_Geom2d_Transformation_IsNull
Handle_Geom2d_AxisPlacement_Create = _Geom2d.Handle_Geom2d_AxisPlacement_Create
Handle_Geom2d_AxisPlacement_DownCast = _Geom2d.Handle_Geom2d_AxisPlacement_DownCast
Handle_Geom2d_AxisPlacement_IsNull = _Geom2d.Handle_Geom2d_AxisPlacement_IsNull
Handle_Geom2d_Curve_Create = _Geom2d.Handle_Geom2d_Curve_Create
Handle_Geom2d_Curve_DownCast = _Geom2d.Handle_Geom2d_Curve_DownCast
Handle_Geom2d_Curve_IsNull = _Geom2d.Handle_Geom2d_Curve_IsNull
Handle_Geom2d_Point_Create = _Geom2d.Handle_Geom2d_Point_Create
Handle_Geom2d_Point_DownCast = _Geom2d.Handle_Geom2d_Point_DownCast
Handle_Geom2d_Point_IsNull = _Geom2d.Handle_Geom2d_Point_IsNull
Handle_Geom2d_Vector_Create = _Geom2d.Handle_Geom2d_Vector_Create
Handle_Geom2d_Vector_DownCast = _Geom2d.Handle_Geom2d_Vector_DownCast
Handle_Geom2d_Vector_IsNull = _Geom2d.Handle_Geom2d_Vector_IsNull
Handle_Geom2d_BoundedCurve_Create = _Geom2d.Handle_Geom2d_BoundedCurve_Create
Handle_Geom2d_BoundedCurve_DownCast = _Geom2d.Handle_Geom2d_BoundedCurve_DownCast
Handle_Geom2d_BoundedCurve_IsNull = _Geom2d.Handle_Geom2d_BoundedCurve_IsNull
Handle_Geom2d_CartesianPoint_Create = _Geom2d.Handle_Geom2d_CartesianPoint_Create
Handle_Geom2d_CartesianPoint_DownCast = _Geom2d.Handle_Geom2d_CartesianPoint_DownCast
Handle_Geom2d_CartesianPoint_IsNull = _Geom2d.Handle_Geom2d_CartesianPoint_IsNull
Handle_Geom2d_Conic_Create = _Geom2d.Handle_Geom2d_Conic_Create
Handle_Geom2d_Conic_DownCast = _Geom2d.Handle_Geom2d_Conic_DownCast
Handle_Geom2d_Conic_IsNull = _Geom2d.Handle_Geom2d_Conic_IsNull
Handle_Geom2d_Direction_Create = _Geom2d.Handle_Geom2d_Direction_Create
Handle_Geom2d_Direction_DownCast = _Geom2d.Handle_Geom2d_Direction_DownCast
Handle_Geom2d_Direction_IsNull = _Geom2d.Handle_Geom2d_Direction_IsNull
Handle_Geom2d_Line_Create = _Geom2d.Handle_Geom2d_Line_Create
Handle_Geom2d_Line_DownCast = _Geom2d.Handle_Geom2d_Line_DownCast
Handle_Geom2d_Line_IsNull = _Geom2d.Handle_Geom2d_Line_IsNull
Handle_Geom2d_OffsetCurve_Create = _Geom2d.Handle_Geom2d_OffsetCurve_Create
Handle_Geom2d_OffsetCurve_DownCast = _Geom2d.Handle_Geom2d_OffsetCurve_DownCast
Handle_Geom2d_OffsetCurve_IsNull = _Geom2d.Handle_Geom2d_OffsetCurve_IsNull
Handle_Geom2d_VectorWithMagnitude_Create = _Geom2d.Handle_Geom2d_VectorWithMagnitude_Create
Handle_Geom2d_VectorWithMagnitude_DownCast = _Geom2d.Handle_Geom2d_VectorWithMagnitude_DownCast
Handle_Geom2d_VectorWithMagnitude_IsNull = _Geom2d.Handle_Geom2d_VectorWithMagnitude_IsNull
Handle_Geom2d_BSplineCurve_Create = _Geom2d.Handle_Geom2d_BSplineCurve_Create
Handle_Geom2d_BSplineCurve_DownCast = _Geom2d.Handle_Geom2d_BSplineCurve_DownCast
Handle_Geom2d_BSplineCurve_IsNull = _Geom2d.Handle_Geom2d_BSplineCurve_IsNull
Handle_Geom2d_BezierCurve_Create = _Geom2d.Handle_Geom2d_BezierCurve_Create
Handle_Geom2d_BezierCurve_DownCast = _Geom2d.Handle_Geom2d_BezierCurve_DownCast
Handle_Geom2d_BezierCurve_IsNull = _Geom2d.Handle_Geom2d_BezierCurve_IsNull
Handle_Geom2d_Circle_Create = _Geom2d.Handle_Geom2d_Circle_Create
Handle_Geom2d_Circle_DownCast = _Geom2d.Handle_Geom2d_Circle_DownCast
Handle_Geom2d_Circle_IsNull = _Geom2d.Handle_Geom2d_Circle_IsNull
Handle_Geom2d_Ellipse_Create = _Geom2d.Handle_Geom2d_Ellipse_Create
Handle_Geom2d_Ellipse_DownCast = _Geom2d.Handle_Geom2d_Ellipse_DownCast
Handle_Geom2d_Ellipse_IsNull = _Geom2d.Handle_Geom2d_Ellipse_IsNull
Handle_Geom2d_Hyperbola_Create = _Geom2d.Handle_Geom2d_Hyperbola_Create
Handle_Geom2d_Hyperbola_DownCast = _Geom2d.Handle_Geom2d_Hyperbola_DownCast
Handle_Geom2d_Hyperbola_IsNull = _Geom2d.Handle_Geom2d_Hyperbola_IsNull
Handle_Geom2d_Parabola_Create = _Geom2d.Handle_Geom2d_Parabola_Create
Handle_Geom2d_Parabola_DownCast = _Geom2d.Handle_Geom2d_Parabola_DownCast
Handle_Geom2d_Parabola_IsNull = _Geom2d.Handle_Geom2d_Parabola_IsNull
Handle_Geom2d_TrimmedCurve_Create = _Geom2d.Handle_Geom2d_TrimmedCurve_Create
Handle_Geom2d_TrimmedCurve_DownCast = _Geom2d.Handle_Geom2d_TrimmedCurve_DownCast
Handle_Geom2d_TrimmedCurve_IsNull = _Geom2d.Handle_Geom2d_TrimmedCurve_IsNull
class Geom2d_Geometry(OCC.Core.Standard.Standard_Transient):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Copy = _swig_new_instance_method(_Geom2d.Geom2d_Geometry_Copy)
    Mirror = _swig_new_instance_method(_Geom2d.Geom2d_Geometry_Mirror)
    Mirrored = _swig_new_instance_method(_Geom2d.Geom2d_Geometry_Mirrored)
    Rotate = _swig_new_instance_method(_Geom2d.Geom2d_Geometry_Rotate)
    Rotated = _swig_new_instance_method(_Geom2d.Geom2d_Geometry_Rotated)
    Scale = _swig_new_instance_method(_Geom2d.Geom2d_Geometry_Scale)
    Scaled = _swig_new_instance_method(_Geom2d.Geom2d_Geometry_Scaled)
    Transform = _swig_new_instance_method(_Geom2d.Geom2d_Geometry_Transform)
    Transformed = _swig_new_instance_method(_Geom2d.Geom2d_Geometry_Transformed)
    Translate = _swig_new_instance_method(_Geom2d.Geom2d_Geometry_Translate)
    Translated = _swig_new_instance_method(_Geom2d.Geom2d_Geometry_Translated)


    @staticmethod
    def DownCast(t):
      return Handle_Geom2d_Geometry_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom2d.delete_Geom2d_Geometry

# Register Geom2d_Geometry in _Geom2d:
_Geom2d.Geom2d_Geometry_swigregister(Geom2d_Geometry)

class Geom2d_Transformation(OCC.Core.Standard.Standard_Transient):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Copy = _swig_new_instance_method(_Geom2d.Geom2d_Transformation_Copy)
    Form = _swig_new_instance_method(_Geom2d.Geom2d_Transformation_Form)

    def __init__(self, *args):
        r"""
        * Creates an identity transformation.
        	:rtype: None* Creates a persistent copy of T.
        	:param T:
        	:type T: gp_Trsf2d
        	:rtype: None
        """
        _Geom2d.Geom2d_Transformation_swiginit(self, _Geom2d.new_Geom2d_Transformation(*args))
    Invert = _swig_new_instance_method(_Geom2d.Geom2d_Transformation_Invert)
    Inverted = _swig_new_instance_method(_Geom2d.Geom2d_Transformation_Inverted)
    IsNegative = _swig_new_instance_method(_Geom2d.Geom2d_Transformation_IsNegative)
    Multiplied = _swig_new_instance_method(_Geom2d.Geom2d_Transformation_Multiplied)
    Multiply = _swig_new_instance_method(_Geom2d.Geom2d_Transformation_Multiply)
    Power = _swig_new_instance_method(_Geom2d.Geom2d_Transformation_Power)
    Powered = _swig_new_instance_method(_Geom2d.Geom2d_Transformation_Powered)
    PreMultiply = _swig_new_instance_method(_Geom2d.Geom2d_Transformation_PreMultiply)
    ScaleFactor = _swig_new_instance_method(_Geom2d.Geom2d_Transformation_ScaleFactor)
    SetMirror = _swig_new_instance_method(_Geom2d.Geom2d_Transformation_SetMirror)
    SetRotation = _swig_new_instance_method(_Geom2d.Geom2d_Transformation_SetRotation)
    SetScale = _swig_new_instance_method(_Geom2d.Geom2d_Transformation_SetScale)
    SetTransformation = _swig_new_instance_method(_Geom2d.Geom2d_Transformation_SetTransformation)
    SetTranslation = _swig_new_instance_method(_Geom2d.Geom2d_Transformation_SetTranslation)
    SetTrsf2d = _swig_new_instance_method(_Geom2d.Geom2d_Transformation_SetTrsf2d)
    Transforms = _swig_new_instance_method(_Geom2d.Geom2d_Transformation_Transforms)
    Trsf2d = _swig_new_instance_method(_Geom2d.Geom2d_Transformation_Trsf2d)
    Value = _swig_new_instance_method(_Geom2d.Geom2d_Transformation_Value)
    __mul__ = _swig_new_instance_method(_Geom2d.Geom2d_Transformation___mul__)
    __imul_wrapper__ = _swig_new_instance_method(_Geom2d.Geom2d_Transformation___imul_wrapper__)

    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self



    @staticmethod
    def DownCast(t):
      return Handle_Geom2d_Transformation_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom2d.delete_Geom2d_Transformation

# Register Geom2d_Transformation in _Geom2d:
_Geom2d.Geom2d_Transformation_swigregister(Geom2d_Transformation)

class Geom2d_AxisPlacement(Geom2d_Geometry):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Angle = _swig_new_instance_method(_Geom2d.Geom2d_AxisPlacement_Angle)
    Ax2d = _swig_new_instance_method(_Geom2d.Geom2d_AxisPlacement_Ax2d)
    Direction = _swig_new_instance_method(_Geom2d.Geom2d_AxisPlacement_Direction)

    def __init__(self, *args):
        r"""
        * Constructs an axis by conversion of the gp_Ax2d axis A.
        	:param A:
        	:type A: gp_Ax2d
        	:rtype: None* Constructs an axis from a given origin P and unit vector V.
        	:param P:
        	:type P: gp_Pnt2d
        	:param V:
        	:type V: gp_Dir2d
        	:rtype: None
        """
        _Geom2d.Geom2d_AxisPlacement_swiginit(self, _Geom2d.new_Geom2d_AxisPlacement(*args))
    Location = _swig_new_instance_method(_Geom2d.Geom2d_AxisPlacement_Location)
    Reverse = _swig_new_instance_method(_Geom2d.Geom2d_AxisPlacement_Reverse)
    Reversed = _swig_new_instance_method(_Geom2d.Geom2d_AxisPlacement_Reversed)
    SetAxis = _swig_new_instance_method(_Geom2d.Geom2d_AxisPlacement_SetAxis)
    SetDirection = _swig_new_instance_method(_Geom2d.Geom2d_AxisPlacement_SetDirection)
    SetLocation = _swig_new_instance_method(_Geom2d.Geom2d_AxisPlacement_SetLocation)


    @staticmethod
    def DownCast(t):
      return Handle_Geom2d_AxisPlacement_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom2d.delete_Geom2d_AxisPlacement

# Register Geom2d_AxisPlacement in _Geom2d:
_Geom2d.Geom2d_AxisPlacement_swigregister(Geom2d_AxisPlacement)

class Geom2d_Curve(Geom2d_Geometry):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Continuity = _swig_new_instance_method(_Geom2d.Geom2d_Curve_Continuity)
    D0 = _swig_new_instance_method(_Geom2d.Geom2d_Curve_D0)
    D1 = _swig_new_instance_method(_Geom2d.Geom2d_Curve_D1)
    D2 = _swig_new_instance_method(_Geom2d.Geom2d_Curve_D2)
    D3 = _swig_new_instance_method(_Geom2d.Geom2d_Curve_D3)
    DN = _swig_new_instance_method(_Geom2d.Geom2d_Curve_DN)
    FirstParameter = _swig_new_instance_method(_Geom2d.Geom2d_Curve_FirstParameter)
    IsCN = _swig_new_instance_method(_Geom2d.Geom2d_Curve_IsCN)
    IsClosed = _swig_new_instance_method(_Geom2d.Geom2d_Curve_IsClosed)
    IsPeriodic = _swig_new_instance_method(_Geom2d.Geom2d_Curve_IsPeriodic)
    LastParameter = _swig_new_instance_method(_Geom2d.Geom2d_Curve_LastParameter)
    ParametricTransformation = _swig_new_instance_method(_Geom2d.Geom2d_Curve_ParametricTransformation)
    Period = _swig_new_instance_method(_Geom2d.Geom2d_Curve_Period)
    Reverse = _swig_new_instance_method(_Geom2d.Geom2d_Curve_Reverse)
    Reversed = _swig_new_instance_method(_Geom2d.Geom2d_Curve_Reversed)
    ReversedParameter = _swig_new_instance_method(_Geom2d.Geom2d_Curve_ReversedParameter)
    TransformedParameter = _swig_new_instance_method(_Geom2d.Geom2d_Curve_TransformedParameter)
    Value = _swig_new_instance_method(_Geom2d.Geom2d_Curve_Value)


    @staticmethod
    def DownCast(t):
      return Handle_Geom2d_Curve_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom2d.delete_Geom2d_Curve

# Register Geom2d_Curve in _Geom2d:
_Geom2d.Geom2d_Curve_swigregister(Geom2d_Curve)

class Geom2d_Point(Geom2d_Geometry):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Coord = _swig_new_instance_method(_Geom2d.Geom2d_Point_Coord)
    Distance = _swig_new_instance_method(_Geom2d.Geom2d_Point_Distance)
    Pnt2d = _swig_new_instance_method(_Geom2d.Geom2d_Point_Pnt2d)
    SquareDistance = _swig_new_instance_method(_Geom2d.Geom2d_Point_SquareDistance)
    X = _swig_new_instance_method(_Geom2d.Geom2d_Point_X)
    Y = _swig_new_instance_method(_Geom2d.Geom2d_Point_Y)


    @staticmethod
    def DownCast(t):
      return Handle_Geom2d_Point_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom2d.delete_Geom2d_Point

# Register Geom2d_Point in _Geom2d:
_Geom2d.Geom2d_Point_swigregister(Geom2d_Point)

class Geom2d_Vector(Geom2d_Geometry):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Angle = _swig_new_instance_method(_Geom2d.Geom2d_Vector_Angle)
    Coord = _swig_new_instance_method(_Geom2d.Geom2d_Vector_Coord)
    Crossed = _swig_new_instance_method(_Geom2d.Geom2d_Vector_Crossed)
    Dot = _swig_new_instance_method(_Geom2d.Geom2d_Vector_Dot)
    Magnitude = _swig_new_instance_method(_Geom2d.Geom2d_Vector_Magnitude)
    Reverse = _swig_new_instance_method(_Geom2d.Geom2d_Vector_Reverse)
    Reversed = _swig_new_instance_method(_Geom2d.Geom2d_Vector_Reversed)
    SquareMagnitude = _swig_new_instance_method(_Geom2d.Geom2d_Vector_SquareMagnitude)
    Vec2d = _swig_new_instance_method(_Geom2d.Geom2d_Vector_Vec2d)
    X = _swig_new_instance_method(_Geom2d.Geom2d_Vector_X)
    Y = _swig_new_instance_method(_Geom2d.Geom2d_Vector_Y)


    @staticmethod
    def DownCast(t):
      return Handle_Geom2d_Vector_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom2d.delete_Geom2d_Vector

# Register Geom2d_Vector in _Geom2d:
_Geom2d.Geom2d_Vector_swigregister(Geom2d_Vector)

class Geom2d_BoundedCurve(Geom2d_Curve):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    EndPoint = _swig_new_instance_method(_Geom2d.Geom2d_BoundedCurve_EndPoint)
    StartPoint = _swig_new_instance_method(_Geom2d.Geom2d_BoundedCurve_StartPoint)


    @staticmethod
    def DownCast(t):
      return Handle_Geom2d_BoundedCurve_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom2d.delete_Geom2d_BoundedCurve

# Register Geom2d_BoundedCurve in _Geom2d:
_Geom2d.Geom2d_BoundedCurve_swigregister(Geom2d_BoundedCurve)

class Geom2d_CartesianPoint(Geom2d_Point):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Returns a persistent copy of P.
        	:param P:
        	:type P: gp_Pnt2d
        	:rtype: None:param X:
        	:type X: float
        	:param Y:
        	:type Y: float
        	:rtype: None
        """
        _Geom2d.Geom2d_CartesianPoint_swiginit(self, _Geom2d.new_Geom2d_CartesianPoint(*args))
    SetCoord = _swig_new_instance_method(_Geom2d.Geom2d_CartesianPoint_SetCoord)
    SetPnt2d = _swig_new_instance_method(_Geom2d.Geom2d_CartesianPoint_SetPnt2d)
    SetX = _swig_new_instance_method(_Geom2d.Geom2d_CartesianPoint_SetX)
    SetY = _swig_new_instance_method(_Geom2d.Geom2d_CartesianPoint_SetY)


    @staticmethod
    def DownCast(t):
      return Handle_Geom2d_CartesianPoint_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom2d.delete_Geom2d_CartesianPoint

# Register Geom2d_CartesianPoint in _Geom2d:
_Geom2d.Geom2d_CartesianPoint_swigregister(Geom2d_CartesianPoint)

class Geom2d_Conic(Geom2d_Curve):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Eccentricity = _swig_new_instance_method(_Geom2d.Geom2d_Conic_Eccentricity)
    Location = _swig_new_instance_method(_Geom2d.Geom2d_Conic_Location)
    Position = _swig_new_instance_method(_Geom2d.Geom2d_Conic_Position)
    SetAxis = _swig_new_instance_method(_Geom2d.Geom2d_Conic_SetAxis)
    SetLocation = _swig_new_instance_method(_Geom2d.Geom2d_Conic_SetLocation)
    SetXAxis = _swig_new_instance_method(_Geom2d.Geom2d_Conic_SetXAxis)
    SetYAxis = _swig_new_instance_method(_Geom2d.Geom2d_Conic_SetYAxis)
    XAxis = _swig_new_instance_method(_Geom2d.Geom2d_Conic_XAxis)
    YAxis = _swig_new_instance_method(_Geom2d.Geom2d_Conic_YAxis)


    @staticmethod
    def DownCast(t):
      return Handle_Geom2d_Conic_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom2d.delete_Geom2d_Conic

# Register Geom2d_Conic in _Geom2d:
_Geom2d.Geom2d_Conic_swigregister(Geom2d_Conic)

class Geom2d_Direction(Geom2d_Vector):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Dir2d = _swig_new_instance_method(_Geom2d.Geom2d_Direction_Dir2d)

    def __init__(self, *args):
        r"""
        * Creates a unit vector with it 2 cartesian coordinates. //! Raised if Sqrt( X*X + Y*Y) <= Resolution from gp.
        	:param X:
        	:type X: float
        	:param Y:
        	:type Y: float
        	:rtype: None* Creates a persistent copy of <self>.
        	:param V:
        	:type V: gp_Dir2d
        	:rtype: None
        """
        _Geom2d.Geom2d_Direction_swiginit(self, _Geom2d.new_Geom2d_Direction(*args))
    SetCoord = _swig_new_instance_method(_Geom2d.Geom2d_Direction_SetCoord)
    SetDir2d = _swig_new_instance_method(_Geom2d.Geom2d_Direction_SetDir2d)
    SetX = _swig_new_instance_method(_Geom2d.Geom2d_Direction_SetX)
    SetY = _swig_new_instance_method(_Geom2d.Geom2d_Direction_SetY)


    @staticmethod
    def DownCast(t):
      return Handle_Geom2d_Direction_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom2d.delete_Geom2d_Direction

# Register Geom2d_Direction in _Geom2d:
_Geom2d.Geom2d_Direction_swigregister(Geom2d_Direction)

class Geom2d_Line(Geom2d_Curve):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Direction = _swig_new_instance_method(_Geom2d.Geom2d_Line_Direction)
    Distance = _swig_new_instance_method(_Geom2d.Geom2d_Line_Distance)

    def __init__(self, *args):
        r"""
        * Creates a line located in 2D space with the axis placement A. The Location of A is the origin of the line.
        	:param A:
        	:type A: gp_Ax2d
        	:rtype: None* Creates a line by conversion of the gp_Lin2d line L.
        	:param L:
        	:type L: gp_Lin2d
        	:rtype: None* Constructs a line passing through point P and parallel to vector V (P and V are, respectively, the origin and the unit vector of the positioning axis of the line).
        	:param P:
        	:type P: gp_Pnt2d
        	:param V:
        	:type V: gp_Dir2d
        	:rtype: None
        """
        _Geom2d.Geom2d_Line_swiginit(self, _Geom2d.new_Geom2d_Line(*args))
    Lin2d = _swig_new_instance_method(_Geom2d.Geom2d_Line_Lin2d)
    Location = _swig_new_instance_method(_Geom2d.Geom2d_Line_Location)
    Position = _swig_new_instance_method(_Geom2d.Geom2d_Line_Position)
    SetDirection = _swig_new_instance_method(_Geom2d.Geom2d_Line_SetDirection)
    SetLin2d = _swig_new_instance_method(_Geom2d.Geom2d_Line_SetLin2d)
    SetLocation = _swig_new_instance_method(_Geom2d.Geom2d_Line_SetLocation)
    SetPosition = _swig_new_instance_method(_Geom2d.Geom2d_Line_SetPosition)


    @staticmethod
    def DownCast(t):
      return Handle_Geom2d_Line_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom2d.delete_Geom2d_Line

# Register Geom2d_Line in _Geom2d:
_Geom2d.Geom2d_Line_swigregister(Geom2d_Line)

class Geom2d_OffsetCurve(Geom2d_Curve):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    BasisCurve = _swig_new_instance_method(_Geom2d.Geom2d_OffsetCurve_BasisCurve)

    def __init__(self, *args):
        r"""
        * Constructs a curve offset from the basis curve C, where Offset is the distance between the offset curve and the basis curve at any point. A point on the offset curve is built by measuring the offset value along a normal vector at a point on C. This normal vector is obtained by rotating the vector tangential to C at 90 degrees in the anti-trigonometric sense. The side of C on which the offset value is measured is indicated by this normal vector if Offset is positive, or in the inverse sense if Offset is negative. If isNotCheckC0 = True checking if basis curve has C0-continuity is not made. Warnings : In this package the entities are not shared. The OffsetCurve is built with a copy of the curve C. So when C is modified the OffsetCurve is not modified Warning! if isNotCheckC0 = false, ConstructionError raised if the basis curve C is not at least C1. No check is done to know if ||V^Z|| != 0.0 at any point.
        	:param C:
        	:type C: Geom2d_Curve
        	:param Offset:
        	:type Offset: float
        	:param isNotCheckC0: default value is Standard_False
        	:type isNotCheckC0: bool
        	:rtype: None
        """
        _Geom2d.Geom2d_OffsetCurve_swiginit(self, _Geom2d.new_Geom2d_OffsetCurve(*args))
    GetBasisCurveContinuity = _swig_new_instance_method(_Geom2d.Geom2d_OffsetCurve_GetBasisCurveContinuity)
    Offset = _swig_new_instance_method(_Geom2d.Geom2d_OffsetCurve_Offset)
    SetBasisCurve = _swig_new_instance_method(_Geom2d.Geom2d_OffsetCurve_SetBasisCurve)
    SetOffsetValue = _swig_new_instance_method(_Geom2d.Geom2d_OffsetCurve_SetOffsetValue)


    @staticmethod
    def DownCast(t):
      return Handle_Geom2d_OffsetCurve_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom2d.delete_Geom2d_OffsetCurve

# Register Geom2d_OffsetCurve in _Geom2d:
_Geom2d.Geom2d_OffsetCurve_swigregister(Geom2d_OffsetCurve)

class Geom2d_VectorWithMagnitude(Geom2d_Vector):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Add = _swig_new_instance_method(_Geom2d.Geom2d_VectorWithMagnitude_Add)
    Added = _swig_new_instance_method(_Geom2d.Geom2d_VectorWithMagnitude_Added)
    Divide = _swig_new_instance_method(_Geom2d.Geom2d_VectorWithMagnitude_Divide)
    Divided = _swig_new_instance_method(_Geom2d.Geom2d_VectorWithMagnitude_Divided)

    def __init__(self, *args):
        r"""
        * Creates a persistent copy of V.
        	:param V:
        	:type V: gp_Vec2d
        	:rtype: None* Creates a vector with two cartesian coordinates.
        	:param X:
        	:type X: float
        	:param Y:
        	:type Y: float
        	:rtype: None* Creates a vector from the point P1 to the point P2. The magnitude of the vector is the distance between P1 and P2
        	:param P1:
        	:type P1: gp_Pnt2d
        	:param P2:
        	:type P2: gp_Pnt2d
        	:rtype: None
        """
        _Geom2d.Geom2d_VectorWithMagnitude_swiginit(self, _Geom2d.new_Geom2d_VectorWithMagnitude(*args))
    Multiplied = _swig_new_instance_method(_Geom2d.Geom2d_VectorWithMagnitude_Multiplied)
    Multiply = _swig_new_instance_method(_Geom2d.Geom2d_VectorWithMagnitude_Multiply)
    Normalize = _swig_new_instance_method(_Geom2d.Geom2d_VectorWithMagnitude_Normalize)
    Normalized = _swig_new_instance_method(_Geom2d.Geom2d_VectorWithMagnitude_Normalized)
    SetCoord = _swig_new_instance_method(_Geom2d.Geom2d_VectorWithMagnitude_SetCoord)
    SetVec2d = _swig_new_instance_method(_Geom2d.Geom2d_VectorWithMagnitude_SetVec2d)
    SetX = _swig_new_instance_method(_Geom2d.Geom2d_VectorWithMagnitude_SetX)
    SetY = _swig_new_instance_method(_Geom2d.Geom2d_VectorWithMagnitude_SetY)
    Subtract = _swig_new_instance_method(_Geom2d.Geom2d_VectorWithMagnitude_Subtract)
    Subtracted = _swig_new_instance_method(_Geom2d.Geom2d_VectorWithMagnitude_Subtracted)
    __imul_wrapper__ = _swig_new_instance_method(_Geom2d.Geom2d_VectorWithMagnitude___imul_wrapper__)

    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self

    __add__ = _swig_new_instance_method(_Geom2d.Geom2d_VectorWithMagnitude___add__)
    __iadd_wrapper__ = _swig_new_instance_method(_Geom2d.Geom2d_VectorWithMagnitude___iadd_wrapper__)

    def __iadd__(self, right):
        self.__iadd_wrapper__(right)
        return self

    __sub__ = _swig_new_instance_method(_Geom2d.Geom2d_VectorWithMagnitude___sub__)
    __isub_wrapper__ = _swig_new_instance_method(_Geom2d.Geom2d_VectorWithMagnitude___isub_wrapper__)

    def __isub__(self, right):
        self.__isub_wrapper__(right)
        return self


    def __truediv__(self, *args):
        return _Geom2d.Geom2d_VectorWithMagnitude___truediv__(self, *args)
    __div__ = __truediv__


    __itruediv_wrapper__ = _swig_new_instance_method(_Geom2d.Geom2d_VectorWithMagnitude___itruediv_wrapper__)

    def __itruediv__(self, right):
        self.__itruediv_wrapper__(right)
        return self



    @staticmethod
    def DownCast(t):
      return Handle_Geom2d_VectorWithMagnitude_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom2d.delete_Geom2d_VectorWithMagnitude

# Register Geom2d_VectorWithMagnitude in _Geom2d:
_Geom2d.Geom2d_VectorWithMagnitude_swigregister(Geom2d_VectorWithMagnitude)

class Geom2d_BSplineCurve(Geom2d_BoundedCurve):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Degree = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_Degree)
    FirstUKnotIndex = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_FirstUKnotIndex)

    def __init__(self, *args):
        r"""
        * Creates a non-rational B_spline curve on the basis <Knots, Multiplicities> of degree <Degree>. The following conditions must be verified. 0 < Degree <= MaxDegree. //! Knots.Length() == Mults.Length() >= 2 //! Knots(i) < Knots(i+1) (Knots are increasing) //! 1 <= Mults(i) <= Degree //! On a non periodic curve the first and last multiplicities may be Degree+1 (this is even recommanded if you want the curve to start and finish on the first and last pole). //! On a periodic curve the first and the last multicities must be the same. //! on non-periodic curves //! Poles.Length() == Sum(Mults(i)) - Degree - 1 >= 2 //! on periodic curves //! Poles.Length() == Sum(Mults(i)) except the first or last
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Multiplicities:
        	:type Multiplicities: TColStd_Array1OfInteger
        	:param Degree:
        	:type Degree: int
        	:param Periodic: default value is Standard_False
        	:type Periodic: bool
        	:rtype: None* Creates a rational B_spline curve on the basis <Knots, Multiplicities> of degree <Degree>. The following conditions must be verified. 0 < Degree <= MaxDegree. //! Knots.Length() == Mults.Length() >= 2 //! Knots(i) < Knots(i+1) (Knots are increasing) //! 1 <= Mults(i) <= Degree //! On a non periodic curve the first and last multiplicities may be Degree+1 (this is even recommanded if you want the curve to start and finish on the first and last pole). //! On a periodic curve the first and the last multicities must be the same. //! on non-periodic curves //! Poles.Length() == Sum(Mults(i)) - Degree - 1 >= 2 //! on periodic curves //! Poles.Length() == Sum(Mults(i)) except the first or last
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt2d
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Multiplicities:
        	:type Multiplicities: TColStd_Array1OfInteger
        	:param Degree:
        	:type Degree: int
        	:param Periodic: default value is Standard_False
        	:type Periodic: bool
        	:rtype: None
        """
        _Geom2d.Geom2d_BSplineCurve_swiginit(self, _Geom2d.new_Geom2d_BSplineCurve(*args))
    IncreaseDegree = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_IncreaseDegree)
    IncreaseMultiplicity = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_IncreaseMultiplicity)
    IncrementMultiplicity = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_IncrementMultiplicity)
    InsertKnot = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_InsertKnot)
    InsertKnots = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_InsertKnots)
    InsertPoleAfter = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_InsertPoleAfter)
    InsertPoleBefore = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_InsertPoleBefore)
    IsG1 = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_IsG1)
    IsRational = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_IsRational)
    Knot = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_Knot)
    KnotDistribution = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_KnotDistribution)
    KnotSequence = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_KnotSequence)
    Knots = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_Knots)
    LastUKnotIndex = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_LastUKnotIndex)
    LocalD0 = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_LocalD0)
    LocalD1 = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_LocalD1)
    LocalD2 = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_LocalD2)
    LocalD3 = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_LocalD3)
    LocalDN = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_LocalDN)
    LocalValue = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_LocalValue)
    LocateU = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_LocateU)
    MaxDegree = _swig_new_static_method(_Geom2d.Geom2d_BSplineCurve_MaxDegree)
    MovePoint = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_MovePoint)
    MovePointAndTangent = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_MovePointAndTangent)
    Multiplicities = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_Multiplicities)
    Multiplicity = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_Multiplicity)
    NbKnots = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_NbKnots)
    NbPoles = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_NbPoles)
    PeriodicNormalization = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_PeriodicNormalization)
    Pole = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_Pole)
    Poles = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_Poles)
    RemoveKnot = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_RemoveKnot)
    RemovePole = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_RemovePole)
    Resolution = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_Resolution)
    Segment = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_Segment)
    SetKnot = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_SetKnot)
    SetKnots = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_SetKnots)
    SetNotPeriodic = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_SetNotPeriodic)
    SetOrigin = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_SetOrigin)
    SetPeriodic = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_SetPeriodic)
    SetPole = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_SetPole)
    SetWeight = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_SetWeight)
    Weight = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_Weight)
    Weights = _swig_new_instance_method(_Geom2d.Geom2d_BSplineCurve_Weights)


    @staticmethod
    def DownCast(t):
      return Handle_Geom2d_BSplineCurve_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom2d.delete_Geom2d_BSplineCurve

# Register Geom2d_BSplineCurve in _Geom2d:
_Geom2d.Geom2d_BSplineCurve_swigregister(Geom2d_BSplineCurve)
Geom2d_BSplineCurve_MaxDegree = _Geom2d.Geom2d_BSplineCurve_MaxDegree

class Geom2d_BezierCurve(Geom2d_BoundedCurve):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Degree = _swig_new_instance_method(_Geom2d.Geom2d_BezierCurve_Degree)

    def __init__(self, *args):
        r"""
        * Creates a non rational Bezier curve with a set of poles : CurvePoles. The weights are defaulted to all being 1. Raises ConstructionError if the number of poles is greater than MaxDegree + 1 or lower than 2.
        	:param CurvePoles:
        	:type CurvePoles: TColgp_Array1OfPnt2d
        	:rtype: None* Creates a rational Bezier curve with the set of poles CurvePoles and the set of weights PoleWeights . If all the weights are identical the curve is considered as non rational. Raises ConstructionError if the number of poles is greater than MaxDegree + 1 or lower than 2 or CurvePoles and CurveWeights have not the same length or one weight value is lower or equal to Resolution from package gp.
        	:param CurvePoles:
        	:type CurvePoles: TColgp_Array1OfPnt2d
        	:param PoleWeights:
        	:type PoleWeights: TColStd_Array1OfReal
        	:rtype: None
        """
        _Geom2d.Geom2d_BezierCurve_swiginit(self, _Geom2d.new_Geom2d_BezierCurve(*args))
    Increase = _swig_new_instance_method(_Geom2d.Geom2d_BezierCurve_Increase)
    InsertPoleAfter = _swig_new_instance_method(_Geom2d.Geom2d_BezierCurve_InsertPoleAfter)
    InsertPoleBefore = _swig_new_instance_method(_Geom2d.Geom2d_BezierCurve_InsertPoleBefore)
    IsRational = _swig_new_instance_method(_Geom2d.Geom2d_BezierCurve_IsRational)
    MaxDegree = _swig_new_static_method(_Geom2d.Geom2d_BezierCurve_MaxDegree)
    NbPoles = _swig_new_instance_method(_Geom2d.Geom2d_BezierCurve_NbPoles)
    Pole = _swig_new_instance_method(_Geom2d.Geom2d_BezierCurve_Pole)
    Poles = _swig_new_instance_method(_Geom2d.Geom2d_BezierCurve_Poles)
    RemovePole = _swig_new_instance_method(_Geom2d.Geom2d_BezierCurve_RemovePole)
    Resolution = _swig_new_instance_method(_Geom2d.Geom2d_BezierCurve_Resolution)
    Segment = _swig_new_instance_method(_Geom2d.Geom2d_BezierCurve_Segment)
    SetPole = _swig_new_instance_method(_Geom2d.Geom2d_BezierCurve_SetPole)
    SetWeight = _swig_new_instance_method(_Geom2d.Geom2d_BezierCurve_SetWeight)
    Weight = _swig_new_instance_method(_Geom2d.Geom2d_BezierCurve_Weight)
    Weights = _swig_new_instance_method(_Geom2d.Geom2d_BezierCurve_Weights)


    @staticmethod
    def DownCast(t):
      return Handle_Geom2d_BezierCurve_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom2d.delete_Geom2d_BezierCurve

# Register Geom2d_BezierCurve in _Geom2d:
_Geom2d.Geom2d_BezierCurve_swigregister(Geom2d_BezierCurve)
Geom2d_BezierCurve_MaxDegree = _Geom2d.Geom2d_BezierCurve_MaxDegree

class Geom2d_Circle(Geom2d_Conic):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Circ2d = _swig_new_instance_method(_Geom2d.Geom2d_Circle_Circ2d)

    def __init__(self, *args):
        r"""
        * Constructs a circle by conversion of the gp_Circ2d circle C.
        	:param C:
        	:type C: gp_Circ2d
        	:rtype: None* Constructs a circle of radius Radius, whose center is the origin of axis A; A is the 'X Axis' of the local coordinate system of the circle; this coordinate system is direct if Sense is true (default value) or indirect if Sense is false. Note: It is possible to create a circle where Radius is equal to 0.0. Exceptions Standard_ConstructionError if Radius is negative.
        	:param A:
        	:type A: gp_Ax2d
        	:param Radius:
        	:type Radius: float
        	:param Sense: default value is Standard_True
        	:type Sense: bool
        	:rtype: None* Constructs a circle of radius Radius, where the coordinate system A locates the circle and defines its orientation in the plane such that: - the center of the circle is the origin of A, - the orientation (direct or indirect) of A gives the orientation of the circle.
        	:param A:
        	:type A: gp_Ax22d
        	:param Radius:
        	:type Radius: float
        	:rtype: None
        """
        _Geom2d.Geom2d_Circle_swiginit(self, _Geom2d.new_Geom2d_Circle(*args))
    Radius = _swig_new_instance_method(_Geom2d.Geom2d_Circle_Radius)
    SetCirc2d = _swig_new_instance_method(_Geom2d.Geom2d_Circle_SetCirc2d)
    SetRadius = _swig_new_instance_method(_Geom2d.Geom2d_Circle_SetRadius)


    @staticmethod
    def DownCast(t):
      return Handle_Geom2d_Circle_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom2d.delete_Geom2d_Circle

# Register Geom2d_Circle in _Geom2d:
_Geom2d.Geom2d_Circle_swigregister(Geom2d_Circle)

class Geom2d_Ellipse(Geom2d_Conic):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Directrix1 = _swig_new_instance_method(_Geom2d.Geom2d_Ellipse_Directrix1)
    Directrix2 = _swig_new_instance_method(_Geom2d.Geom2d_Ellipse_Directrix2)
    Elips2d = _swig_new_instance_method(_Geom2d.Geom2d_Ellipse_Elips2d)
    Focal = _swig_new_instance_method(_Geom2d.Geom2d_Ellipse_Focal)
    Focus1 = _swig_new_instance_method(_Geom2d.Geom2d_Ellipse_Focus1)
    Focus2 = _swig_new_instance_method(_Geom2d.Geom2d_Ellipse_Focus2)

    def __init__(self, *args):
        r"""
        * Creates an ellipse by conversion of the gp_Elips2d ellipse E.
        	:param E:
        	:type E: gp_Elips2d
        	:rtype: None* Creates an ellipse defined by its major and minor radii, MajorRadius and MinorRadius, and positioned in the plane by its major axis MajorAxis; the center of the ellipse is the origin of MajorAxis and the unit vector of MajorAxis is the 'X Direction' of the local coordinate system of the ellipse; this coordinate system is direct if Sense is true (default value) or indirect if Sense is false. Warnings : It is not forbidden to create an ellipse with MajorRadius = MinorRadius. Exceptions Standard_ConstructionError if: - MajorRadius is less than MinorRadius, or - MinorRadius is less than 0.
        	:param MajorAxis:
        	:type MajorAxis: gp_Ax2d
        	:param MajorRadius:
        	:type MajorRadius: float
        	:param MinorRadius:
        	:type MinorRadius: float
        	:param Sense: default value is Standard_True
        	:type Sense: bool
        	:rtype: None* Creates an ellipse defined by its major and minor radii, MajorRadius and MinorRadius, where the coordinate system Axis locates the ellipse and defines its orientation in the plane such that: - the center of the ellipse is the origin of Axis, - the 'X Direction' of Axis defines the major axis of the ellipse, - the 'Y Direction' of Axis defines the minor axis of the ellipse, - the orientation of Axis (direct or indirect) gives the orientation of the ellipse. Warnings : It is not forbidden to create an ellipse with MajorRadius = MinorRadius. Exceptions Standard_ConstructionError if: - MajorRadius is less than MinorRadius, or - MinorRadius is less than 0.
        	:param Axis:
        	:type Axis: gp_Ax22d
        	:param MajorRadius:
        	:type MajorRadius: float
        	:param MinorRadius:
        	:type MinorRadius: float
        	:rtype: None
        """
        _Geom2d.Geom2d_Ellipse_swiginit(self, _Geom2d.new_Geom2d_Ellipse(*args))
    MajorRadius = _swig_new_instance_method(_Geom2d.Geom2d_Ellipse_MajorRadius)
    MinorRadius = _swig_new_instance_method(_Geom2d.Geom2d_Ellipse_MinorRadius)
    Parameter = _swig_new_instance_method(_Geom2d.Geom2d_Ellipse_Parameter)
    SetElips2d = _swig_new_instance_method(_Geom2d.Geom2d_Ellipse_SetElips2d)
    SetMajorRadius = _swig_new_instance_method(_Geom2d.Geom2d_Ellipse_SetMajorRadius)
    SetMinorRadius = _swig_new_instance_method(_Geom2d.Geom2d_Ellipse_SetMinorRadius)


    @staticmethod
    def DownCast(t):
      return Handle_Geom2d_Ellipse_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom2d.delete_Geom2d_Ellipse

# Register Geom2d_Ellipse in _Geom2d:
_Geom2d.Geom2d_Ellipse_swigregister(Geom2d_Ellipse)

class Geom2d_Hyperbola(Geom2d_Conic):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Asymptote1 = _swig_new_instance_method(_Geom2d.Geom2d_Hyperbola_Asymptote1)
    Asymptote2 = _swig_new_instance_method(_Geom2d.Geom2d_Hyperbola_Asymptote2)
    ConjugateBranch1 = _swig_new_instance_method(_Geom2d.Geom2d_Hyperbola_ConjugateBranch1)
    ConjugateBranch2 = _swig_new_instance_method(_Geom2d.Geom2d_Hyperbola_ConjugateBranch2)
    Directrix1 = _swig_new_instance_method(_Geom2d.Geom2d_Hyperbola_Directrix1)
    Directrix2 = _swig_new_instance_method(_Geom2d.Geom2d_Hyperbola_Directrix2)
    Focal = _swig_new_instance_method(_Geom2d.Geom2d_Hyperbola_Focal)
    Focus1 = _swig_new_instance_method(_Geom2d.Geom2d_Hyperbola_Focus1)
    Focus2 = _swig_new_instance_method(_Geom2d.Geom2d_Hyperbola_Focus2)

    def __init__(self, *args):
        r"""
        * Creates an Hyperbola from a non persistent one from package gp
        	:param H:
        	:type H: gp_Hypr2d
        	:rtype: None* MajorAxis is the 'XAxis' of the hyperbola. The YAxis is in the direct sense if 'Sense' is True; The major radius of the hyperbola is on this 'XAxis' and the minor radius is on the 'YAxis' of the hyperbola. Raised if MajorRadius < 0.0 or if MinorRadius < 0.0
        	:param MajorAxis:
        	:type MajorAxis: gp_Ax2d
        	:param MajorRadius:
        	:type MajorRadius: float
        	:param MinorRadius:
        	:type MinorRadius: float
        	:param Sense: default value is Standard_True
        	:type Sense: bool
        	:rtype: None* The XDirection of 'Axis' is the 'XAxis' of the hyperbola and the YDirection of 'Axis' is the 'YAxis'. The major radius of the hyperbola is on this 'XAxis' and the minor radius is on the 'YAxis' of the hyperbola. Raised if MajorRadius < 0.0 or if MinorRadius < 0.0
        	:param Axis:
        	:type Axis: gp_Ax22d
        	:param MajorRadius:
        	:type MajorRadius: float
        	:param MinorRadius:
        	:type MinorRadius: float
        	:rtype: None
        """
        _Geom2d.Geom2d_Hyperbola_swiginit(self, _Geom2d.new_Geom2d_Hyperbola(*args))
    Hypr2d = _swig_new_instance_method(_Geom2d.Geom2d_Hyperbola_Hypr2d)
    MajorRadius = _swig_new_instance_method(_Geom2d.Geom2d_Hyperbola_MajorRadius)
    MinorRadius = _swig_new_instance_method(_Geom2d.Geom2d_Hyperbola_MinorRadius)
    OtherBranch = _swig_new_instance_method(_Geom2d.Geom2d_Hyperbola_OtherBranch)
    Parameter = _swig_new_instance_method(_Geom2d.Geom2d_Hyperbola_Parameter)
    SetHypr2d = _swig_new_instance_method(_Geom2d.Geom2d_Hyperbola_SetHypr2d)
    SetMajorRadius = _swig_new_instance_method(_Geom2d.Geom2d_Hyperbola_SetMajorRadius)
    SetMinorRadius = _swig_new_instance_method(_Geom2d.Geom2d_Hyperbola_SetMinorRadius)


    @staticmethod
    def DownCast(t):
      return Handle_Geom2d_Hyperbola_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom2d.delete_Geom2d_Hyperbola

# Register Geom2d_Hyperbola in _Geom2d:
_Geom2d.Geom2d_Hyperbola_swigregister(Geom2d_Hyperbola)

class Geom2d_Parabola(Geom2d_Conic):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Directrix = _swig_new_instance_method(_Geom2d.Geom2d_Parabola_Directrix)
    Focal = _swig_new_instance_method(_Geom2d.Geom2d_Parabola_Focal)
    Focus = _swig_new_instance_method(_Geom2d.Geom2d_Parabola_Focus)

    def __init__(self, *args):
        r"""
        * Creates a parabola from a non persistent one.
        	:param Prb:
        	:type Prb: gp_Parab2d
        	:rtype: None* Creates a parabola with its 'MirrorAxis' and it's focal length 'Focal'. MirrorAxis is the axis of symmetry of the curve, it is the 'XAxis'. The 'YAxis' is parallel to the directrix of the parabola and is in the direct sense if Sense is True. The 'Location' point of 'MirrorAxis' is the vertex of the parabola Raised if Focal < 0.0
        	:param MirrorAxis:
        	:type MirrorAxis: gp_Ax2d
        	:param Focal:
        	:type Focal: float
        	:param Sense: default value is Standard_True
        	:type Sense: bool
        	:rtype: None* Creates a parabola with its Axis and it's focal length 'Focal'. The XDirection of Axis is the axis of symmetry of the curve, it is the 'XAxis'. The 'YAxis' is parallel to the directrix of the parabola. The 'Location' point of 'Axis' is the vertex of the parabola. Raised if Focal < 0.0
        	:param Axis:
        	:type Axis: gp_Ax22d
        	:param Focal:
        	:type Focal: float
        	:rtype: None* D is the directrix of the parabola and F the focus point. The symmetry axis 'XAxis' of the parabola is normal to the directrix and pass through the focus point F, but its 'Location' point is the vertex of the parabola. The 'YAxis' of the parabola is parallel to D and its 'Location' point is the vertex of the parabola.
        	:param D:
        	:type D: gp_Ax2d
        	:param F:
        	:type F: gp_Pnt2d
        	:rtype: None
        """
        _Geom2d.Geom2d_Parabola_swiginit(self, _Geom2d.new_Geom2d_Parabola(*args))
    Parab2d = _swig_new_instance_method(_Geom2d.Geom2d_Parabola_Parab2d)
    Parameter = _swig_new_instance_method(_Geom2d.Geom2d_Parabola_Parameter)
    SetFocal = _swig_new_instance_method(_Geom2d.Geom2d_Parabola_SetFocal)
    SetParab2d = _swig_new_instance_method(_Geom2d.Geom2d_Parabola_SetParab2d)


    @staticmethod
    def DownCast(t):
      return Handle_Geom2d_Parabola_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom2d.delete_Geom2d_Parabola

# Register Geom2d_Parabola in _Geom2d:
_Geom2d.Geom2d_Parabola_swigregister(Geom2d_Parabola)

class Geom2d_TrimmedCurve(Geom2d_BoundedCurve):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    BasisCurve = _swig_new_instance_method(_Geom2d.Geom2d_TrimmedCurve_BasisCurve)

    def __init__(self, *args):
        r"""
        * Creates a trimmed curve from the basis curve C limited between U1 and U2. //! . U1 can be greater or lower than U2. . The returned curve is oriented from U1 to U2. . If the basis curve C is periodic there is an ambiguity because two parts are available. In this case by default the trimmed curve has the same orientation as the basis curve (Sense = True). If Sense = False then the orientation of the trimmed curve is opposite to the orientation of the basis curve C. If the curve is closed but not periodic it is not possible to keep the part of the curve including the junction point (except if the junction point is at the beginning or at the end of the trimmed curve) because you could lose the fundamental characteristics of the basis curve which are used for example to compute the derivatives of the trimmed curve. So for a closed curve the rules are the same as for a open curve. Warnings : In this package the entities are not shared. The TrimmedCurve is built with a copy of the curve C. So when C is modified the TrimmedCurve is not modified Warnings : If <C> is periodic and <theAdjustPeriodic> is True, parametrics bounds of the TrimmedCurve, can be different to [<U1>;<U2>}, if <U1> or <U2> are not in the principal period. Include : For more explanation see the scheme given with this class. Raises ConstructionError the C is not periodic and U1 or U2 are out of the bounds of C. Raised if U1 = U2.
        	:param C:
        	:type C: Geom2d_Curve
        	:param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:param Sense: default value is Standard_True
        	:type Sense: bool
        	:param theAdjustPeriodic: default value is Standard_True
        	:type theAdjustPeriodic: bool
        	:rtype: None
        """
        _Geom2d.Geom2d_TrimmedCurve_swiginit(self, _Geom2d.new_Geom2d_TrimmedCurve(*args))
    SetTrim = _swig_new_instance_method(_Geom2d.Geom2d_TrimmedCurve_SetTrim)


    @staticmethod
    def DownCast(t):
      return Handle_Geom2d_TrimmedCurve_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom2d.delete_Geom2d_TrimmedCurve

# Register Geom2d_TrimmedCurve in _Geom2d:
_Geom2d.Geom2d_TrimmedCurve_swigregister(Geom2d_TrimmedCurve)



