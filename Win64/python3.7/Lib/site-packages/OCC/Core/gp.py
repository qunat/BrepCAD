# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
gp module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_gp.html
"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _gp
else:
    import _gp

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _gp.SWIG_PyInstanceMethod_New
_swig_new_static_method = _gp.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gp.delete_SwigPyIterator
    value = _swig_new_instance_method(_gp.SwigPyIterator_value)
    incr = _swig_new_instance_method(_gp.SwigPyIterator_incr)
    decr = _swig_new_instance_method(_gp.SwigPyIterator_decr)
    distance = _swig_new_instance_method(_gp.SwigPyIterator_distance)
    equal = _swig_new_instance_method(_gp.SwigPyIterator_equal)
    copy = _swig_new_instance_method(_gp.SwigPyIterator_copy)
    next = _swig_new_instance_method(_gp.SwigPyIterator_next)
    __next__ = _swig_new_instance_method(_gp.SwigPyIterator___next__)
    previous = _swig_new_instance_method(_gp.SwigPyIterator_previous)
    advance = _swig_new_instance_method(_gp.SwigPyIterator_advance)
    __eq__ = _swig_new_instance_method(_gp.SwigPyIterator___eq__)
    __ne__ = _swig_new_instance_method(_gp.SwigPyIterator___ne__)
    __iadd__ = _swig_new_instance_method(_gp.SwigPyIterator___iadd__)
    __isub__ = _swig_new_instance_method(_gp.SwigPyIterator___isub__)
    __add__ = _swig_new_instance_method(_gp.SwigPyIterator___add__)
    __sub__ = _swig_new_instance_method(_gp.SwigPyIterator___sub__)
    def __iter__(self):
        return self

# Register SwigPyIterator in _gp:
_gp.SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
gp_Identity = _gp.gp_Identity
gp_Rotation = _gp.gp_Rotation
gp_Translation = _gp.gp_Translation
gp_PntMirror = _gp.gp_PntMirror
gp_Ax1Mirror = _gp.gp_Ax1Mirror
gp_Ax2Mirror = _gp.gp_Ax2Mirror
gp_Scale = _gp.gp_Scale
gp_CompoundTrsf = _gp.gp_CompoundTrsf
gp_Other = _gp.gp_Other
gp_EulerAngles = _gp.gp_EulerAngles
gp_YawPitchRoll = _gp.gp_YawPitchRoll
gp_Extrinsic_XYZ = _gp.gp_Extrinsic_XYZ
gp_Extrinsic_XZY = _gp.gp_Extrinsic_XZY
gp_Extrinsic_YZX = _gp.gp_Extrinsic_YZX
gp_Extrinsic_YXZ = _gp.gp_Extrinsic_YXZ
gp_Extrinsic_ZXY = _gp.gp_Extrinsic_ZXY
gp_Extrinsic_ZYX = _gp.gp_Extrinsic_ZYX
gp_Intrinsic_XYZ = _gp.gp_Intrinsic_XYZ
gp_Intrinsic_XZY = _gp.gp_Intrinsic_XZY
gp_Intrinsic_YZX = _gp.gp_Intrinsic_YZX
gp_Intrinsic_YXZ = _gp.gp_Intrinsic_YXZ
gp_Intrinsic_ZXY = _gp.gp_Intrinsic_ZXY
gp_Intrinsic_ZYX = _gp.gp_Intrinsic_ZYX
gp_Extrinsic_XYX = _gp.gp_Extrinsic_XYX
gp_Extrinsic_XZX = _gp.gp_Extrinsic_XZX
gp_Extrinsic_YZY = _gp.gp_Extrinsic_YZY
gp_Extrinsic_YXY = _gp.gp_Extrinsic_YXY
gp_Extrinsic_ZYZ = _gp.gp_Extrinsic_ZYZ
gp_Extrinsic_ZXZ = _gp.gp_Extrinsic_ZXZ
gp_Intrinsic_XYX = _gp.gp_Intrinsic_XYX
gp_Intrinsic_XZX = _gp.gp_Intrinsic_XZX
gp_Intrinsic_YZY = _gp.gp_Intrinsic_YZY
gp_Intrinsic_YXY = _gp.gp_Intrinsic_YXY
gp_Intrinsic_ZXZ = _gp.gp_Intrinsic_ZXZ
gp_Intrinsic_ZYZ = _gp.gp_Intrinsic_ZYZ
class gp(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DX = _swig_new_static_method(_gp.gp_DX)
    DX2d = _swig_new_static_method(_gp.gp_DX2d)
    DY = _swig_new_static_method(_gp.gp_DY)
    DY2d = _swig_new_static_method(_gp.gp_DY2d)
    DZ = _swig_new_static_method(_gp.gp_DZ)
    OX = _swig_new_static_method(_gp.gp_OX)
    OX2d = _swig_new_static_method(_gp.gp_OX2d)
    OY = _swig_new_static_method(_gp.gp_OY)
    OY2d = _swig_new_static_method(_gp.gp_OY2d)
    OZ = _swig_new_static_method(_gp.gp_OZ)
    Origin = _swig_new_static_method(_gp.gp_Origin)
    Origin2d = _swig_new_static_method(_gp.gp_Origin2d)
    Resolution = _swig_new_static_method(_gp.gp_Resolution)
    XOY = _swig_new_static_method(_gp.gp_XOY)
    YOZ = _swig_new_static_method(_gp.gp_YOZ)
    ZOX = _swig_new_static_method(_gp.gp_ZOX)

    __repr__ = _dumps_object


    def __init__(self):
        _gp.gp_swiginit(self, _gp.new_gp())
    __swig_destroy__ = _gp.delete_gp

# Register gp in _gp:
_gp.gp_swigregister(gp)
gp_DX = _gp.gp_DX
gp_DX2d = _gp.gp_DX2d
gp_DY = _gp.gp_DY
gp_DY2d = _gp.gp_DY2d
gp_DZ = _gp.gp_DZ
gp_OX = _gp.gp_OX
gp_OX2d = _gp.gp_OX2d
gp_OY = _gp.gp_OY
gp_OY2d = _gp.gp_OY2d
gp_OZ = _gp.gp_OZ
gp_Origin = _gp.gp_Origin
gp_Origin2d = _gp.gp_Origin2d
gp_Resolution = _gp.gp_Resolution
gp_XOY = _gp.gp_XOY
gp_YOZ = _gp.gp_YOZ
gp_ZOX = _gp.gp_ZOX

class gp_Ax1(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Angle = _swig_new_instance_method(_gp.gp_Ax1_Angle)
    Direction = _swig_new_instance_method(_gp.gp_Ax1_Direction)
    IsCoaxial = _swig_new_instance_method(_gp.gp_Ax1_IsCoaxial)
    IsNormal = _swig_new_instance_method(_gp.gp_Ax1_IsNormal)
    IsOpposite = _swig_new_instance_method(_gp.gp_Ax1_IsOpposite)
    IsParallel = _swig_new_instance_method(_gp.gp_Ax1_IsParallel)
    Location = _swig_new_instance_method(_gp.gp_Ax1_Location)
    Mirror = _swig_new_instance_method(_gp.gp_Ax1_Mirror)
    Mirrored = _swig_new_instance_method(_gp.gp_Ax1_Mirrored)
    Reverse = _swig_new_instance_method(_gp.gp_Ax1_Reverse)
    Reversed = _swig_new_instance_method(_gp.gp_Ax1_Reversed)
    Rotate = _swig_new_instance_method(_gp.gp_Ax1_Rotate)
    Rotated = _swig_new_instance_method(_gp.gp_Ax1_Rotated)
    Scale = _swig_new_instance_method(_gp.gp_Ax1_Scale)
    Scaled = _swig_new_instance_method(_gp.gp_Ax1_Scaled)
    SetDirection = _swig_new_instance_method(_gp.gp_Ax1_SetDirection)
    SetLocation = _swig_new_instance_method(_gp.gp_Ax1_SetLocation)
    Transform = _swig_new_instance_method(_gp.gp_Ax1_Transform)
    Transformed = _swig_new_instance_method(_gp.gp_Ax1_Transformed)
    Translate = _swig_new_instance_method(_gp.gp_Ax1_Translate)
    Translated = _swig_new_instance_method(_gp.gp_Ax1_Translated)

    def __init__(self, *args):
        r"""
        * Creates an axis object representing Z axis of the reference co-ordinate system.
        	:rtype: None* P is the location point and V is the direction of <self>.
        	:param P:
        	:type P: gp_Pnt
        	:param V:
        	:type V: gp_Dir
        	:rtype: None
        """
        _gp.gp_Ax1_swiginit(self, _gp.new_gp_Ax1(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Ax1

# Register gp_Ax1 in _gp:
_gp.gp_Ax1_swigregister(gp_Ax1)

class gp_Ax2(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Angle = _swig_new_instance_method(_gp.gp_Ax2_Angle)
    Axis = _swig_new_instance_method(_gp.gp_Ax2_Axis)
    Direction = _swig_new_instance_method(_gp.gp_Ax2_Direction)
    IsCoplanar = _swig_new_instance_method(_gp.gp_Ax2_IsCoplanar)
    Location = _swig_new_instance_method(_gp.gp_Ax2_Location)
    Mirror = _swig_new_instance_method(_gp.gp_Ax2_Mirror)
    Mirrored = _swig_new_instance_method(_gp.gp_Ax2_Mirrored)
    Rotate = _swig_new_instance_method(_gp.gp_Ax2_Rotate)
    Rotated = _swig_new_instance_method(_gp.gp_Ax2_Rotated)
    Scale = _swig_new_instance_method(_gp.gp_Ax2_Scale)
    Scaled = _swig_new_instance_method(_gp.gp_Ax2_Scaled)
    SetAxis = _swig_new_instance_method(_gp.gp_Ax2_SetAxis)
    SetDirection = _swig_new_instance_method(_gp.gp_Ax2_SetDirection)
    SetLocation = _swig_new_instance_method(_gp.gp_Ax2_SetLocation)
    SetXDirection = _swig_new_instance_method(_gp.gp_Ax2_SetXDirection)
    SetYDirection = _swig_new_instance_method(_gp.gp_Ax2_SetYDirection)
    Transform = _swig_new_instance_method(_gp.gp_Ax2_Transform)
    Transformed = _swig_new_instance_method(_gp.gp_Ax2_Transformed)
    Translate = _swig_new_instance_method(_gp.gp_Ax2_Translate)
    Translated = _swig_new_instance_method(_gp.gp_Ax2_Translated)
    XDirection = _swig_new_instance_method(_gp.gp_Ax2_XDirection)
    YDirection = _swig_new_instance_method(_gp.gp_Ax2_YDirection)

    def __init__(self, *args):
        r"""
        * Creates an object corresponding to the reference coordinate system (OXYZ).
        	:rtype: None* Creates an axis placement with an origin P such that: - N is the Direction, and - the 'X Direction' is normal to N, in the plane defined by the vectors (N, Vx): 'X Direction' = (N ^ Vx) ^ N, Exception: raises ConstructionError if N and Vx are parallel (same or opposite orientation).
        	:param P:
        	:type P: gp_Pnt
        	:param N:
        	:type N: gp_Dir
        	:param Vx:
        	:type Vx: gp_Dir
        	:rtype: None* Creates - a coordinate system with an origin P, where V gives the 'main Direction' (here, 'X Direction' and 'Y Direction' are defined automatically).
        	:param P:
        	:type P: gp_Pnt
        	:param V:
        	:type V: gp_Dir
        	:rtype: None
        """
        _gp.gp_Ax2_swiginit(self, _gp.new_gp_Ax2(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Ax2

# Register gp_Ax2 in _gp:
_gp.gp_Ax2_swigregister(gp_Ax2)

class gp_Ax22d(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Location = _swig_new_instance_method(_gp.gp_Ax22d_Location)
    Mirror = _swig_new_instance_method(_gp.gp_Ax22d_Mirror)
    Mirrored = _swig_new_instance_method(_gp.gp_Ax22d_Mirrored)
    Rotate = _swig_new_instance_method(_gp.gp_Ax22d_Rotate)
    Rotated = _swig_new_instance_method(_gp.gp_Ax22d_Rotated)
    Scale = _swig_new_instance_method(_gp.gp_Ax22d_Scale)
    Scaled = _swig_new_instance_method(_gp.gp_Ax22d_Scaled)
    SetAxis = _swig_new_instance_method(_gp.gp_Ax22d_SetAxis)
    SetLocation = _swig_new_instance_method(_gp.gp_Ax22d_SetLocation)
    SetXAxis = _swig_new_instance_method(_gp.gp_Ax22d_SetXAxis)
    SetXDirection = _swig_new_instance_method(_gp.gp_Ax22d_SetXDirection)
    SetYAxis = _swig_new_instance_method(_gp.gp_Ax22d_SetYAxis)
    SetYDirection = _swig_new_instance_method(_gp.gp_Ax22d_SetYDirection)
    Transform = _swig_new_instance_method(_gp.gp_Ax22d_Transform)
    Transformed = _swig_new_instance_method(_gp.gp_Ax22d_Transformed)
    Translate = _swig_new_instance_method(_gp.gp_Ax22d_Translate)
    Translated = _swig_new_instance_method(_gp.gp_Ax22d_Translated)
    XAxis = _swig_new_instance_method(_gp.gp_Ax22d_XAxis)
    XDirection = _swig_new_instance_method(_gp.gp_Ax22d_XDirection)
    YAxis = _swig_new_instance_method(_gp.gp_Ax22d_YAxis)
    YDirection = _swig_new_instance_method(_gp.gp_Ax22d_YDirection)

    def __init__(self, *args):
        r"""
        * Creates an object representing the reference co-ordinate system (OXY).
        	:rtype: None* Creates a coordinate system with origin P and where: - Vx is the 'X Direction', and - the 'Y Direction' is orthogonal to Vx and oriented so that the cross products Vx^'Y Direction' and Vx^Vy have the same sign. Raises ConstructionError if Vx and Vy are parallel (same or opposite orientation).
        	:param P:
        	:type P: gp_Pnt2d
        	:param Vx:
        	:type Vx: gp_Dir2d
        	:param Vy:
        	:type Vy: gp_Dir2d
        	:rtype: None* Creates - a coordinate system with origin P and 'X Direction' V, which is: - right-handed if Sense is true (default value), or - left-handed if Sense is false
        	:param P:
        	:type P: gp_Pnt2d
        	:param V:
        	:type V: gp_Dir2d
        	:param Sense: default value is Standard_True
        	:type Sense: bool
        	:rtype: None* Creates - a coordinate system where its origin is the origin of A and its 'X Direction' is the unit vector of A, which is: - right-handed if Sense is true (default value), or - left-handed if Sense is false.
        	:param A:
        	:type A: gp_Ax2d
        	:param Sense: default value is Standard_True
        	:type Sense: bool
        	:rtype: None
        """
        _gp.gp_Ax22d_swiginit(self, _gp.new_gp_Ax22d(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Ax22d

# Register gp_Ax22d in _gp:
_gp.gp_Ax22d_swigregister(gp_Ax22d)

class gp_Ax2d(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Angle = _swig_new_instance_method(_gp.gp_Ax2d_Angle)
    Direction = _swig_new_instance_method(_gp.gp_Ax2d_Direction)
    IsCoaxial = _swig_new_instance_method(_gp.gp_Ax2d_IsCoaxial)
    IsNormal = _swig_new_instance_method(_gp.gp_Ax2d_IsNormal)
    IsOpposite = _swig_new_instance_method(_gp.gp_Ax2d_IsOpposite)
    IsParallel = _swig_new_instance_method(_gp.gp_Ax2d_IsParallel)
    Location = _swig_new_instance_method(_gp.gp_Ax2d_Location)
    Mirror = _swig_new_instance_method(_gp.gp_Ax2d_Mirror)
    Mirrored = _swig_new_instance_method(_gp.gp_Ax2d_Mirrored)
    Reverse = _swig_new_instance_method(_gp.gp_Ax2d_Reverse)
    Reversed = _swig_new_instance_method(_gp.gp_Ax2d_Reversed)
    Rotate = _swig_new_instance_method(_gp.gp_Ax2d_Rotate)
    Rotated = _swig_new_instance_method(_gp.gp_Ax2d_Rotated)
    Scale = _swig_new_instance_method(_gp.gp_Ax2d_Scale)
    Scaled = _swig_new_instance_method(_gp.gp_Ax2d_Scaled)
    SetDirection = _swig_new_instance_method(_gp.gp_Ax2d_SetDirection)
    SetLocation = _swig_new_instance_method(_gp.gp_Ax2d_SetLocation)
    Transform = _swig_new_instance_method(_gp.gp_Ax2d_Transform)
    Transformed = _swig_new_instance_method(_gp.gp_Ax2d_Transformed)
    Translate = _swig_new_instance_method(_gp.gp_Ax2d_Translate)
    Translated = _swig_new_instance_method(_gp.gp_Ax2d_Translated)

    def __init__(self, *args):
        r"""
        * Creates an axis object representing X axis of the reference co-ordinate system.
        	:rtype: None* Creates an Ax2d. <P> is the 'Location' point of the axis placement and V is the 'Direction' of the axis placement.
        	:param P:
        	:type P: gp_Pnt2d
        	:param V:
        	:type V: gp_Dir2d
        	:rtype: None
        """
        _gp.gp_Ax2d_swiginit(self, _gp.new_gp_Ax2d(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Ax2d

# Register gp_Ax2d in _gp:
_gp.gp_Ax2d_swigregister(gp_Ax2d)

class gp_Ax3(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Angle = _swig_new_instance_method(_gp.gp_Ax3_Angle)
    Ax2 = _swig_new_instance_method(_gp.gp_Ax3_Ax2)
    Axis = _swig_new_instance_method(_gp.gp_Ax3_Axis)
    Direct = _swig_new_instance_method(_gp.gp_Ax3_Direct)
    Direction = _swig_new_instance_method(_gp.gp_Ax3_Direction)
    IsCoplanar = _swig_new_instance_method(_gp.gp_Ax3_IsCoplanar)
    Location = _swig_new_instance_method(_gp.gp_Ax3_Location)
    Mirror = _swig_new_instance_method(_gp.gp_Ax3_Mirror)
    Mirrored = _swig_new_instance_method(_gp.gp_Ax3_Mirrored)
    Rotate = _swig_new_instance_method(_gp.gp_Ax3_Rotate)
    Rotated = _swig_new_instance_method(_gp.gp_Ax3_Rotated)
    Scale = _swig_new_instance_method(_gp.gp_Ax3_Scale)
    Scaled = _swig_new_instance_method(_gp.gp_Ax3_Scaled)
    SetAxis = _swig_new_instance_method(_gp.gp_Ax3_SetAxis)
    SetDirection = _swig_new_instance_method(_gp.gp_Ax3_SetDirection)
    SetLocation = _swig_new_instance_method(_gp.gp_Ax3_SetLocation)
    SetXDirection = _swig_new_instance_method(_gp.gp_Ax3_SetXDirection)
    SetYDirection = _swig_new_instance_method(_gp.gp_Ax3_SetYDirection)
    Transform = _swig_new_instance_method(_gp.gp_Ax3_Transform)
    Transformed = _swig_new_instance_method(_gp.gp_Ax3_Transformed)
    Translate = _swig_new_instance_method(_gp.gp_Ax3_Translate)
    Translated = _swig_new_instance_method(_gp.gp_Ax3_Translated)
    XDirection = _swig_new_instance_method(_gp.gp_Ax3_XDirection)
    XReverse = _swig_new_instance_method(_gp.gp_Ax3_XReverse)
    YDirection = _swig_new_instance_method(_gp.gp_Ax3_YDirection)
    YReverse = _swig_new_instance_method(_gp.gp_Ax3_YReverse)
    ZReverse = _swig_new_instance_method(_gp.gp_Ax3_ZReverse)

    def __init__(self, *args):
        r"""
        * Creates an object corresponding to the reference coordinate system (OXYZ).
        	:rtype: None* Creates a coordinate system from a right-handed coordinate system.
        	:param A:
        	:type A: gp_Ax2
        	:rtype: None* Creates a right handed axis placement with the 'Location' point P and two directions, N gives the 'Direction' and Vx gives the 'XDirection'. Raises ConstructionError if N and Vx are parallel (same or opposite orientation).
        	:param P:
        	:type P: gp_Pnt
        	:param N:
        	:type N: gp_Dir
        	:param Vx:
        	:type Vx: gp_Dir
        	:rtype: None* Creates an axis placement with the 'Location' point <P> and the normal direction <V>.
        	:param P:
        	:type P: gp_Pnt
        	:param V:
        	:type V: gp_Dir
        	:rtype: None
        """
        _gp.gp_Ax3_swiginit(self, _gp.new_gp_Ax3(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Ax3

# Register gp_Ax3 in _gp:
_gp.gp_Ax3_swigregister(gp_Ax3)

class gp_Circ(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Area = _swig_new_instance_method(_gp.gp_Circ_Area)
    Axis = _swig_new_instance_method(_gp.gp_Circ_Axis)
    Contains = _swig_new_instance_method(_gp.gp_Circ_Contains)
    Distance = _swig_new_instance_method(_gp.gp_Circ_Distance)
    Length = _swig_new_instance_method(_gp.gp_Circ_Length)
    Location = _swig_new_instance_method(_gp.gp_Circ_Location)
    Mirror = _swig_new_instance_method(_gp.gp_Circ_Mirror)
    Mirrored = _swig_new_instance_method(_gp.gp_Circ_Mirrored)
    Position = _swig_new_instance_method(_gp.gp_Circ_Position)
    Radius = _swig_new_instance_method(_gp.gp_Circ_Radius)
    Rotate = _swig_new_instance_method(_gp.gp_Circ_Rotate)
    Rotated = _swig_new_instance_method(_gp.gp_Circ_Rotated)
    Scale = _swig_new_instance_method(_gp.gp_Circ_Scale)
    Scaled = _swig_new_instance_method(_gp.gp_Circ_Scaled)
    SetAxis = _swig_new_instance_method(_gp.gp_Circ_SetAxis)
    SetLocation = _swig_new_instance_method(_gp.gp_Circ_SetLocation)
    SetPosition = _swig_new_instance_method(_gp.gp_Circ_SetPosition)
    SetRadius = _swig_new_instance_method(_gp.gp_Circ_SetRadius)
    SquareDistance = _swig_new_instance_method(_gp.gp_Circ_SquareDistance)
    Transform = _swig_new_instance_method(_gp.gp_Circ_Transform)
    Transformed = _swig_new_instance_method(_gp.gp_Circ_Transformed)
    Translate = _swig_new_instance_method(_gp.gp_Circ_Translate)
    Translated = _swig_new_instance_method(_gp.gp_Circ_Translated)
    XAxis = _swig_new_instance_method(_gp.gp_Circ_XAxis)
    YAxis = _swig_new_instance_method(_gp.gp_Circ_YAxis)

    def __init__(self, *args):
        r"""
        * Creates an indefinite circle.
        	:rtype: None* A2 locates the circle and gives its orientation in 3D space. Warnings : It is not forbidden to create a circle with Radius = 0.0 Raises ConstructionError if Radius < 0.0
        	:param A2:
        	:type A2: gp_Ax2
        	:param Radius:
        	:type Radius: float
        	:rtype: None
        """
        _gp.gp_Circ_swiginit(self, _gp.new_gp_Circ(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Circ

# Register gp_Circ in _gp:
_gp.gp_Circ_swigregister(gp_Circ)

class gp_Circ2d(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Area = _swig_new_instance_method(_gp.gp_Circ2d_Area)
    Axis = _swig_new_instance_method(_gp.gp_Circ2d_Axis)
    Coefficients = _swig_new_instance_method(_gp.gp_Circ2d_Coefficients)
    Contains = _swig_new_instance_method(_gp.gp_Circ2d_Contains)
    Distance = _swig_new_instance_method(_gp.gp_Circ2d_Distance)
    IsDirect = _swig_new_instance_method(_gp.gp_Circ2d_IsDirect)
    Length = _swig_new_instance_method(_gp.gp_Circ2d_Length)
    Location = _swig_new_instance_method(_gp.gp_Circ2d_Location)
    Mirror = _swig_new_instance_method(_gp.gp_Circ2d_Mirror)
    Mirrored = _swig_new_instance_method(_gp.gp_Circ2d_Mirrored)
    Position = _swig_new_instance_method(_gp.gp_Circ2d_Position)
    Radius = _swig_new_instance_method(_gp.gp_Circ2d_Radius)
    Reverse = _swig_new_instance_method(_gp.gp_Circ2d_Reverse)
    Reversed = _swig_new_instance_method(_gp.gp_Circ2d_Reversed)
    Rotate = _swig_new_instance_method(_gp.gp_Circ2d_Rotate)
    Rotated = _swig_new_instance_method(_gp.gp_Circ2d_Rotated)
    Scale = _swig_new_instance_method(_gp.gp_Circ2d_Scale)
    Scaled = _swig_new_instance_method(_gp.gp_Circ2d_Scaled)
    SetAxis = _swig_new_instance_method(_gp.gp_Circ2d_SetAxis)
    SetLocation = _swig_new_instance_method(_gp.gp_Circ2d_SetLocation)
    SetRadius = _swig_new_instance_method(_gp.gp_Circ2d_SetRadius)
    SetXAxis = _swig_new_instance_method(_gp.gp_Circ2d_SetXAxis)
    SetYAxis = _swig_new_instance_method(_gp.gp_Circ2d_SetYAxis)
    SquareDistance = _swig_new_instance_method(_gp.gp_Circ2d_SquareDistance)
    Transform = _swig_new_instance_method(_gp.gp_Circ2d_Transform)
    Transformed = _swig_new_instance_method(_gp.gp_Circ2d_Transformed)
    Translate = _swig_new_instance_method(_gp.gp_Circ2d_Translate)
    Translated = _swig_new_instance_method(_gp.gp_Circ2d_Translated)
    XAxis = _swig_new_instance_method(_gp.gp_Circ2d_XAxis)
    YAxis = _swig_new_instance_method(_gp.gp_Circ2d_YAxis)

    def __init__(self, *args):
        r"""
        * creates an indefinite circle.
        	:rtype: None* The location point of XAxis is the center of the circle. Warnings : It is not forbidden to create a circle with Radius = 0.0 Raises ConstructionError if Radius < 0.0. Raised if Radius < 0.0.
        	:param XAxis:
        	:type XAxis: gp_Ax2d
        	:param Radius:
        	:type Radius: float
        	:param Sense: default value is Standard_True
        	:type Sense: bool
        	:rtype: None* Axis defines the Xaxis and Yaxis of the circle which defines the origin and the sense of parametrization. The location point of Axis is the center of the circle. Warnings : It is not forbidden to create a circle with Radius = 0.0 Raises ConstructionError if Radius < 0.0. Raised if Radius < 0.0.
        	:param Axis:
        	:type Axis: gp_Ax22d
        	:param Radius:
        	:type Radius: float
        	:rtype: None
        """
        _gp.gp_Circ2d_swiginit(self, _gp.new_gp_Circ2d(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Circ2d

# Register gp_Circ2d in _gp:
_gp.gp_Circ2d_swigregister(gp_Circ2d)

class gp_Cone(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Apex = _swig_new_instance_method(_gp.gp_Cone_Apex)
    Axis = _swig_new_instance_method(_gp.gp_Cone_Axis)
    Coefficients = _swig_new_instance_method(_gp.gp_Cone_Coefficients)
    Direct = _swig_new_instance_method(_gp.gp_Cone_Direct)
    Location = _swig_new_instance_method(_gp.gp_Cone_Location)
    Mirror = _swig_new_instance_method(_gp.gp_Cone_Mirror)
    Mirrored = _swig_new_instance_method(_gp.gp_Cone_Mirrored)
    Position = _swig_new_instance_method(_gp.gp_Cone_Position)
    RefRadius = _swig_new_instance_method(_gp.gp_Cone_RefRadius)
    Rotate = _swig_new_instance_method(_gp.gp_Cone_Rotate)
    Rotated = _swig_new_instance_method(_gp.gp_Cone_Rotated)
    Scale = _swig_new_instance_method(_gp.gp_Cone_Scale)
    Scaled = _swig_new_instance_method(_gp.gp_Cone_Scaled)
    SemiAngle = _swig_new_instance_method(_gp.gp_Cone_SemiAngle)
    SetAxis = _swig_new_instance_method(_gp.gp_Cone_SetAxis)
    SetLocation = _swig_new_instance_method(_gp.gp_Cone_SetLocation)
    SetPosition = _swig_new_instance_method(_gp.gp_Cone_SetPosition)
    SetRadius = _swig_new_instance_method(_gp.gp_Cone_SetRadius)
    SetSemiAngle = _swig_new_instance_method(_gp.gp_Cone_SetSemiAngle)
    Transform = _swig_new_instance_method(_gp.gp_Cone_Transform)
    Transformed = _swig_new_instance_method(_gp.gp_Cone_Transformed)
    Translate = _swig_new_instance_method(_gp.gp_Cone_Translate)
    Translated = _swig_new_instance_method(_gp.gp_Cone_Translated)
    UReverse = _swig_new_instance_method(_gp.gp_Cone_UReverse)
    VReverse = _swig_new_instance_method(_gp.gp_Cone_VReverse)
    XAxis = _swig_new_instance_method(_gp.gp_Cone_XAxis)
    YAxis = _swig_new_instance_method(_gp.gp_Cone_YAxis)

    def __init__(self, *args):
        r"""
        * Creates an indefinite Cone.
        	:rtype: None* Creates an infinite conical surface. A3 locates the cone in the space and defines the reference plane of the surface. Ang is the conical surface semi-angle. Its absolute value is in range ]0, PI/2[. Radius is the radius of the circle in the reference plane of the cone. Raises ConstructionError * if Radius is lower than 0.0 * Abs(Ang) < Resolution from gp or Abs(Ang) >= (PI/2) - Resolution.
        	:param A3:
        	:type A3: gp_Ax3
        	:param Ang:
        	:type Ang: float
        	:param Radius:
        	:type Radius: float
        	:rtype: None
        """
        _gp.gp_Cone_swiginit(self, _gp.new_gp_Cone(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Cone

# Register gp_Cone in _gp:
_gp.gp_Cone_swigregister(gp_Cone)

class gp_Cylinder(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Axis = _swig_new_instance_method(_gp.gp_Cylinder_Axis)
    Coefficients = _swig_new_instance_method(_gp.gp_Cylinder_Coefficients)
    Direct = _swig_new_instance_method(_gp.gp_Cylinder_Direct)
    Location = _swig_new_instance_method(_gp.gp_Cylinder_Location)
    Mirror = _swig_new_instance_method(_gp.gp_Cylinder_Mirror)
    Mirrored = _swig_new_instance_method(_gp.gp_Cylinder_Mirrored)
    Position = _swig_new_instance_method(_gp.gp_Cylinder_Position)
    Radius = _swig_new_instance_method(_gp.gp_Cylinder_Radius)
    Rotate = _swig_new_instance_method(_gp.gp_Cylinder_Rotate)
    Rotated = _swig_new_instance_method(_gp.gp_Cylinder_Rotated)
    Scale = _swig_new_instance_method(_gp.gp_Cylinder_Scale)
    Scaled = _swig_new_instance_method(_gp.gp_Cylinder_Scaled)
    SetAxis = _swig_new_instance_method(_gp.gp_Cylinder_SetAxis)
    SetLocation = _swig_new_instance_method(_gp.gp_Cylinder_SetLocation)
    SetPosition = _swig_new_instance_method(_gp.gp_Cylinder_SetPosition)
    SetRadius = _swig_new_instance_method(_gp.gp_Cylinder_SetRadius)
    Transform = _swig_new_instance_method(_gp.gp_Cylinder_Transform)
    Transformed = _swig_new_instance_method(_gp.gp_Cylinder_Transformed)
    Translate = _swig_new_instance_method(_gp.gp_Cylinder_Translate)
    Translated = _swig_new_instance_method(_gp.gp_Cylinder_Translated)
    UReverse = _swig_new_instance_method(_gp.gp_Cylinder_UReverse)
    VReverse = _swig_new_instance_method(_gp.gp_Cylinder_VReverse)
    XAxis = _swig_new_instance_method(_gp.gp_Cylinder_XAxis)
    YAxis = _swig_new_instance_method(_gp.gp_Cylinder_YAxis)

    def __init__(self, *args):
        r"""
        * Creates a indefinite cylinder.
        	:rtype: None* Creates a cylinder of radius Radius, whose axis is the 'main Axis' of A3. A3 is the local coordinate system of the cylinder. Raises ConstructionErrord if R < 0.0
        	:param A3:
        	:type A3: gp_Ax3
        	:param Radius:
        	:type Radius: float
        	:rtype: None
        """
        _gp.gp_Cylinder_swiginit(self, _gp.new_gp_Cylinder(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Cylinder

# Register gp_Cylinder in _gp:
_gp.gp_Cylinder_swigregister(gp_Cylinder)

class gp_Dir(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Angle = _swig_new_instance_method(_gp.gp_Dir_Angle)
    AngleWithRef = _swig_new_instance_method(_gp.gp_Dir_AngleWithRef)
    Coord = _swig_new_instance_method(_gp.gp_Dir_Coord)
    Cross = _swig_new_instance_method(_gp.gp_Dir_Cross)
    CrossCross = _swig_new_instance_method(_gp.gp_Dir_CrossCross)
    CrossCrossed = _swig_new_instance_method(_gp.gp_Dir_CrossCrossed)
    Crossed = _swig_new_instance_method(_gp.gp_Dir_Crossed)
    Dot = _swig_new_instance_method(_gp.gp_Dir_Dot)
    DotCross = _swig_new_instance_method(_gp.gp_Dir_DotCross)
    IsEqual = _swig_new_instance_method(_gp.gp_Dir_IsEqual)
    IsNormal = _swig_new_instance_method(_gp.gp_Dir_IsNormal)
    IsOpposite = _swig_new_instance_method(_gp.gp_Dir_IsOpposite)
    IsParallel = _swig_new_instance_method(_gp.gp_Dir_IsParallel)
    Mirror = _swig_new_instance_method(_gp.gp_Dir_Mirror)
    Mirrored = _swig_new_instance_method(_gp.gp_Dir_Mirrored)
    Reverse = _swig_new_instance_method(_gp.gp_Dir_Reverse)
    Reversed = _swig_new_instance_method(_gp.gp_Dir_Reversed)
    Rotate = _swig_new_instance_method(_gp.gp_Dir_Rotate)
    Rotated = _swig_new_instance_method(_gp.gp_Dir_Rotated)
    SetCoord = _swig_new_instance_method(_gp.gp_Dir_SetCoord)
    SetX = _swig_new_instance_method(_gp.gp_Dir_SetX)
    SetXYZ = _swig_new_instance_method(_gp.gp_Dir_SetXYZ)
    SetY = _swig_new_instance_method(_gp.gp_Dir_SetY)
    SetZ = _swig_new_instance_method(_gp.gp_Dir_SetZ)
    Transform = _swig_new_instance_method(_gp.gp_Dir_Transform)
    Transformed = _swig_new_instance_method(_gp.gp_Dir_Transformed)
    X = _swig_new_instance_method(_gp.gp_Dir_X)
    XYZ = _swig_new_instance_method(_gp.gp_Dir_XYZ)
    Y = _swig_new_instance_method(_gp.gp_Dir_Y)
    Z = _swig_new_instance_method(_gp.gp_Dir_Z)

    def __init__(self, *args):
        r"""
        * Creates a direction corresponding to X axis.
        	:rtype: None* Normalizes the vector V and creates a direction. Raises ConstructionError if V.Magnitude() <= Resolution.
        	:param V:
        	:type V: gp_Vec
        	:rtype: None* Creates a direction from a triplet of coordinates. Raises ConstructionError if Coord.Modulus() <= Resolution from gp.
        	:param Coord:
        	:type Coord: gp_XYZ
        	:rtype: None* Creates a direction with its 3 cartesian coordinates. Raises ConstructionError if Sqrt(Xv*Xv + Yv*Yv + Zv*Zv) <= Resolution Modification of the direction's coordinates If Sqrt (X*X + Y*Y + Z*Z) <= Resolution from gp where X, Y ,Z are the new coordinates it is not possible to construct the direction and the method raises the exception ConstructionError.
        	:param Xv:
        	:type Xv: float
        	:param Yv:
        	:type Yv: float
        	:param Zv:
        	:type Zv: float
        	:rtype: None
        """
        _gp.gp_Dir_swiginit(self, _gp.new_gp_Dir(*args))
    __mul__ = _swig_new_instance_method(_gp.gp_Dir___mul__)
    __neg__ = _swig_new_instance_method(_gp.gp_Dir___neg__)

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Dir

# Register gp_Dir in _gp:
_gp.gp_Dir_swigregister(gp_Dir)

class gp_Dir2d(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Angle = _swig_new_instance_method(_gp.gp_Dir2d_Angle)
    Coord = _swig_new_instance_method(_gp.gp_Dir2d_Coord)
    Crossed = _swig_new_instance_method(_gp.gp_Dir2d_Crossed)
    Dot = _swig_new_instance_method(_gp.gp_Dir2d_Dot)
    IsEqual = _swig_new_instance_method(_gp.gp_Dir2d_IsEqual)
    IsNormal = _swig_new_instance_method(_gp.gp_Dir2d_IsNormal)
    IsOpposite = _swig_new_instance_method(_gp.gp_Dir2d_IsOpposite)
    IsParallel = _swig_new_instance_method(_gp.gp_Dir2d_IsParallel)
    Mirror = _swig_new_instance_method(_gp.gp_Dir2d_Mirror)
    Mirrored = _swig_new_instance_method(_gp.gp_Dir2d_Mirrored)
    Reverse = _swig_new_instance_method(_gp.gp_Dir2d_Reverse)
    Reversed = _swig_new_instance_method(_gp.gp_Dir2d_Reversed)
    Rotate = _swig_new_instance_method(_gp.gp_Dir2d_Rotate)
    Rotated = _swig_new_instance_method(_gp.gp_Dir2d_Rotated)
    SetCoord = _swig_new_instance_method(_gp.gp_Dir2d_SetCoord)
    SetX = _swig_new_instance_method(_gp.gp_Dir2d_SetX)
    SetXY = _swig_new_instance_method(_gp.gp_Dir2d_SetXY)
    SetY = _swig_new_instance_method(_gp.gp_Dir2d_SetY)
    Transform = _swig_new_instance_method(_gp.gp_Dir2d_Transform)
    Transformed = _swig_new_instance_method(_gp.gp_Dir2d_Transformed)
    X = _swig_new_instance_method(_gp.gp_Dir2d_X)
    XY = _swig_new_instance_method(_gp.gp_Dir2d_XY)
    Y = _swig_new_instance_method(_gp.gp_Dir2d_Y)

    def __init__(self, *args):
        r"""
        * Creates a direction corresponding to X axis.
        	:rtype: None* Normalizes the vector V and creates a Direction. Raises ConstructionError if V.Magnitude() <= Resolution from gp.
        	:param V:
        	:type V: gp_Vec2d
        	:rtype: None* Creates a Direction from a doublet of coordinates. Raises ConstructionError if Coord.Modulus() <= Resolution from gp.
        	:param Coord:
        	:type Coord: gp_XY
        	:rtype: None* Creates a Direction with its 2 cartesian coordinates. Raises ConstructionError if Sqrt(Xv*Xv + Yv*Yv) <= Resolution from gp.
        	:param Xv:
        	:type Xv: float
        	:param Yv:
        	:type Yv: float
        	:rtype: None
        """
        _gp.gp_Dir2d_swiginit(self, _gp.new_gp_Dir2d(*args))
    __mul__ = _swig_new_instance_method(_gp.gp_Dir2d___mul__)
    __neg__ = _swig_new_instance_method(_gp.gp_Dir2d___neg__)

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Dir2d

# Register gp_Dir2d in _gp:
_gp.gp_Dir2d_swigregister(gp_Dir2d)

class gp_Elips(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Area = _swig_new_instance_method(_gp.gp_Elips_Area)
    Axis = _swig_new_instance_method(_gp.gp_Elips_Axis)
    Directrix1 = _swig_new_instance_method(_gp.gp_Elips_Directrix1)
    Directrix2 = _swig_new_instance_method(_gp.gp_Elips_Directrix2)
    Eccentricity = _swig_new_instance_method(_gp.gp_Elips_Eccentricity)
    Focal = _swig_new_instance_method(_gp.gp_Elips_Focal)
    Focus1 = _swig_new_instance_method(_gp.gp_Elips_Focus1)
    Focus2 = _swig_new_instance_method(_gp.gp_Elips_Focus2)
    Location = _swig_new_instance_method(_gp.gp_Elips_Location)
    MajorRadius = _swig_new_instance_method(_gp.gp_Elips_MajorRadius)
    MinorRadius = _swig_new_instance_method(_gp.gp_Elips_MinorRadius)
    Mirror = _swig_new_instance_method(_gp.gp_Elips_Mirror)
    Mirrored = _swig_new_instance_method(_gp.gp_Elips_Mirrored)
    Parameter = _swig_new_instance_method(_gp.gp_Elips_Parameter)
    Position = _swig_new_instance_method(_gp.gp_Elips_Position)
    Rotate = _swig_new_instance_method(_gp.gp_Elips_Rotate)
    Rotated = _swig_new_instance_method(_gp.gp_Elips_Rotated)
    Scale = _swig_new_instance_method(_gp.gp_Elips_Scale)
    Scaled = _swig_new_instance_method(_gp.gp_Elips_Scaled)
    SetAxis = _swig_new_instance_method(_gp.gp_Elips_SetAxis)
    SetLocation = _swig_new_instance_method(_gp.gp_Elips_SetLocation)
    SetMajorRadius = _swig_new_instance_method(_gp.gp_Elips_SetMajorRadius)
    SetMinorRadius = _swig_new_instance_method(_gp.gp_Elips_SetMinorRadius)
    SetPosition = _swig_new_instance_method(_gp.gp_Elips_SetPosition)
    Transform = _swig_new_instance_method(_gp.gp_Elips_Transform)
    Transformed = _swig_new_instance_method(_gp.gp_Elips_Transformed)
    Translate = _swig_new_instance_method(_gp.gp_Elips_Translate)
    Translated = _swig_new_instance_method(_gp.gp_Elips_Translated)
    XAxis = _swig_new_instance_method(_gp.gp_Elips_XAxis)
    YAxis = _swig_new_instance_method(_gp.gp_Elips_YAxis)

    def __init__(self, *args):
        r"""
        * Creates an indefinite ellipse.
        	:rtype: None* The major radius of the ellipse is on the 'XAxis' and the minor radius is on the 'YAxis' of the ellipse. The 'XAxis' is defined with the 'XDirection' of A2 and the 'YAxis' is defined with the 'YDirection' of A2. Warnings : It is not forbidden to create an ellipse with MajorRadius = MinorRadius. Raises ConstructionError if MajorRadius < MinorRadius or MinorRadius < 0.
        	:param A2:
        	:type A2: gp_Ax2
        	:param MajorRadius:
        	:type MajorRadius: float
        	:param MinorRadius:
        	:type MinorRadius: float
        	:rtype: None
        """
        _gp.gp_Elips_swiginit(self, _gp.new_gp_Elips(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Elips

# Register gp_Elips in _gp:
_gp.gp_Elips_swigregister(gp_Elips)

class gp_Elips2d(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Area = _swig_new_instance_method(_gp.gp_Elips2d_Area)
    Axis = _swig_new_instance_method(_gp.gp_Elips2d_Axis)
    Coefficients = _swig_new_instance_method(_gp.gp_Elips2d_Coefficients)
    Directrix1 = _swig_new_instance_method(_gp.gp_Elips2d_Directrix1)
    Directrix2 = _swig_new_instance_method(_gp.gp_Elips2d_Directrix2)
    Eccentricity = _swig_new_instance_method(_gp.gp_Elips2d_Eccentricity)
    Focal = _swig_new_instance_method(_gp.gp_Elips2d_Focal)
    Focus1 = _swig_new_instance_method(_gp.gp_Elips2d_Focus1)
    Focus2 = _swig_new_instance_method(_gp.gp_Elips2d_Focus2)
    IsDirect = _swig_new_instance_method(_gp.gp_Elips2d_IsDirect)
    Location = _swig_new_instance_method(_gp.gp_Elips2d_Location)
    MajorRadius = _swig_new_instance_method(_gp.gp_Elips2d_MajorRadius)
    MinorRadius = _swig_new_instance_method(_gp.gp_Elips2d_MinorRadius)
    Mirror = _swig_new_instance_method(_gp.gp_Elips2d_Mirror)
    Mirrored = _swig_new_instance_method(_gp.gp_Elips2d_Mirrored)
    Parameter = _swig_new_instance_method(_gp.gp_Elips2d_Parameter)
    Reverse = _swig_new_instance_method(_gp.gp_Elips2d_Reverse)
    Reversed = _swig_new_instance_method(_gp.gp_Elips2d_Reversed)
    Rotate = _swig_new_instance_method(_gp.gp_Elips2d_Rotate)
    Rotated = _swig_new_instance_method(_gp.gp_Elips2d_Rotated)
    Scale = _swig_new_instance_method(_gp.gp_Elips2d_Scale)
    Scaled = _swig_new_instance_method(_gp.gp_Elips2d_Scaled)
    SetAxis = _swig_new_instance_method(_gp.gp_Elips2d_SetAxis)
    SetLocation = _swig_new_instance_method(_gp.gp_Elips2d_SetLocation)
    SetMajorRadius = _swig_new_instance_method(_gp.gp_Elips2d_SetMajorRadius)
    SetMinorRadius = _swig_new_instance_method(_gp.gp_Elips2d_SetMinorRadius)
    SetXAxis = _swig_new_instance_method(_gp.gp_Elips2d_SetXAxis)
    SetYAxis = _swig_new_instance_method(_gp.gp_Elips2d_SetYAxis)
    Transform = _swig_new_instance_method(_gp.gp_Elips2d_Transform)
    Transformed = _swig_new_instance_method(_gp.gp_Elips2d_Transformed)
    Translate = _swig_new_instance_method(_gp.gp_Elips2d_Translate)
    Translated = _swig_new_instance_method(_gp.gp_Elips2d_Translated)
    XAxis = _swig_new_instance_method(_gp.gp_Elips2d_XAxis)
    YAxis = _swig_new_instance_method(_gp.gp_Elips2d_YAxis)

    def __init__(self, *args):
        r"""
        * Creates an indefinite ellipse.
        	:rtype: None* Creates an ellipse with the major axis, the major and the minor radius. The location of the MajorAxis is the center of the ellipse. The sense of parametrization is given by Sense. Warnings : It is possible to create an ellipse with MajorRadius = MinorRadius. Raises ConstructionError if MajorRadius < MinorRadius or MinorRadius < 0.0
        	:param MajorAxis:
        	:type MajorAxis: gp_Ax2d
        	:param MajorRadius:
        	:type MajorRadius: float
        	:param MinorRadius:
        	:type MinorRadius: float
        	:param Sense: default value is Standard_True
        	:type Sense: bool
        	:rtype: None* Creates an ellipse with radii MajorRadius and MinorRadius, positioned in the plane by coordinate system A where: - the origin of A is the center of the ellipse, - the 'X Direction' of A defines the major axis of the ellipse, that is, the major radius MajorRadius is measured along this axis, and - the 'Y Direction' of A defines the minor axis of the ellipse, that is, the minor radius MinorRadius is measured along this axis, and - the orientation (direct or indirect sense) of A gives the orientation of the ellipse. Warnings : It is possible to create an ellipse with MajorRadius = MinorRadius. Raises ConstructionError if MajorRadius < MinorRadius or MinorRadius < 0.0
        	:param A:
        	:type A: gp_Ax22d
        	:param MajorRadius:
        	:type MajorRadius: float
        	:param MinorRadius:
        	:type MinorRadius: float
        	:rtype: None
        """
        _gp.gp_Elips2d_swiginit(self, _gp.new_gp_Elips2d(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Elips2d

# Register gp_Elips2d in _gp:
_gp.gp_Elips2d_swigregister(gp_Elips2d)

class gp_GTrsf(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Form = _swig_new_instance_method(_gp.gp_GTrsf_Form)
    Invert = _swig_new_instance_method(_gp.gp_GTrsf_Invert)
    Inverted = _swig_new_instance_method(_gp.gp_GTrsf_Inverted)
    IsNegative = _swig_new_instance_method(_gp.gp_GTrsf_IsNegative)
    IsSingular = _swig_new_instance_method(_gp.gp_GTrsf_IsSingular)
    Multiplied = _swig_new_instance_method(_gp.gp_GTrsf_Multiplied)
    Multiply = _swig_new_instance_method(_gp.gp_GTrsf_Multiply)
    Power = _swig_new_instance_method(_gp.gp_GTrsf_Power)
    Powered = _swig_new_instance_method(_gp.gp_GTrsf_Powered)
    PreMultiply = _swig_new_instance_method(_gp.gp_GTrsf_PreMultiply)
    SetAffinity = _swig_new_instance_method(_gp.gp_GTrsf_SetAffinity)
    SetForm = _swig_new_instance_method(_gp.gp_GTrsf_SetForm)
    SetTranslationPart = _swig_new_instance_method(_gp.gp_GTrsf_SetTranslationPart)
    SetTrsf = _swig_new_instance_method(_gp.gp_GTrsf_SetTrsf)
    SetValue = _swig_new_instance_method(_gp.gp_GTrsf_SetValue)
    SetVectorialPart = _swig_new_instance_method(_gp.gp_GTrsf_SetVectorialPart)
    Transforms = _swig_new_instance_method(_gp.gp_GTrsf_Transforms)
    TranslationPart = _swig_new_instance_method(_gp.gp_GTrsf_TranslationPart)
    Trsf = _swig_new_instance_method(_gp.gp_GTrsf_Trsf)
    Value = _swig_new_instance_method(_gp.gp_GTrsf_Value)
    VectorialPart = _swig_new_instance_method(_gp.gp_GTrsf_VectorialPart)

    def __init__(self, *args):
        r"""
        * Returns the Identity transformation.
        	:rtype: None* Converts the gp_Trsf transformation T into a general transformation, i.e. Returns a GTrsf with the same matrix of coefficients as the Trsf T.
        	:param T:
        	:type T: gp_Trsf
        	:rtype: None* Creates a transformation based on the matrix M and the vector V where M defines the vectorial part of the transformation, and V the translation part, or
        	:param M:
        	:type M: gp_Mat
        	:param V:
        	:type V: gp_XYZ
        	:rtype: None
        """
        _gp.gp_GTrsf_swiginit(self, _gp.new_gp_GTrsf(*args))
    __mul__ = _swig_new_instance_method(_gp.gp_GTrsf___mul__)
    __imul_wrapper__ = _swig_new_instance_method(_gp.gp_GTrsf___imul_wrapper__)

    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self


    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_GTrsf

# Register gp_GTrsf in _gp:
_gp.gp_GTrsf_swigregister(gp_GTrsf)

class gp_GTrsf2d(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Form = _swig_new_instance_method(_gp.gp_GTrsf2d_Form)
    Invert = _swig_new_instance_method(_gp.gp_GTrsf2d_Invert)
    Inverted = _swig_new_instance_method(_gp.gp_GTrsf2d_Inverted)
    IsNegative = _swig_new_instance_method(_gp.gp_GTrsf2d_IsNegative)
    IsSingular = _swig_new_instance_method(_gp.gp_GTrsf2d_IsSingular)
    Multiplied = _swig_new_instance_method(_gp.gp_GTrsf2d_Multiplied)
    Multiply = _swig_new_instance_method(_gp.gp_GTrsf2d_Multiply)
    Power = _swig_new_instance_method(_gp.gp_GTrsf2d_Power)
    Powered = _swig_new_instance_method(_gp.gp_GTrsf2d_Powered)
    PreMultiply = _swig_new_instance_method(_gp.gp_GTrsf2d_PreMultiply)
    SetAffinity = _swig_new_instance_method(_gp.gp_GTrsf2d_SetAffinity)
    SetTranslationPart = _swig_new_instance_method(_gp.gp_GTrsf2d_SetTranslationPart)
    SetTrsf2d = _swig_new_instance_method(_gp.gp_GTrsf2d_SetTrsf2d)
    SetValue = _swig_new_instance_method(_gp.gp_GTrsf2d_SetValue)
    SetVectorialPart = _swig_new_instance_method(_gp.gp_GTrsf2d_SetVectorialPart)
    Transformed = _swig_new_instance_method(_gp.gp_GTrsf2d_Transformed)
    Transforms = _swig_new_instance_method(_gp.gp_GTrsf2d_Transforms)
    TranslationPart = _swig_new_instance_method(_gp.gp_GTrsf2d_TranslationPart)
    Trsf2d = _swig_new_instance_method(_gp.gp_GTrsf2d_Trsf2d)
    Value = _swig_new_instance_method(_gp.gp_GTrsf2d_Value)
    VectorialPart = _swig_new_instance_method(_gp.gp_GTrsf2d_VectorialPart)

    def __init__(self, *args):
        r"""
        * returns identity transformation.
        	:rtype: None* Converts the gp_Trsf2d transformation T into a general transformation.
        	:param T:
        	:type T: gp_Trsf2d
        	:rtype: None* Creates a transformation based on the matrix M and the vector V where M defines the vectorial part of the transformation, and V the translation part.
        	:param M:
        	:type M: gp_Mat2d
        	:param V:
        	:type V: gp_XY
        	:rtype: None
        """
        _gp.gp_GTrsf2d_swiginit(self, _gp.new_gp_GTrsf2d(*args))
    __mul__ = _swig_new_instance_method(_gp.gp_GTrsf2d___mul__)
    __imul_wrapper__ = _swig_new_instance_method(_gp.gp_GTrsf2d___imul_wrapper__)

    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self


    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_GTrsf2d

# Register gp_GTrsf2d in _gp:
_gp.gp_GTrsf2d_swigregister(gp_GTrsf2d)

class gp_Hypr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Asymptote1 = _swig_new_instance_method(_gp.gp_Hypr_Asymptote1)
    Asymptote2 = _swig_new_instance_method(_gp.gp_Hypr_Asymptote2)
    Axis = _swig_new_instance_method(_gp.gp_Hypr_Axis)
    ConjugateBranch1 = _swig_new_instance_method(_gp.gp_Hypr_ConjugateBranch1)
    ConjugateBranch2 = _swig_new_instance_method(_gp.gp_Hypr_ConjugateBranch2)
    Directrix1 = _swig_new_instance_method(_gp.gp_Hypr_Directrix1)
    Directrix2 = _swig_new_instance_method(_gp.gp_Hypr_Directrix2)
    Eccentricity = _swig_new_instance_method(_gp.gp_Hypr_Eccentricity)
    Focal = _swig_new_instance_method(_gp.gp_Hypr_Focal)
    Focus1 = _swig_new_instance_method(_gp.gp_Hypr_Focus1)
    Focus2 = _swig_new_instance_method(_gp.gp_Hypr_Focus2)
    Location = _swig_new_instance_method(_gp.gp_Hypr_Location)
    MajorRadius = _swig_new_instance_method(_gp.gp_Hypr_MajorRadius)
    MinorRadius = _swig_new_instance_method(_gp.gp_Hypr_MinorRadius)
    Mirror = _swig_new_instance_method(_gp.gp_Hypr_Mirror)
    Mirrored = _swig_new_instance_method(_gp.gp_Hypr_Mirrored)
    OtherBranch = _swig_new_instance_method(_gp.gp_Hypr_OtherBranch)
    Parameter = _swig_new_instance_method(_gp.gp_Hypr_Parameter)
    Position = _swig_new_instance_method(_gp.gp_Hypr_Position)
    Rotate = _swig_new_instance_method(_gp.gp_Hypr_Rotate)
    Rotated = _swig_new_instance_method(_gp.gp_Hypr_Rotated)
    Scale = _swig_new_instance_method(_gp.gp_Hypr_Scale)
    Scaled = _swig_new_instance_method(_gp.gp_Hypr_Scaled)
    SetAxis = _swig_new_instance_method(_gp.gp_Hypr_SetAxis)
    SetLocation = _swig_new_instance_method(_gp.gp_Hypr_SetLocation)
    SetMajorRadius = _swig_new_instance_method(_gp.gp_Hypr_SetMajorRadius)
    SetMinorRadius = _swig_new_instance_method(_gp.gp_Hypr_SetMinorRadius)
    SetPosition = _swig_new_instance_method(_gp.gp_Hypr_SetPosition)
    Transform = _swig_new_instance_method(_gp.gp_Hypr_Transform)
    Transformed = _swig_new_instance_method(_gp.gp_Hypr_Transformed)
    Translate = _swig_new_instance_method(_gp.gp_Hypr_Translate)
    Translated = _swig_new_instance_method(_gp.gp_Hypr_Translated)
    XAxis = _swig_new_instance_method(_gp.gp_Hypr_XAxis)
    YAxis = _swig_new_instance_method(_gp.gp_Hypr_YAxis)

    def __init__(self, *args):
        r"""
        * Creates of an indefinite hyperbola.
        	:rtype: None* Creates a hyperbola with radii MajorRadius and MinorRadius, positioned in the space by the coordinate system A2 such that: - the origin of A2 is the center of the hyperbola, - the 'X Direction' of A2 defines the major axis of the hyperbola, that is, the major radius MajorRadius is measured along this axis, and - the 'Y Direction' of A2 defines the minor axis of the hyperbola, that is, the minor radius MinorRadius is measured along this axis. Note: This class does not prevent the creation of a hyperbola where: - MajorAxis is equal to MinorAxis, or - MajorAxis is less than MinorAxis. Exceptions Standard_ConstructionError if MajorAxis or MinorAxis is negative. Raises ConstructionError if MajorRadius < 0.0 or MinorRadius < 0.0 Raised if MajorRadius < 0.0 or MinorRadius < 0.0
        	:param A2:
        	:type A2: gp_Ax2
        	:param MajorRadius:
        	:type MajorRadius: float
        	:param MinorRadius:
        	:type MinorRadius: float
        	:rtype: None
        """
        _gp.gp_Hypr_swiginit(self, _gp.new_gp_Hypr(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Hypr

# Register gp_Hypr in _gp:
_gp.gp_Hypr_swigregister(gp_Hypr)

class gp_Hypr2d(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Asymptote1 = _swig_new_instance_method(_gp.gp_Hypr2d_Asymptote1)
    Asymptote2 = _swig_new_instance_method(_gp.gp_Hypr2d_Asymptote2)
    Axis = _swig_new_instance_method(_gp.gp_Hypr2d_Axis)
    Coefficients = _swig_new_instance_method(_gp.gp_Hypr2d_Coefficients)
    ConjugateBranch1 = _swig_new_instance_method(_gp.gp_Hypr2d_ConjugateBranch1)
    ConjugateBranch2 = _swig_new_instance_method(_gp.gp_Hypr2d_ConjugateBranch2)
    Directrix1 = _swig_new_instance_method(_gp.gp_Hypr2d_Directrix1)
    Directrix2 = _swig_new_instance_method(_gp.gp_Hypr2d_Directrix2)
    Eccentricity = _swig_new_instance_method(_gp.gp_Hypr2d_Eccentricity)
    Focal = _swig_new_instance_method(_gp.gp_Hypr2d_Focal)
    Focus1 = _swig_new_instance_method(_gp.gp_Hypr2d_Focus1)
    Focus2 = _swig_new_instance_method(_gp.gp_Hypr2d_Focus2)
    IsDirect = _swig_new_instance_method(_gp.gp_Hypr2d_IsDirect)
    Location = _swig_new_instance_method(_gp.gp_Hypr2d_Location)
    MajorRadius = _swig_new_instance_method(_gp.gp_Hypr2d_MajorRadius)
    MinorRadius = _swig_new_instance_method(_gp.gp_Hypr2d_MinorRadius)
    Mirror = _swig_new_instance_method(_gp.gp_Hypr2d_Mirror)
    Mirrored = _swig_new_instance_method(_gp.gp_Hypr2d_Mirrored)
    OtherBranch = _swig_new_instance_method(_gp.gp_Hypr2d_OtherBranch)
    Parameter = _swig_new_instance_method(_gp.gp_Hypr2d_Parameter)
    Reverse = _swig_new_instance_method(_gp.gp_Hypr2d_Reverse)
    Reversed = _swig_new_instance_method(_gp.gp_Hypr2d_Reversed)
    Rotate = _swig_new_instance_method(_gp.gp_Hypr2d_Rotate)
    Rotated = _swig_new_instance_method(_gp.gp_Hypr2d_Rotated)
    Scale = _swig_new_instance_method(_gp.gp_Hypr2d_Scale)
    Scaled = _swig_new_instance_method(_gp.gp_Hypr2d_Scaled)
    SetAxis = _swig_new_instance_method(_gp.gp_Hypr2d_SetAxis)
    SetLocation = _swig_new_instance_method(_gp.gp_Hypr2d_SetLocation)
    SetMajorRadius = _swig_new_instance_method(_gp.gp_Hypr2d_SetMajorRadius)
    SetMinorRadius = _swig_new_instance_method(_gp.gp_Hypr2d_SetMinorRadius)
    SetXAxis = _swig_new_instance_method(_gp.gp_Hypr2d_SetXAxis)
    SetYAxis = _swig_new_instance_method(_gp.gp_Hypr2d_SetYAxis)
    Transform = _swig_new_instance_method(_gp.gp_Hypr2d_Transform)
    Transformed = _swig_new_instance_method(_gp.gp_Hypr2d_Transformed)
    Translate = _swig_new_instance_method(_gp.gp_Hypr2d_Translate)
    Translated = _swig_new_instance_method(_gp.gp_Hypr2d_Translated)
    XAxis = _swig_new_instance_method(_gp.gp_Hypr2d_XAxis)
    YAxis = _swig_new_instance_method(_gp.gp_Hypr2d_YAxis)

    def __init__(self, *args):
        r"""
        * Creates of an indefinite hyperbola.
        	:rtype: None* Creates a hyperbola with radii MajorRadius and MinorRadius, centered on the origin of MajorAxis and where the unit vector of MajorAxis is the 'X Direction' of the local coordinate system of the hyperbola. This coordinate system is direct if Sense is true (the default value), and indirect if Sense is false. Warnings : It is yet possible to create an Hyperbola with MajorRadius <= MinorRadius. Raises ConstructionError if MajorRadius < 0.0 or MinorRadius < 0.0
        	:param MajorAxis:
        	:type MajorAxis: gp_Ax2d
        	:param MajorRadius:
        	:type MajorRadius: float
        	:param MinorRadius:
        	:type MinorRadius: float
        	:param Sense: default value is Standard_True
        	:type Sense: bool
        	:rtype: None* a hyperbola with radii MajorRadius and MinorRadius, positioned in the plane by coordinate system A where: - the origin of A is the center of the hyperbola, - the 'X Direction' of A defines the major axis of the hyperbola, that is, the major radius MajorRadius is measured along this axis, and - the 'Y Direction' of A defines the minor axis of the hyperbola, that is, the minor radius MinorRadius is measured along this axis, and - the orientation (direct or indirect sense) of A gives the implicit orientation of the hyperbola. Warnings : It is yet possible to create an Hyperbola with MajorRadius <= MinorRadius. Raises ConstructionError if MajorRadius < 0.0 or MinorRadius < 0.0
        	:param A:
        	:type A: gp_Ax22d
        	:param MajorRadius:
        	:type MajorRadius: float
        	:param MinorRadius:
        	:type MinorRadius: float
        	:rtype: None
        """
        _gp.gp_Hypr2d_swiginit(self, _gp.new_gp_Hypr2d(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Hypr2d

# Register gp_Hypr2d in _gp:
_gp.gp_Hypr2d_swigregister(gp_Hypr2d)

class gp_Lin(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Angle = _swig_new_instance_method(_gp.gp_Lin_Angle)
    Contains = _swig_new_instance_method(_gp.gp_Lin_Contains)
    Direction = _swig_new_instance_method(_gp.gp_Lin_Direction)
    Distance = _swig_new_instance_method(_gp.gp_Lin_Distance)
    Location = _swig_new_instance_method(_gp.gp_Lin_Location)
    Mirror = _swig_new_instance_method(_gp.gp_Lin_Mirror)
    Mirrored = _swig_new_instance_method(_gp.gp_Lin_Mirrored)
    Normal = _swig_new_instance_method(_gp.gp_Lin_Normal)
    Position = _swig_new_instance_method(_gp.gp_Lin_Position)
    Reverse = _swig_new_instance_method(_gp.gp_Lin_Reverse)
    Reversed = _swig_new_instance_method(_gp.gp_Lin_Reversed)
    Rotate = _swig_new_instance_method(_gp.gp_Lin_Rotate)
    Rotated = _swig_new_instance_method(_gp.gp_Lin_Rotated)
    Scale = _swig_new_instance_method(_gp.gp_Lin_Scale)
    Scaled = _swig_new_instance_method(_gp.gp_Lin_Scaled)
    SetDirection = _swig_new_instance_method(_gp.gp_Lin_SetDirection)
    SetLocation = _swig_new_instance_method(_gp.gp_Lin_SetLocation)
    SetPosition = _swig_new_instance_method(_gp.gp_Lin_SetPosition)
    SquareDistance = _swig_new_instance_method(_gp.gp_Lin_SquareDistance)
    Transform = _swig_new_instance_method(_gp.gp_Lin_Transform)
    Transformed = _swig_new_instance_method(_gp.gp_Lin_Transformed)
    Translate = _swig_new_instance_method(_gp.gp_Lin_Translate)
    Translated = _swig_new_instance_method(_gp.gp_Lin_Translated)

    def __init__(self, *args):
        r"""
        * Creates a Line corresponding to Z axis of the reference coordinate system.
        	:rtype: None* Creates a line defined by axis A1.
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: None* Creates a line passing through point P and parallel to vector V (P and V are, respectively, the origin and the unit vector of the positioning axis of the line).
        	:param P:
        	:type P: gp_Pnt
        	:param V:
        	:type V: gp_Dir
        	:rtype: None
        """
        _gp.gp_Lin_swiginit(self, _gp.new_gp_Lin(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Lin

# Register gp_Lin in _gp:
_gp.gp_Lin_swigregister(gp_Lin)

class gp_Lin2d(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Angle = _swig_new_instance_method(_gp.gp_Lin2d_Angle)
    Coefficients = _swig_new_instance_method(_gp.gp_Lin2d_Coefficients)
    Contains = _swig_new_instance_method(_gp.gp_Lin2d_Contains)
    Direction = _swig_new_instance_method(_gp.gp_Lin2d_Direction)
    Distance = _swig_new_instance_method(_gp.gp_Lin2d_Distance)
    Location = _swig_new_instance_method(_gp.gp_Lin2d_Location)
    Mirror = _swig_new_instance_method(_gp.gp_Lin2d_Mirror)
    Mirrored = _swig_new_instance_method(_gp.gp_Lin2d_Mirrored)
    Normal = _swig_new_instance_method(_gp.gp_Lin2d_Normal)
    Position = _swig_new_instance_method(_gp.gp_Lin2d_Position)
    Reverse = _swig_new_instance_method(_gp.gp_Lin2d_Reverse)
    Reversed = _swig_new_instance_method(_gp.gp_Lin2d_Reversed)
    Rotate = _swig_new_instance_method(_gp.gp_Lin2d_Rotate)
    Rotated = _swig_new_instance_method(_gp.gp_Lin2d_Rotated)
    Scale = _swig_new_instance_method(_gp.gp_Lin2d_Scale)
    Scaled = _swig_new_instance_method(_gp.gp_Lin2d_Scaled)
    SetDirection = _swig_new_instance_method(_gp.gp_Lin2d_SetDirection)
    SetLocation = _swig_new_instance_method(_gp.gp_Lin2d_SetLocation)
    SetPosition = _swig_new_instance_method(_gp.gp_Lin2d_SetPosition)
    SquareDistance = _swig_new_instance_method(_gp.gp_Lin2d_SquareDistance)
    Transform = _swig_new_instance_method(_gp.gp_Lin2d_Transform)
    Transformed = _swig_new_instance_method(_gp.gp_Lin2d_Transformed)
    Translate = _swig_new_instance_method(_gp.gp_Lin2d_Translate)
    Translated = _swig_new_instance_method(_gp.gp_Lin2d_Translated)

    def __init__(self, *args):
        r"""
        * Creates a Line corresponding to X axis of the reference coordinate system.
        	:rtype: None* Creates a line located with A.
        	:param A:
        	:type A: gp_Ax2d
        	:rtype: None* <P> is the location point (origin) of the line and <V> is the direction of the line.
        	:param P:
        	:type P: gp_Pnt2d
        	:param V:
        	:type V: gp_Dir2d
        	:rtype: None* Creates the line from the equation A*X + B*Y + C = 0.0 Raises ConstructionError if Sqrt(A*A + B*B) <= Resolution from gp. Raised if Sqrt(A*A + B*B) <= Resolution from gp.
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param C:
        	:type C: float
        	:rtype: None
        """
        _gp.gp_Lin2d_swiginit(self, _gp.new_gp_Lin2d(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Lin2d

# Register gp_Lin2d in _gp:
_gp.gp_Lin2d_swigregister(gp_Lin2d)

class gp_Mat(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Add = _swig_new_instance_method(_gp.gp_Mat_Add)
    Added = _swig_new_instance_method(_gp.gp_Mat_Added)
    GetChangeValue = _swig_new_instance_method(_gp.gp_Mat_GetChangeValue)
    SetChangeValue = _swig_new_instance_method(_gp.gp_Mat_SetChangeValue)
    Column = _swig_new_instance_method(_gp.gp_Mat_Column)
    Determinant = _swig_new_instance_method(_gp.gp_Mat_Determinant)
    Diagonal = _swig_new_instance_method(_gp.gp_Mat_Diagonal)
    Divide = _swig_new_instance_method(_gp.gp_Mat_Divide)
    Divided = _swig_new_instance_method(_gp.gp_Mat_Divided)
    DumpJsonToString = _swig_new_instance_method(_gp.gp_Mat_DumpJsonToString)
    Invert = _swig_new_instance_method(_gp.gp_Mat_Invert)
    Inverted = _swig_new_instance_method(_gp.gp_Mat_Inverted)
    IsSingular = _swig_new_instance_method(_gp.gp_Mat_IsSingular)
    Multiplied = _swig_new_instance_method(_gp.gp_Mat_Multiplied)
    Multiply = _swig_new_instance_method(_gp.gp_Mat_Multiply)
    Power = _swig_new_instance_method(_gp.gp_Mat_Power)
    Powered = _swig_new_instance_method(_gp.gp_Mat_Powered)
    PreMultiply = _swig_new_instance_method(_gp.gp_Mat_PreMultiply)
    Row = _swig_new_instance_method(_gp.gp_Mat_Row)
    SetCol = _swig_new_instance_method(_gp.gp_Mat_SetCol)
    SetCols = _swig_new_instance_method(_gp.gp_Mat_SetCols)
    SetCross = _swig_new_instance_method(_gp.gp_Mat_SetCross)
    SetDiagonal = _swig_new_instance_method(_gp.gp_Mat_SetDiagonal)
    SetDot = _swig_new_instance_method(_gp.gp_Mat_SetDot)
    SetIdentity = _swig_new_instance_method(_gp.gp_Mat_SetIdentity)
    SetRotation = _swig_new_instance_method(_gp.gp_Mat_SetRotation)
    SetRow = _swig_new_instance_method(_gp.gp_Mat_SetRow)
    SetRows = _swig_new_instance_method(_gp.gp_Mat_SetRows)
    SetScale = _swig_new_instance_method(_gp.gp_Mat_SetScale)
    SetValue = _swig_new_instance_method(_gp.gp_Mat_SetValue)
    Subtract = _swig_new_instance_method(_gp.gp_Mat_Subtract)
    Subtracted = _swig_new_instance_method(_gp.gp_Mat_Subtracted)
    Transpose = _swig_new_instance_method(_gp.gp_Mat_Transpose)
    Transposed = _swig_new_instance_method(_gp.gp_Mat_Transposed)
    Value = _swig_new_instance_method(_gp.gp_Mat_Value)

    def __init__(self, *args):
        r"""
        * creates a matrix with null coefficients.
        	:rtype: None:param a11:
        	:type a11: float
        	:param a12:
        	:type a12: float
        	:param a13:
        	:type a13: float
        	:param a21:
        	:type a21: float
        	:param a22:
        	:type a22: float
        	:param a23:
        	:type a23: float
        	:param a31:
        	:type a31: float
        	:param a32:
        	:type a32: float
        	:param a33:
        	:type a33: float
        	:rtype: None* Creates a matrix. Col1, Col2, Col3 are the 3 columns of the matrix.
        	:param Col1:
        	:type Col1: gp_XYZ
        	:param Col2:
        	:type Col2: gp_XYZ
        	:param Col3:
        	:type Col3: gp_XYZ
        	:rtype: None
        """
        _gp.gp_Mat_swiginit(self, _gp.new_gp_Mat(*args))
    __mul__ = _swig_new_instance_method(_gp.gp_Mat___mul__)

    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self

    __imul_wrapper__ = _swig_new_instance_method(_gp.gp_Mat___imul_wrapper__)

    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self

    __add__ = _swig_new_instance_method(_gp.gp_Mat___add__)
    __iadd_wrapper__ = _swig_new_instance_method(_gp.gp_Mat___iadd_wrapper__)

    def __iadd__(self, right):
        self.__iadd_wrapper__(right)
        return self

    __sub__ = _swig_new_instance_method(_gp.gp_Mat___sub__)
    __isub_wrapper__ = _swig_new_instance_method(_gp.gp_Mat___isub_wrapper__)

    def __isub__(self, right):
        self.__isub_wrapper__(right)
        return self


    def __truediv__(self, *args):
        return _gp.gp_Mat___truediv__(self, *args)
    __div__ = __truediv__


    __itruediv_wrapper__ = _swig_new_instance_method(_gp.gp_Mat___itruediv_wrapper__)

    def __itruediv__(self, right):
        self.__itruediv_wrapper__(right)
        return self


    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Mat

# Register gp_Mat in _gp:
_gp.gp_Mat_swigregister(gp_Mat)

class gp_Mat2d(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Add = _swig_new_instance_method(_gp.gp_Mat2d_Add)
    Added = _swig_new_instance_method(_gp.gp_Mat2d_Added)
    GetChangeValue = _swig_new_instance_method(_gp.gp_Mat2d_GetChangeValue)
    SetChangeValue = _swig_new_instance_method(_gp.gp_Mat2d_SetChangeValue)
    Column = _swig_new_instance_method(_gp.gp_Mat2d_Column)
    Determinant = _swig_new_instance_method(_gp.gp_Mat2d_Determinant)
    Diagonal = _swig_new_instance_method(_gp.gp_Mat2d_Diagonal)
    Divide = _swig_new_instance_method(_gp.gp_Mat2d_Divide)
    Divided = _swig_new_instance_method(_gp.gp_Mat2d_Divided)
    Invert = _swig_new_instance_method(_gp.gp_Mat2d_Invert)
    Inverted = _swig_new_instance_method(_gp.gp_Mat2d_Inverted)
    IsSingular = _swig_new_instance_method(_gp.gp_Mat2d_IsSingular)
    Multiplied = _swig_new_instance_method(_gp.gp_Mat2d_Multiplied)
    Multiply = _swig_new_instance_method(_gp.gp_Mat2d_Multiply)
    Power = _swig_new_instance_method(_gp.gp_Mat2d_Power)
    Powered = _swig_new_instance_method(_gp.gp_Mat2d_Powered)
    PreMultiply = _swig_new_instance_method(_gp.gp_Mat2d_PreMultiply)
    Row = _swig_new_instance_method(_gp.gp_Mat2d_Row)
    SetCol = _swig_new_instance_method(_gp.gp_Mat2d_SetCol)
    SetCols = _swig_new_instance_method(_gp.gp_Mat2d_SetCols)
    SetDiagonal = _swig_new_instance_method(_gp.gp_Mat2d_SetDiagonal)
    SetIdentity = _swig_new_instance_method(_gp.gp_Mat2d_SetIdentity)
    SetRotation = _swig_new_instance_method(_gp.gp_Mat2d_SetRotation)
    SetRow = _swig_new_instance_method(_gp.gp_Mat2d_SetRow)
    SetRows = _swig_new_instance_method(_gp.gp_Mat2d_SetRows)
    SetScale = _swig_new_instance_method(_gp.gp_Mat2d_SetScale)
    SetValue = _swig_new_instance_method(_gp.gp_Mat2d_SetValue)
    Subtract = _swig_new_instance_method(_gp.gp_Mat2d_Subtract)
    Subtracted = _swig_new_instance_method(_gp.gp_Mat2d_Subtracted)
    Transpose = _swig_new_instance_method(_gp.gp_Mat2d_Transpose)
    Transposed = _swig_new_instance_method(_gp.gp_Mat2d_Transposed)
    Value = _swig_new_instance_method(_gp.gp_Mat2d_Value)

    def __init__(self, *args):
        r"""
        * Creates a matrix with null coefficients.
        	:rtype: None* Col1, Col2 are the 2 columns of the matrix.
        	:param Col1:
        	:type Col1: gp_XY
        	:param Col2:
        	:type Col2: gp_XY
        	:rtype: None
        """
        _gp.gp_Mat2d_swiginit(self, _gp.new_gp_Mat2d(*args))
    __mul__ = _swig_new_instance_method(_gp.gp_Mat2d___mul__)
    __imul_wrapper__ = _swig_new_instance_method(_gp.gp_Mat2d___imul_wrapper__)

    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self

    __add__ = _swig_new_instance_method(_gp.gp_Mat2d___add__)
    __iadd_wrapper__ = _swig_new_instance_method(_gp.gp_Mat2d___iadd_wrapper__)

    def __iadd__(self, right):
        self.__iadd_wrapper__(right)
        return self

    __sub__ = _swig_new_instance_method(_gp.gp_Mat2d___sub__)
    __isub_wrapper__ = _swig_new_instance_method(_gp.gp_Mat2d___isub_wrapper__)

    def __isub__(self, right):
        self.__isub_wrapper__(right)
        return self


    def __truediv__(self, *args):
        return _gp.gp_Mat2d___truediv__(self, *args)
    __div__ = __truediv__


    __itruediv_wrapper__ = _swig_new_instance_method(_gp.gp_Mat2d___itruediv_wrapper__)

    def __itruediv__(self, right):
        self.__itruediv_wrapper__(right)
        return self


    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Mat2d

# Register gp_Mat2d in _gp:
_gp.gp_Mat2d_swigregister(gp_Mat2d)

class gp_Parab(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Axis = _swig_new_instance_method(_gp.gp_Parab_Axis)
    Directrix = _swig_new_instance_method(_gp.gp_Parab_Directrix)
    Focal = _swig_new_instance_method(_gp.gp_Parab_Focal)
    Focus = _swig_new_instance_method(_gp.gp_Parab_Focus)
    Location = _swig_new_instance_method(_gp.gp_Parab_Location)
    Mirror = _swig_new_instance_method(_gp.gp_Parab_Mirror)
    Mirrored = _swig_new_instance_method(_gp.gp_Parab_Mirrored)
    Parameter = _swig_new_instance_method(_gp.gp_Parab_Parameter)
    Position = _swig_new_instance_method(_gp.gp_Parab_Position)
    Rotate = _swig_new_instance_method(_gp.gp_Parab_Rotate)
    Rotated = _swig_new_instance_method(_gp.gp_Parab_Rotated)
    Scale = _swig_new_instance_method(_gp.gp_Parab_Scale)
    Scaled = _swig_new_instance_method(_gp.gp_Parab_Scaled)
    SetAxis = _swig_new_instance_method(_gp.gp_Parab_SetAxis)
    SetFocal = _swig_new_instance_method(_gp.gp_Parab_SetFocal)
    SetLocation = _swig_new_instance_method(_gp.gp_Parab_SetLocation)
    SetPosition = _swig_new_instance_method(_gp.gp_Parab_SetPosition)
    Transform = _swig_new_instance_method(_gp.gp_Parab_Transform)
    Transformed = _swig_new_instance_method(_gp.gp_Parab_Transformed)
    Translate = _swig_new_instance_method(_gp.gp_Parab_Translate)
    Translated = _swig_new_instance_method(_gp.gp_Parab_Translated)
    XAxis = _swig_new_instance_method(_gp.gp_Parab_XAxis)
    YAxis = _swig_new_instance_method(_gp.gp_Parab_YAxis)

    def __init__(self, *args):
        r"""
        * Creates an indefinite Parabola.
        	:rtype: None* Creates a parabola with its local coordinate system 'A2' and it's focal length 'Focal'. The XDirection of A2 defines the axis of symmetry of the parabola. The YDirection of A2 is parallel to the directrix of the parabola. The Location point of A2 is the vertex of the parabola Raises ConstructionError if Focal < 0.0 Raised if Focal < 0.0
        	:param A2:
        	:type A2: gp_Ax2
        	:param Focal:
        	:type Focal: float
        	:rtype: None* D is the directrix of the parabola and F the focus point. The symmetry axis (XAxis) of the parabola is normal to the directrix and pass through the focus point F, but its location point is the vertex of the parabola. The YAxis of the parabola is parallel to D and its location point is the vertex of the parabola. The normal to the plane of the parabola is the cross product between the XAxis and the YAxis.
        	:param D:
        	:type D: gp_Ax1
        	:param F:
        	:type F: gp_Pnt
        	:rtype: None
        """
        _gp.gp_Parab_swiginit(self, _gp.new_gp_Parab(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Parab

# Register gp_Parab in _gp:
_gp.gp_Parab_swigregister(gp_Parab)

class gp_Parab2d(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Axis = _swig_new_instance_method(_gp.gp_Parab2d_Axis)
    Coefficients = _swig_new_instance_method(_gp.gp_Parab2d_Coefficients)
    Directrix = _swig_new_instance_method(_gp.gp_Parab2d_Directrix)
    Focal = _swig_new_instance_method(_gp.gp_Parab2d_Focal)
    Focus = _swig_new_instance_method(_gp.gp_Parab2d_Focus)
    IsDirect = _swig_new_instance_method(_gp.gp_Parab2d_IsDirect)
    Location = _swig_new_instance_method(_gp.gp_Parab2d_Location)
    Mirror = _swig_new_instance_method(_gp.gp_Parab2d_Mirror)
    MirrorAxis = _swig_new_instance_method(_gp.gp_Parab2d_MirrorAxis)
    Mirrored = _swig_new_instance_method(_gp.gp_Parab2d_Mirrored)
    Parameter = _swig_new_instance_method(_gp.gp_Parab2d_Parameter)
    Reverse = _swig_new_instance_method(_gp.gp_Parab2d_Reverse)
    Reversed = _swig_new_instance_method(_gp.gp_Parab2d_Reversed)
    Rotate = _swig_new_instance_method(_gp.gp_Parab2d_Rotate)
    Rotated = _swig_new_instance_method(_gp.gp_Parab2d_Rotated)
    Scale = _swig_new_instance_method(_gp.gp_Parab2d_Scale)
    Scaled = _swig_new_instance_method(_gp.gp_Parab2d_Scaled)
    SetAxis = _swig_new_instance_method(_gp.gp_Parab2d_SetAxis)
    SetFocal = _swig_new_instance_method(_gp.gp_Parab2d_SetFocal)
    SetLocation = _swig_new_instance_method(_gp.gp_Parab2d_SetLocation)
    SetMirrorAxis = _swig_new_instance_method(_gp.gp_Parab2d_SetMirrorAxis)
    Transform = _swig_new_instance_method(_gp.gp_Parab2d_Transform)
    Transformed = _swig_new_instance_method(_gp.gp_Parab2d_Transformed)
    Translate = _swig_new_instance_method(_gp.gp_Parab2d_Translate)
    Translated = _swig_new_instance_method(_gp.gp_Parab2d_Translated)

    def __init__(self, *args):
        r"""
        * Creates an indefinite parabola.
        	:rtype: None* Creates a parabola with its vertex point, its axis of symmetry ('XAxis') and its focal length. The sense of parametrization is given by theSense. If theSense == True (by default) then right-handed coordinate system is used, otherwise - left-handed. Warnings : It is possible to have FocalLength = 0. In this case, the parabola looks like a line, which is parallel to the symmetry-axis. Raises ConstructionError if FocalLength < 0.0
        	:param theMirrorAxis:
        	:type theMirrorAxis: gp_Ax2d
        	:param theFocalLength:
        	:type theFocalLength: float
        	:param theSense: default value is Standard_True
        	:type theSense: bool
        	:rtype: None* Creates a parabola with its vertex point, its axis of symmetry ('XAxis'), correspond Y-axis and its focal length. Warnings : It is possible to have FocalLength = 0. In this case, the parabola looks like a line, which is parallel to the symmetry-axis. Raises ConstructionError if Focal < 0.0
        	:param theAxes:
        	:type theAxes: gp_Ax22d
        	:param theFocalLength:
        	:type theFocalLength: float
        	:rtype: None* Creates a parabola with the directrix and the focus point. Y-axis of the parabola (in User Coordinate System - UCS) is the direction of theDirectrix. X-axis always directs from theDirectrix to theFocus point and always comes through theFocus. Apex of the parabola is a middle point between the theFocus and the intersection point of theDirectrix and the X-axis. Warnings : It is possible to have FocalLength = 0 (when theFocus lies in theDirectrix). In this case, X-direction of the parabola is defined by theSense parameter. If theSense == True (by default) then right-handed coordinate system is used, otherwise - left-handed. Result parabola will look like a line, which is perpendicular to the directrix.
        	:param theDirectrix:
        	:type theDirectrix: gp_Ax2d
        	:param theFocus:
        	:type theFocus: gp_Pnt2d
        	:param theSense: default value is Standard_True
        	:type theSense: bool
        	:rtype: None
        """
        _gp.gp_Parab2d_swiginit(self, _gp.new_gp_Parab2d(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Parab2d

# Register gp_Parab2d in _gp:
_gp.gp_Parab2d_swigregister(gp_Parab2d)

class gp_Pln(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Axis = _swig_new_instance_method(_gp.gp_Pln_Axis)
    Coefficients = _swig_new_instance_method(_gp.gp_Pln_Coefficients)
    Contains = _swig_new_instance_method(_gp.gp_Pln_Contains)
    Direct = _swig_new_instance_method(_gp.gp_Pln_Direct)
    Distance = _swig_new_instance_method(_gp.gp_Pln_Distance)
    Location = _swig_new_instance_method(_gp.gp_Pln_Location)
    Mirror = _swig_new_instance_method(_gp.gp_Pln_Mirror)
    Mirrored = _swig_new_instance_method(_gp.gp_Pln_Mirrored)
    Position = _swig_new_instance_method(_gp.gp_Pln_Position)
    Rotate = _swig_new_instance_method(_gp.gp_Pln_Rotate)
    Rotated = _swig_new_instance_method(_gp.gp_Pln_Rotated)
    Scale = _swig_new_instance_method(_gp.gp_Pln_Scale)
    Scaled = _swig_new_instance_method(_gp.gp_Pln_Scaled)
    SetAxis = _swig_new_instance_method(_gp.gp_Pln_SetAxis)
    SetLocation = _swig_new_instance_method(_gp.gp_Pln_SetLocation)
    SetPosition = _swig_new_instance_method(_gp.gp_Pln_SetPosition)
    SquareDistance = _swig_new_instance_method(_gp.gp_Pln_SquareDistance)
    Transform = _swig_new_instance_method(_gp.gp_Pln_Transform)
    Transformed = _swig_new_instance_method(_gp.gp_Pln_Transformed)
    Translate = _swig_new_instance_method(_gp.gp_Pln_Translate)
    Translated = _swig_new_instance_method(_gp.gp_Pln_Translated)
    UReverse = _swig_new_instance_method(_gp.gp_Pln_UReverse)
    VReverse = _swig_new_instance_method(_gp.gp_Pln_VReverse)
    XAxis = _swig_new_instance_method(_gp.gp_Pln_XAxis)
    YAxis = _swig_new_instance_method(_gp.gp_Pln_YAxis)

    def __init__(self, *args):
        r"""
        * Creates a plane coincident with OXY plane of the reference coordinate system.
        	:rtype: None* The coordinate system of the plane is defined with the axis placement A3. The 'Direction' of A3 defines the normal to the plane. The 'Location' of A3 defines the location (origin) of the plane. The 'XDirection' and 'YDirection' of A3 define the 'XAxis' and the 'YAxis' of the plane used to parametrize the plane.
        	:param A3:
        	:type A3: gp_Ax3
        	:rtype: None* Creates a plane with the 'Location' point <P> and the normal direction <V>.
        	:param P:
        	:type P: gp_Pnt
        	:param V:
        	:type V: gp_Dir
        	:rtype: None* Creates a plane from its cartesian equation : A * X + B * Y + C * Z + D = 0.0 Raises ConstructionError if Sqrt (A*A + B*B + C*C) <= Resolution from gp.
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param C:
        	:type C: float
        	:param D:
        	:type D: float
        	:rtype: None
        """
        _gp.gp_Pln_swiginit(self, _gp.new_gp_Pln(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Pln

# Register gp_Pln in _gp:
_gp.gp_Pln_swigregister(gp_Pln)

class gp_Pnt(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    BaryCenter = _swig_new_instance_method(_gp.gp_Pnt_BaryCenter)
    ChangeCoord = _swig_new_instance_method(_gp.gp_Pnt_ChangeCoord)
    Coord = _swig_new_instance_method(_gp.gp_Pnt_Coord)
    Distance = _swig_new_instance_method(_gp.gp_Pnt_Distance)
    IsEqual = _swig_new_instance_method(_gp.gp_Pnt_IsEqual)
    Mirror = _swig_new_instance_method(_gp.gp_Pnt_Mirror)
    Mirrored = _swig_new_instance_method(_gp.gp_Pnt_Mirrored)
    Rotate = _swig_new_instance_method(_gp.gp_Pnt_Rotate)
    Rotated = _swig_new_instance_method(_gp.gp_Pnt_Rotated)
    Scale = _swig_new_instance_method(_gp.gp_Pnt_Scale)
    Scaled = _swig_new_instance_method(_gp.gp_Pnt_Scaled)
    SetCoord = _swig_new_instance_method(_gp.gp_Pnt_SetCoord)
    SetX = _swig_new_instance_method(_gp.gp_Pnt_SetX)
    SetXYZ = _swig_new_instance_method(_gp.gp_Pnt_SetXYZ)
    SetY = _swig_new_instance_method(_gp.gp_Pnt_SetY)
    SetZ = _swig_new_instance_method(_gp.gp_Pnt_SetZ)
    SquareDistance = _swig_new_instance_method(_gp.gp_Pnt_SquareDistance)
    Transform = _swig_new_instance_method(_gp.gp_Pnt_Transform)
    Transformed = _swig_new_instance_method(_gp.gp_Pnt_Transformed)
    Translate = _swig_new_instance_method(_gp.gp_Pnt_Translate)
    Translated = _swig_new_instance_method(_gp.gp_Pnt_Translated)
    X = _swig_new_instance_method(_gp.gp_Pnt_X)
    XYZ = _swig_new_instance_method(_gp.gp_Pnt_XYZ)
    Y = _swig_new_instance_method(_gp.gp_Pnt_Y)
    Z = _swig_new_instance_method(_gp.gp_Pnt_Z)

    def __init__(self, *args):
        r"""
        * Creates a point with zero coordinates.
        	:rtype: None* Creates a point from a XYZ object.
        	:param Coord:
        	:type Coord: gp_XYZ
        	:rtype: None* Creates a point with its 3 cartesian's coordinates : Xp, Yp, Zp.
        	:param Xp:
        	:type Xp: float
        	:param Yp:
        	:type Yp: float
        	:param Zp:
        	:type Zp: float
        	:rtype: None
        """
        _gp.gp_Pnt_swiginit(self, _gp.new_gp_Pnt(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Pnt

# Register gp_Pnt in _gp:
_gp.gp_Pnt_swigregister(gp_Pnt)

class gp_Pnt2d(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ChangeCoord = _swig_new_instance_method(_gp.gp_Pnt2d_ChangeCoord)
    Coord = _swig_new_instance_method(_gp.gp_Pnt2d_Coord)
    Distance = _swig_new_instance_method(_gp.gp_Pnt2d_Distance)
    IsEqual = _swig_new_instance_method(_gp.gp_Pnt2d_IsEqual)
    Mirror = _swig_new_instance_method(_gp.gp_Pnt2d_Mirror)
    Mirrored = _swig_new_instance_method(_gp.gp_Pnt2d_Mirrored)
    Rotate = _swig_new_instance_method(_gp.gp_Pnt2d_Rotate)
    Rotated = _swig_new_instance_method(_gp.gp_Pnt2d_Rotated)
    Scale = _swig_new_instance_method(_gp.gp_Pnt2d_Scale)
    Scaled = _swig_new_instance_method(_gp.gp_Pnt2d_Scaled)
    SetCoord = _swig_new_instance_method(_gp.gp_Pnt2d_SetCoord)
    SetX = _swig_new_instance_method(_gp.gp_Pnt2d_SetX)
    SetXY = _swig_new_instance_method(_gp.gp_Pnt2d_SetXY)
    SetY = _swig_new_instance_method(_gp.gp_Pnt2d_SetY)
    SquareDistance = _swig_new_instance_method(_gp.gp_Pnt2d_SquareDistance)
    Transform = _swig_new_instance_method(_gp.gp_Pnt2d_Transform)
    Transformed = _swig_new_instance_method(_gp.gp_Pnt2d_Transformed)
    Translate = _swig_new_instance_method(_gp.gp_Pnt2d_Translate)
    Translated = _swig_new_instance_method(_gp.gp_Pnt2d_Translated)
    X = _swig_new_instance_method(_gp.gp_Pnt2d_X)
    XY = _swig_new_instance_method(_gp.gp_Pnt2d_XY)
    Y = _swig_new_instance_method(_gp.gp_Pnt2d_Y)

    def __init__(self, *args):
        r"""
        * Creates a point with zero coordinates.
        	:rtype: None* Creates a point with a doublet of coordinates.
        	:param Coord:
        	:type Coord: gp_XY
        	:rtype: None* Creates a point with its 2 cartesian's coordinates : Xp, Yp.
        	:param Xp:
        	:type Xp: float
        	:param Yp:
        	:type Yp: float
        	:rtype: None
        """
        _gp.gp_Pnt2d_swiginit(self, _gp.new_gp_Pnt2d(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Pnt2d

# Register gp_Pnt2d in _gp:
_gp.gp_Pnt2d_swigregister(gp_Pnt2d)

class gp_Quaternion(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Add = _swig_new_instance_method(_gp.gp_Quaternion_Add)
    Added = _swig_new_instance_method(_gp.gp_Quaternion_Added)
    Dot = _swig_new_instance_method(_gp.gp_Quaternion_Dot)
    GetEulerAngles = _swig_new_instance_method(_gp.gp_Quaternion_GetEulerAngles)
    GetMatrix = _swig_new_instance_method(_gp.gp_Quaternion_GetMatrix)
    GetRotationAngle = _swig_new_instance_method(_gp.gp_Quaternion_GetRotationAngle)
    GetVectorAndAngle = _swig_new_instance_method(_gp.gp_Quaternion_GetVectorAndAngle)
    Invert = _swig_new_instance_method(_gp.gp_Quaternion_Invert)
    Inverted = _swig_new_instance_method(_gp.gp_Quaternion_Inverted)
    IsEqual = _swig_new_instance_method(_gp.gp_Quaternion_IsEqual)
    Multiplied = _swig_new_instance_method(_gp.gp_Quaternion_Multiplied)
    Multiply = _swig_new_instance_method(_gp.gp_Quaternion_Multiply)
    Negated = _swig_new_instance_method(_gp.gp_Quaternion_Negated)
    Norm = _swig_new_instance_method(_gp.gp_Quaternion_Norm)
    Normalize = _swig_new_instance_method(_gp.gp_Quaternion_Normalize)
    Normalized = _swig_new_instance_method(_gp.gp_Quaternion_Normalized)
    Reverse = _swig_new_instance_method(_gp.gp_Quaternion_Reverse)
    Reversed = _swig_new_instance_method(_gp.gp_Quaternion_Reversed)
    Scale = _swig_new_instance_method(_gp.gp_Quaternion_Scale)
    Scaled = _swig_new_instance_method(_gp.gp_Quaternion_Scaled)
    Set = _swig_new_instance_method(_gp.gp_Quaternion_Set)
    SetEulerAngles = _swig_new_instance_method(_gp.gp_Quaternion_SetEulerAngles)
    SetIdent = _swig_new_instance_method(_gp.gp_Quaternion_SetIdent)
    SetMatrix = _swig_new_instance_method(_gp.gp_Quaternion_SetMatrix)
    SetRotation = _swig_new_instance_method(_gp.gp_Quaternion_SetRotation)
    SetVectorAndAngle = _swig_new_instance_method(_gp.gp_Quaternion_SetVectorAndAngle)
    SquareNorm = _swig_new_instance_method(_gp.gp_Quaternion_SquareNorm)
    StabilizeLength = _swig_new_instance_method(_gp.gp_Quaternion_StabilizeLength)
    Subtract = _swig_new_instance_method(_gp.gp_Quaternion_Subtract)
    Subtracted = _swig_new_instance_method(_gp.gp_Quaternion_Subtracted)
    W = _swig_new_instance_method(_gp.gp_Quaternion_W)
    X = _swig_new_instance_method(_gp.gp_Quaternion_X)
    Y = _swig_new_instance_method(_gp.gp_Quaternion_Y)
    Z = _swig_new_instance_method(_gp.gp_Quaternion_Z)

    def __init__(self, *args):
        r"""
        * Creates an identity quaternion
        	:rtype: None* Creates quaternion directly from component values
        	:param x:
        	:type x: float
        	:param y:
        	:type y: float
        	:param z:
        	:type z: float
        	:param w:
        	:type w: float
        	:rtype: None* Creates copy of another quaternion
        	:param theToCopy:
        	:type theToCopy: gp_Quaternion
        	:rtype: None* Creates quaternion representing shortest-arc rotation operator producing vector theVecTo from vector theVecFrom.
        	:param theVecFrom:
        	:type theVecFrom: gp_Vec
        	:param theVecTo:
        	:type theVecTo: gp_Vec
        	:rtype: None* Creates quaternion representing shortest-arc rotation operator producing vector theVecTo from vector theVecFrom. Additional vector theHelpCrossVec defines preferred direction for rotation and is used when theVecTo and theVecFrom are directed oppositely.
        	:param theVecFrom:
        	:type theVecFrom: gp_Vec
        	:param theVecTo:
        	:type theVecTo: gp_Vec
        	:param theHelpCrossVec:
        	:type theHelpCrossVec: gp_Vec
        	:rtype: None* Creates quaternion representing rotation on angle theAngle around vector theAxis
        	:param theAxis:
        	:type theAxis: gp_Vec
        	:param theAngle:
        	:type theAngle: float
        	:rtype: None* Creates quaternion from rotation matrix 3*3 (which should be orthonormal skew-symmetric matrix)
        	:param theMat:
        	:type theMat: gp_Mat
        	:rtype: None
        """
        _gp.gp_Quaternion_swiginit(self, _gp.new_gp_Quaternion(*args))
    __mul__ = _swig_new_instance_method(_gp.gp_Quaternion___mul__)

    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self

    __imul_wrapper__ = _swig_new_instance_method(_gp.gp_Quaternion___imul_wrapper__)

    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self

    __add__ = _swig_new_instance_method(_gp.gp_Quaternion___add__)
    __iadd_wrapper__ = _swig_new_instance_method(_gp.gp_Quaternion___iadd_wrapper__)

    def __iadd__(self, right):
        self.__iadd_wrapper__(right)
        return self

    __neg__ = _swig_new_instance_method(_gp.gp_Quaternion___neg__)
    __sub__ = _swig_new_instance_method(_gp.gp_Quaternion___sub__)
    __isub_wrapper__ = _swig_new_instance_method(_gp.gp_Quaternion___isub_wrapper__)

    def __isub__(self, right):
        self.__isub_wrapper__(right)
        return self


    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Quaternion

# Register gp_Quaternion in _gp:
_gp.gp_Quaternion_swigregister(gp_Quaternion)

class gp_QuaternionNLerp(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Init = _swig_new_instance_method(_gp.gp_QuaternionNLerp_Init)
    InitFromUnit = _swig_new_instance_method(_gp.gp_QuaternionNLerp_InitFromUnit)
    Interpolate = _swig_new_instance_method(_gp.gp_QuaternionNLerp_Interpolate)

    def __init__(self, *args):
        r"""
        * Empty constructor,
        	:rtype: None* Constructor with initialization.
        	:param theQStart:
        	:type theQStart: gp_Quaternion
        	:param theQEnd:
        	:type theQEnd: gp_Quaternion
        	:rtype: None
        """
        _gp.gp_QuaternionNLerp_swiginit(self, _gp.new_gp_QuaternionNLerp(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_QuaternionNLerp

# Register gp_QuaternionNLerp in _gp:
_gp.gp_QuaternionNLerp_swigregister(gp_QuaternionNLerp)

class gp_QuaternionSLerp(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Init = _swig_new_instance_method(_gp.gp_QuaternionSLerp_Init)
    InitFromUnit = _swig_new_instance_method(_gp.gp_QuaternionSLerp_InitFromUnit)
    Interpolate = _swig_new_instance_method(_gp.gp_QuaternionSLerp_Interpolate)

    def __init__(self, *args):
        r"""
        * Empty constructor,
        	:rtype: None* Constructor with initialization.
        	:param theQStart:
        	:type theQStart: gp_Quaternion
        	:param theQEnd:
        	:type theQEnd: gp_Quaternion
        	:rtype: None
        """
        _gp.gp_QuaternionSLerp_swiginit(self, _gp.new_gp_QuaternionSLerp(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_QuaternionSLerp

# Register gp_QuaternionSLerp in _gp:
_gp.gp_QuaternionSLerp_swigregister(gp_QuaternionSLerp)

class gp_Sphere(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Area = _swig_new_instance_method(_gp.gp_Sphere_Area)
    Coefficients = _swig_new_instance_method(_gp.gp_Sphere_Coefficients)
    Direct = _swig_new_instance_method(_gp.gp_Sphere_Direct)
    Location = _swig_new_instance_method(_gp.gp_Sphere_Location)
    Mirror = _swig_new_instance_method(_gp.gp_Sphere_Mirror)
    Mirrored = _swig_new_instance_method(_gp.gp_Sphere_Mirrored)
    Position = _swig_new_instance_method(_gp.gp_Sphere_Position)
    Radius = _swig_new_instance_method(_gp.gp_Sphere_Radius)
    Rotate = _swig_new_instance_method(_gp.gp_Sphere_Rotate)
    Rotated = _swig_new_instance_method(_gp.gp_Sphere_Rotated)
    Scale = _swig_new_instance_method(_gp.gp_Sphere_Scale)
    Scaled = _swig_new_instance_method(_gp.gp_Sphere_Scaled)
    SetLocation = _swig_new_instance_method(_gp.gp_Sphere_SetLocation)
    SetPosition = _swig_new_instance_method(_gp.gp_Sphere_SetPosition)
    SetRadius = _swig_new_instance_method(_gp.gp_Sphere_SetRadius)
    Transform = _swig_new_instance_method(_gp.gp_Sphere_Transform)
    Transformed = _swig_new_instance_method(_gp.gp_Sphere_Transformed)
    Translate = _swig_new_instance_method(_gp.gp_Sphere_Translate)
    Translated = _swig_new_instance_method(_gp.gp_Sphere_Translated)
    UReverse = _swig_new_instance_method(_gp.gp_Sphere_UReverse)
    VReverse = _swig_new_instance_method(_gp.gp_Sphere_VReverse)
    Volume = _swig_new_instance_method(_gp.gp_Sphere_Volume)
    XAxis = _swig_new_instance_method(_gp.gp_Sphere_XAxis)
    YAxis = _swig_new_instance_method(_gp.gp_Sphere_YAxis)

    def __init__(self, *args):
        r"""
        * Creates an indefinite sphere.
        	:rtype: None* Constructs a sphere with radius Radius, centered on the origin of A3. A3 is the local coordinate system of the sphere. Warnings : It is not forbidden to create a sphere with null radius. Raises ConstructionError if Radius < 0.0
        	:param A3:
        	:type A3: gp_Ax3
        	:param Radius:
        	:type Radius: float
        	:rtype: None
        """
        _gp.gp_Sphere_swiginit(self, _gp.new_gp_Sphere(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Sphere

# Register gp_Sphere in _gp:
_gp.gp_Sphere_swigregister(gp_Sphere)

class gp_Torus(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Area = _swig_new_instance_method(_gp.gp_Torus_Area)
    Axis = _swig_new_instance_method(_gp.gp_Torus_Axis)
    Direct = _swig_new_instance_method(_gp.gp_Torus_Direct)
    Location = _swig_new_instance_method(_gp.gp_Torus_Location)
    MajorRadius = _swig_new_instance_method(_gp.gp_Torus_MajorRadius)
    MinorRadius = _swig_new_instance_method(_gp.gp_Torus_MinorRadius)
    Mirror = _swig_new_instance_method(_gp.gp_Torus_Mirror)
    Mirrored = _swig_new_instance_method(_gp.gp_Torus_Mirrored)
    Position = _swig_new_instance_method(_gp.gp_Torus_Position)
    Rotate = _swig_new_instance_method(_gp.gp_Torus_Rotate)
    Rotated = _swig_new_instance_method(_gp.gp_Torus_Rotated)
    Scale = _swig_new_instance_method(_gp.gp_Torus_Scale)
    Scaled = _swig_new_instance_method(_gp.gp_Torus_Scaled)
    SetAxis = _swig_new_instance_method(_gp.gp_Torus_SetAxis)
    SetLocation = _swig_new_instance_method(_gp.gp_Torus_SetLocation)
    SetMajorRadius = _swig_new_instance_method(_gp.gp_Torus_SetMajorRadius)
    SetMinorRadius = _swig_new_instance_method(_gp.gp_Torus_SetMinorRadius)
    SetPosition = _swig_new_instance_method(_gp.gp_Torus_SetPosition)
    Transform = _swig_new_instance_method(_gp.gp_Torus_Transform)
    Transformed = _swig_new_instance_method(_gp.gp_Torus_Transformed)
    Translate = _swig_new_instance_method(_gp.gp_Torus_Translate)
    Translated = _swig_new_instance_method(_gp.gp_Torus_Translated)
    UReverse = _swig_new_instance_method(_gp.gp_Torus_UReverse)
    VReverse = _swig_new_instance_method(_gp.gp_Torus_VReverse)
    Volume = _swig_new_instance_method(_gp.gp_Torus_Volume)
    XAxis = _swig_new_instance_method(_gp.gp_Torus_XAxis)
    YAxis = _swig_new_instance_method(_gp.gp_Torus_YAxis)

    def __init__(self, *args):
        r"""
        * creates an indefinite Torus.
        	:rtype: None* a torus centered on the origin of coordinate system A3, with major radius MajorRadius and minor radius MinorRadius, and with the reference plane defined by the origin, the 'X Direction' and the 'Y Direction' of A3. Warnings : It is not forbidden to create a torus with MajorRadius = MinorRadius = 0.0 Raises ConstructionError if MinorRadius < 0.0 or if MajorRadius < 0.0
        	:param A3:
        	:type A3: gp_Ax3
        	:param MajorRadius:
        	:type MajorRadius: float
        	:param MinorRadius:
        	:type MinorRadius: float
        	:rtype: None
        """
        _gp.gp_Torus_swiginit(self, _gp.new_gp_Torus(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Torus

# Register gp_Torus in _gp:
_gp.gp_Torus_swigregister(gp_Torus)

class gp_Trsf(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DumpJsonToString = _swig_new_instance_method(_gp.gp_Trsf_DumpJsonToString)
    Form = _swig_new_instance_method(_gp.gp_Trsf_Form)
    GetRotation = _swig_new_instance_method(_gp.gp_Trsf_GetRotation)
    HVectorialPart = _swig_new_instance_method(_gp.gp_Trsf_HVectorialPart)
    Invert = _swig_new_instance_method(_gp.gp_Trsf_Invert)
    Inverted = _swig_new_instance_method(_gp.gp_Trsf_Inverted)
    IsNegative = _swig_new_instance_method(_gp.gp_Trsf_IsNegative)
    Multiplied = _swig_new_instance_method(_gp.gp_Trsf_Multiplied)
    Multiply = _swig_new_instance_method(_gp.gp_Trsf_Multiply)
    Power = _swig_new_instance_method(_gp.gp_Trsf_Power)
    Powered = _swig_new_instance_method(_gp.gp_Trsf_Powered)
    PreMultiply = _swig_new_instance_method(_gp.gp_Trsf_PreMultiply)
    ScaleFactor = _swig_new_instance_method(_gp.gp_Trsf_ScaleFactor)
    SetDisplacement = _swig_new_instance_method(_gp.gp_Trsf_SetDisplacement)
    SetForm = _swig_new_instance_method(_gp.gp_Trsf_SetForm)
    SetMirror = _swig_new_instance_method(_gp.gp_Trsf_SetMirror)
    SetRotation = _swig_new_instance_method(_gp.gp_Trsf_SetRotation)
    SetScale = _swig_new_instance_method(_gp.gp_Trsf_SetScale)
    SetScaleFactor = _swig_new_instance_method(_gp.gp_Trsf_SetScaleFactor)
    SetTransformation = _swig_new_instance_method(_gp.gp_Trsf_SetTransformation)
    SetTranslation = _swig_new_instance_method(_gp.gp_Trsf_SetTranslation)
    SetTranslationPart = _swig_new_instance_method(_gp.gp_Trsf_SetTranslationPart)
    SetValues = _swig_new_instance_method(_gp.gp_Trsf_SetValues)
    Transforms = _swig_new_instance_method(_gp.gp_Trsf_Transforms)
    TranslationPart = _swig_new_instance_method(_gp.gp_Trsf_TranslationPart)
    Value = _swig_new_instance_method(_gp.gp_Trsf_Value)
    VectorialPart = _swig_new_instance_method(_gp.gp_Trsf_VectorialPart)

    def __init__(self, *args):
        r"""
        * Returns the identity transformation.
        	:rtype: None* Creates a 3D transformation from the 2D transformation T. The resulting transformation has a homogeneous vectorial part, V3, and a translation part, T3, built from T: a11 a12 0 a13 V3 = a21 a22 0 T3 = a23 0 0 1. 0 It also has the same scale factor as T. This guarantees (by projection) that the transformation which would be performed by T in a plane (2D space) is performed by the resulting transformation in the xOy plane of the 3D space, (i.e. in the plane defined by the origin (0., 0., 0.) and the vectors DX (1., 0., 0.), and DY (0., 1., 0.)). The scale factor is applied to the entire space.
        	:param T:
        	:type T: gp_Trsf2d
        	:rtype: None
        """
        _gp.gp_Trsf_swiginit(self, _gp.new_gp_Trsf(*args))
    __mul__ = _swig_new_instance_method(_gp.gp_Trsf___mul__)
    __imul_wrapper__ = _swig_new_instance_method(_gp.gp_Trsf___imul_wrapper__)

    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self


    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Trsf

# Register gp_Trsf in _gp:
_gp.gp_Trsf_swigregister(gp_Trsf)

class gp_Trsf2d(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Form = _swig_new_instance_method(_gp.gp_Trsf2d_Form)
    HVectorialPart = _swig_new_instance_method(_gp.gp_Trsf2d_HVectorialPart)
    Invert = _swig_new_instance_method(_gp.gp_Trsf2d_Invert)
    Inverted = _swig_new_instance_method(_gp.gp_Trsf2d_Inverted)
    IsNegative = _swig_new_instance_method(_gp.gp_Trsf2d_IsNegative)
    Multiplied = _swig_new_instance_method(_gp.gp_Trsf2d_Multiplied)
    Multiply = _swig_new_instance_method(_gp.gp_Trsf2d_Multiply)
    Power = _swig_new_instance_method(_gp.gp_Trsf2d_Power)
    Powered = _swig_new_instance_method(_gp.gp_Trsf2d_Powered)
    PreMultiply = _swig_new_instance_method(_gp.gp_Trsf2d_PreMultiply)
    RotationPart = _swig_new_instance_method(_gp.gp_Trsf2d_RotationPart)
    ScaleFactor = _swig_new_instance_method(_gp.gp_Trsf2d_ScaleFactor)
    SetMirror = _swig_new_instance_method(_gp.gp_Trsf2d_SetMirror)
    SetRotation = _swig_new_instance_method(_gp.gp_Trsf2d_SetRotation)
    SetScale = _swig_new_instance_method(_gp.gp_Trsf2d_SetScale)
    SetScaleFactor = _swig_new_instance_method(_gp.gp_Trsf2d_SetScaleFactor)
    SetTransformation = _swig_new_instance_method(_gp.gp_Trsf2d_SetTransformation)
    SetTranslation = _swig_new_instance_method(_gp.gp_Trsf2d_SetTranslation)
    SetTranslationPart = _swig_new_instance_method(_gp.gp_Trsf2d_SetTranslationPart)
    SetValues = _swig_new_instance_method(_gp.gp_Trsf2d_SetValues)
    Transforms = _swig_new_instance_method(_gp.gp_Trsf2d_Transforms)
    TranslationPart = _swig_new_instance_method(_gp.gp_Trsf2d_TranslationPart)
    Value = _swig_new_instance_method(_gp.gp_Trsf2d_Value)
    VectorialPart = _swig_new_instance_method(_gp.gp_Trsf2d_VectorialPart)

    def __init__(self, *args):
        r"""
        * Returns identity transformation.
        	:rtype: None* Creates a 2d transformation in the XY plane from a 3d transformation .
        	:param T:
        	:type T: gp_Trsf
        	:rtype: None
        """
        _gp.gp_Trsf2d_swiginit(self, _gp.new_gp_Trsf2d(*args))
    __mul__ = _swig_new_instance_method(_gp.gp_Trsf2d___mul__)
    __imul_wrapper__ = _swig_new_instance_method(_gp.gp_Trsf2d___imul_wrapper__)

    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self


    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Trsf2d

# Register gp_Trsf2d in _gp:
_gp.gp_Trsf2d_swigregister(gp_Trsf2d)

class gp_Vec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Add = _swig_new_instance_method(_gp.gp_Vec_Add)
    Added = _swig_new_instance_method(_gp.gp_Vec_Added)
    Angle = _swig_new_instance_method(_gp.gp_Vec_Angle)
    AngleWithRef = _swig_new_instance_method(_gp.gp_Vec_AngleWithRef)
    Coord = _swig_new_instance_method(_gp.gp_Vec_Coord)
    Cross = _swig_new_instance_method(_gp.gp_Vec_Cross)
    CrossCross = _swig_new_instance_method(_gp.gp_Vec_CrossCross)
    CrossCrossed = _swig_new_instance_method(_gp.gp_Vec_CrossCrossed)
    CrossMagnitude = _swig_new_instance_method(_gp.gp_Vec_CrossMagnitude)
    CrossSquareMagnitude = _swig_new_instance_method(_gp.gp_Vec_CrossSquareMagnitude)
    Crossed = _swig_new_instance_method(_gp.gp_Vec_Crossed)
    Divide = _swig_new_instance_method(_gp.gp_Vec_Divide)
    Divided = _swig_new_instance_method(_gp.gp_Vec_Divided)
    Dot = _swig_new_instance_method(_gp.gp_Vec_Dot)
    DotCross = _swig_new_instance_method(_gp.gp_Vec_DotCross)
    IsEqual = _swig_new_instance_method(_gp.gp_Vec_IsEqual)
    IsNormal = _swig_new_instance_method(_gp.gp_Vec_IsNormal)
    IsOpposite = _swig_new_instance_method(_gp.gp_Vec_IsOpposite)
    IsParallel = _swig_new_instance_method(_gp.gp_Vec_IsParallel)
    Magnitude = _swig_new_instance_method(_gp.gp_Vec_Magnitude)
    Mirror = _swig_new_instance_method(_gp.gp_Vec_Mirror)
    Mirrored = _swig_new_instance_method(_gp.gp_Vec_Mirrored)
    Multiplied = _swig_new_instance_method(_gp.gp_Vec_Multiplied)
    Multiply = _swig_new_instance_method(_gp.gp_Vec_Multiply)
    Normalize = _swig_new_instance_method(_gp.gp_Vec_Normalize)
    Normalized = _swig_new_instance_method(_gp.gp_Vec_Normalized)
    Reverse = _swig_new_instance_method(_gp.gp_Vec_Reverse)
    Reversed = _swig_new_instance_method(_gp.gp_Vec_Reversed)
    Rotate = _swig_new_instance_method(_gp.gp_Vec_Rotate)
    Rotated = _swig_new_instance_method(_gp.gp_Vec_Rotated)
    Scale = _swig_new_instance_method(_gp.gp_Vec_Scale)
    Scaled = _swig_new_instance_method(_gp.gp_Vec_Scaled)
    SetCoord = _swig_new_instance_method(_gp.gp_Vec_SetCoord)
    SetLinearForm = _swig_new_instance_method(_gp.gp_Vec_SetLinearForm)
    SetX = _swig_new_instance_method(_gp.gp_Vec_SetX)
    SetXYZ = _swig_new_instance_method(_gp.gp_Vec_SetXYZ)
    SetY = _swig_new_instance_method(_gp.gp_Vec_SetY)
    SetZ = _swig_new_instance_method(_gp.gp_Vec_SetZ)
    SquareMagnitude = _swig_new_instance_method(_gp.gp_Vec_SquareMagnitude)
    Subtract = _swig_new_instance_method(_gp.gp_Vec_Subtract)
    Subtracted = _swig_new_instance_method(_gp.gp_Vec_Subtracted)
    Transform = _swig_new_instance_method(_gp.gp_Vec_Transform)
    Transformed = _swig_new_instance_method(_gp.gp_Vec_Transformed)
    X = _swig_new_instance_method(_gp.gp_Vec_X)
    XYZ = _swig_new_instance_method(_gp.gp_Vec_XYZ)
    Y = _swig_new_instance_method(_gp.gp_Vec_Y)
    Z = _swig_new_instance_method(_gp.gp_Vec_Z)

    def __init__(self, *args):
        r"""
        * Creates a zero vector.
        	:rtype: None* Creates a unitary vector from a direction V.
        	:param V:
        	:type V: gp_Dir
        	:rtype: None* Creates a vector with a triplet of coordinates.
        	:param Coord:
        	:type Coord: gp_XYZ
        	:rtype: None* Creates a point with its three cartesian coordinates.
        	:param Xv:
        	:type Xv: float
        	:param Yv:
        	:type Yv: float
        	:param Zv:
        	:type Zv: float
        	:rtype: None* Creates a vector from two points. The length of the vector is the distance between P1 and P2
        	:param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: None
        """
        _gp.gp_Vec_swiginit(self, _gp.new_gp_Vec(*args))
    __mul__ = _swig_new_instance_method(_gp.gp_Vec___mul__)
    __imul_wrapper__ = _swig_new_instance_method(_gp.gp_Vec___imul_wrapper__)

    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self

    __add__ = _swig_new_instance_method(_gp.gp_Vec___add__)
    __iadd_wrapper__ = _swig_new_instance_method(_gp.gp_Vec___iadd_wrapper__)

    def __iadd__(self, right):
        self.__iadd_wrapper__(right)
        return self

    __sub__ = _swig_new_instance_method(_gp.gp_Vec___sub__)
    __neg__ = _swig_new_instance_method(_gp.gp_Vec___neg__)
    __isub_wrapper__ = _swig_new_instance_method(_gp.gp_Vec___isub_wrapper__)

    def __isub__(self, right):
        self.__isub_wrapper__(right)
        return self


    def __truediv__(self, *args):
        return _gp.gp_Vec___truediv__(self, *args)
    __div__ = __truediv__


    __itruediv_wrapper__ = _swig_new_instance_method(_gp.gp_Vec___itruediv_wrapper__)

    def __itruediv__(self, right):
        self.__itruediv_wrapper__(right)
        return self


    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Vec

# Register gp_Vec in _gp:
_gp.gp_Vec_swigregister(gp_Vec)

class gp_Vec2d(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Add = _swig_new_instance_method(_gp.gp_Vec2d_Add)
    Added = _swig_new_instance_method(_gp.gp_Vec2d_Added)
    Angle = _swig_new_instance_method(_gp.gp_Vec2d_Angle)
    Coord = _swig_new_instance_method(_gp.gp_Vec2d_Coord)
    CrossMagnitude = _swig_new_instance_method(_gp.gp_Vec2d_CrossMagnitude)
    CrossSquareMagnitude = _swig_new_instance_method(_gp.gp_Vec2d_CrossSquareMagnitude)
    Crossed = _swig_new_instance_method(_gp.gp_Vec2d_Crossed)
    Divide = _swig_new_instance_method(_gp.gp_Vec2d_Divide)
    Divided = _swig_new_instance_method(_gp.gp_Vec2d_Divided)
    Dot = _swig_new_instance_method(_gp.gp_Vec2d_Dot)
    GetNormal = _swig_new_instance_method(_gp.gp_Vec2d_GetNormal)
    IsEqual = _swig_new_instance_method(_gp.gp_Vec2d_IsEqual)
    IsNormal = _swig_new_instance_method(_gp.gp_Vec2d_IsNormal)
    IsOpposite = _swig_new_instance_method(_gp.gp_Vec2d_IsOpposite)
    IsParallel = _swig_new_instance_method(_gp.gp_Vec2d_IsParallel)
    Magnitude = _swig_new_instance_method(_gp.gp_Vec2d_Magnitude)
    Mirror = _swig_new_instance_method(_gp.gp_Vec2d_Mirror)
    Mirrored = _swig_new_instance_method(_gp.gp_Vec2d_Mirrored)
    Multiplied = _swig_new_instance_method(_gp.gp_Vec2d_Multiplied)
    Multiply = _swig_new_instance_method(_gp.gp_Vec2d_Multiply)
    Normalize = _swig_new_instance_method(_gp.gp_Vec2d_Normalize)
    Normalized = _swig_new_instance_method(_gp.gp_Vec2d_Normalized)
    Reverse = _swig_new_instance_method(_gp.gp_Vec2d_Reverse)
    Reversed = _swig_new_instance_method(_gp.gp_Vec2d_Reversed)
    Rotate = _swig_new_instance_method(_gp.gp_Vec2d_Rotate)
    Rotated = _swig_new_instance_method(_gp.gp_Vec2d_Rotated)
    Scale = _swig_new_instance_method(_gp.gp_Vec2d_Scale)
    Scaled = _swig_new_instance_method(_gp.gp_Vec2d_Scaled)
    SetCoord = _swig_new_instance_method(_gp.gp_Vec2d_SetCoord)
    SetLinearForm = _swig_new_instance_method(_gp.gp_Vec2d_SetLinearForm)
    SetX = _swig_new_instance_method(_gp.gp_Vec2d_SetX)
    SetXY = _swig_new_instance_method(_gp.gp_Vec2d_SetXY)
    SetY = _swig_new_instance_method(_gp.gp_Vec2d_SetY)
    SquareMagnitude = _swig_new_instance_method(_gp.gp_Vec2d_SquareMagnitude)
    Subtract = _swig_new_instance_method(_gp.gp_Vec2d_Subtract)
    Subtracted = _swig_new_instance_method(_gp.gp_Vec2d_Subtracted)
    Transform = _swig_new_instance_method(_gp.gp_Vec2d_Transform)
    Transformed = _swig_new_instance_method(_gp.gp_Vec2d_Transformed)
    X = _swig_new_instance_method(_gp.gp_Vec2d_X)
    XY = _swig_new_instance_method(_gp.gp_Vec2d_XY)
    Y = _swig_new_instance_method(_gp.gp_Vec2d_Y)

    def __init__(self, *args):
        r"""
        * Creates a zero vector.
        	:rtype: None* Creates a unitary vector from a direction V.
        	:param V:
        	:type V: gp_Dir2d
        	:rtype: None* Creates a vector with a doublet of coordinates.
        	:param Coord:
        	:type Coord: gp_XY
        	:rtype: None* Creates a point with its two Cartesian coordinates.
        	:param Xv:
        	:type Xv: float
        	:param Yv:
        	:type Yv: float
        	:rtype: None* Creates a vector from two points. The length of the vector is the distance between P1 and P2
        	:param P1:
        	:type P1: gp_Pnt2d
        	:param P2:
        	:type P2: gp_Pnt2d
        	:rtype: None
        """
        _gp.gp_Vec2d_swiginit(self, _gp.new_gp_Vec2d(*args))
    __mul__ = _swig_new_instance_method(_gp.gp_Vec2d___mul__)
    __imul_wrapper__ = _swig_new_instance_method(_gp.gp_Vec2d___imul_wrapper__)

    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self

    __add__ = _swig_new_instance_method(_gp.gp_Vec2d___add__)
    __iadd_wrapper__ = _swig_new_instance_method(_gp.gp_Vec2d___iadd_wrapper__)

    def __iadd__(self, right):
        self.__iadd_wrapper__(right)
        return self

    __neg__ = _swig_new_instance_method(_gp.gp_Vec2d___neg__)
    __sub__ = _swig_new_instance_method(_gp.gp_Vec2d___sub__)
    __isub_wrapper__ = _swig_new_instance_method(_gp.gp_Vec2d___isub_wrapper__)

    def __isub__(self, right):
        self.__isub_wrapper__(right)
        return self


    def __truediv__(self, *args):
        return _gp.gp_Vec2d___truediv__(self, *args)
    __div__ = __truediv__


    __itruediv_wrapper__ = _swig_new_instance_method(_gp.gp_Vec2d___itruediv_wrapper__)

    def __itruediv__(self, right):
        self.__itruediv_wrapper__(right)
        return self


    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_Vec2d

# Register gp_Vec2d in _gp:
_gp.gp_Vec2d_swigregister(gp_Vec2d)

class gp_XY(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Add = _swig_new_instance_method(_gp.gp_XY_Add)
    Added = _swig_new_instance_method(_gp.gp_XY_Added)
    GetChangeCoord = _swig_new_instance_method(_gp.gp_XY_GetChangeCoord)
    SetChangeCoord = _swig_new_instance_method(_gp.gp_XY_SetChangeCoord)
    Coord = _swig_new_instance_method(_gp.gp_XY_Coord)
    CrossMagnitude = _swig_new_instance_method(_gp.gp_XY_CrossMagnitude)
    CrossSquareMagnitude = _swig_new_instance_method(_gp.gp_XY_CrossSquareMagnitude)
    Crossed = _swig_new_instance_method(_gp.gp_XY_Crossed)
    Divide = _swig_new_instance_method(_gp.gp_XY_Divide)
    Divided = _swig_new_instance_method(_gp.gp_XY_Divided)
    Dot = _swig_new_instance_method(_gp.gp_XY_Dot)
    IsEqual = _swig_new_instance_method(_gp.gp_XY_IsEqual)
    Modulus = _swig_new_instance_method(_gp.gp_XY_Modulus)
    Multiplied = _swig_new_instance_method(_gp.gp_XY_Multiplied)
    Multiply = _swig_new_instance_method(_gp.gp_XY_Multiply)
    Normalize = _swig_new_instance_method(_gp.gp_XY_Normalize)
    Normalized = _swig_new_instance_method(_gp.gp_XY_Normalized)
    Reverse = _swig_new_instance_method(_gp.gp_XY_Reverse)
    Reversed = _swig_new_instance_method(_gp.gp_XY_Reversed)
    SetCoord = _swig_new_instance_method(_gp.gp_XY_SetCoord)
    SetLinearForm = _swig_new_instance_method(_gp.gp_XY_SetLinearForm)
    SetX = _swig_new_instance_method(_gp.gp_XY_SetX)
    SetY = _swig_new_instance_method(_gp.gp_XY_SetY)
    SquareModulus = _swig_new_instance_method(_gp.gp_XY_SquareModulus)
    Subtract = _swig_new_instance_method(_gp.gp_XY_Subtract)
    Subtracted = _swig_new_instance_method(_gp.gp_XY_Subtracted)
    X = _swig_new_instance_method(_gp.gp_XY_X)
    Y = _swig_new_instance_method(_gp.gp_XY_Y)

    def __init__(self, *args):
        r"""
        * Creates XY object with zero coordinates (0,0).
        	:rtype: None* a number pair defined by the XY coordinates
        	:param X:
        	:type X: float
        	:param Y:
        	:type Y: float
        	:rtype: None
        """
        _gp.gp_XY_swiginit(self, _gp.new_gp_XY(*args))
    __mul__ = _swig_new_instance_method(_gp.gp_XY___mul__)

    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self


    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self

    __imul_wrapper__ = _swig_new_instance_method(_gp.gp_XY___imul_wrapper__)

    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self

    __add__ = _swig_new_instance_method(_gp.gp_XY___add__)
    __iadd_wrapper__ = _swig_new_instance_method(_gp.gp_XY___iadd_wrapper__)

    def __iadd__(self, right):
        self.__iadd_wrapper__(right)
        return self

    __neg__ = _swig_new_instance_method(_gp.gp_XY___neg__)
    __sub__ = _swig_new_instance_method(_gp.gp_XY___sub__)
    __isub_wrapper__ = _swig_new_instance_method(_gp.gp_XY___isub_wrapper__)

    def __isub__(self, right):
        self.__isub_wrapper__(right)
        return self


    def __truediv__(self, *args):
        return _gp.gp_XY___truediv__(self, *args)
    __div__ = __truediv__


    __itruediv_wrapper__ = _swig_new_instance_method(_gp.gp_XY___itruediv_wrapper__)

    def __itruediv__(self, right):
        self.__itruediv_wrapper__(right)
        return self


    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_XY

# Register gp_XY in _gp:
_gp.gp_XY_swigregister(gp_XY)

class gp_XYZ(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Add = _swig_new_instance_method(_gp.gp_XYZ_Add)
    Added = _swig_new_instance_method(_gp.gp_XYZ_Added)
    GetChangeCoord = _swig_new_instance_method(_gp.gp_XYZ_GetChangeCoord)
    SetChangeCoord = _swig_new_instance_method(_gp.gp_XYZ_SetChangeCoord)
    ChangeData = _swig_new_instance_method(_gp.gp_XYZ_ChangeData)
    Coord = _swig_new_instance_method(_gp.gp_XYZ_Coord)
    Cross = _swig_new_instance_method(_gp.gp_XYZ_Cross)
    CrossCross = _swig_new_instance_method(_gp.gp_XYZ_CrossCross)
    CrossCrossed = _swig_new_instance_method(_gp.gp_XYZ_CrossCrossed)
    CrossMagnitude = _swig_new_instance_method(_gp.gp_XYZ_CrossMagnitude)
    CrossSquareMagnitude = _swig_new_instance_method(_gp.gp_XYZ_CrossSquareMagnitude)
    Crossed = _swig_new_instance_method(_gp.gp_XYZ_Crossed)
    Divide = _swig_new_instance_method(_gp.gp_XYZ_Divide)
    Divided = _swig_new_instance_method(_gp.gp_XYZ_Divided)
    Dot = _swig_new_instance_method(_gp.gp_XYZ_Dot)
    DotCross = _swig_new_instance_method(_gp.gp_XYZ_DotCross)
    DumpJsonToString = _swig_new_instance_method(_gp.gp_XYZ_DumpJsonToString)
    GetData = _swig_new_instance_method(_gp.gp_XYZ_GetData)
    IsEqual = _swig_new_instance_method(_gp.gp_XYZ_IsEqual)
    Modulus = _swig_new_instance_method(_gp.gp_XYZ_Modulus)
    Multiplied = _swig_new_instance_method(_gp.gp_XYZ_Multiplied)
    Multiply = _swig_new_instance_method(_gp.gp_XYZ_Multiply)
    Normalize = _swig_new_instance_method(_gp.gp_XYZ_Normalize)
    Normalized = _swig_new_instance_method(_gp.gp_XYZ_Normalized)
    Reverse = _swig_new_instance_method(_gp.gp_XYZ_Reverse)
    Reversed = _swig_new_instance_method(_gp.gp_XYZ_Reversed)
    SetCoord = _swig_new_instance_method(_gp.gp_XYZ_SetCoord)
    SetLinearForm = _swig_new_instance_method(_gp.gp_XYZ_SetLinearForm)
    SetX = _swig_new_instance_method(_gp.gp_XYZ_SetX)
    SetY = _swig_new_instance_method(_gp.gp_XYZ_SetY)
    SetZ = _swig_new_instance_method(_gp.gp_XYZ_SetZ)
    SquareModulus = _swig_new_instance_method(_gp.gp_XYZ_SquareModulus)
    Subtract = _swig_new_instance_method(_gp.gp_XYZ_Subtract)
    Subtracted = _swig_new_instance_method(_gp.gp_XYZ_Subtracted)
    X = _swig_new_instance_method(_gp.gp_XYZ_X)
    Y = _swig_new_instance_method(_gp.gp_XYZ_Y)
    Z = _swig_new_instance_method(_gp.gp_XYZ_Z)

    def __init__(self, *args):
        r"""
        * Creates an XYZ object with zero co-ordinates (0,0,0)
        	:rtype: None* creates an XYZ with given coordinates
        	:param X:
        	:type X: float
        	:param Y:
        	:type Y: float
        	:param Z:
        	:type Z: float
        	:rtype: None
        """
        _gp.gp_XYZ_swiginit(self, _gp.new_gp_XYZ(*args))
    __mul__ = _swig_new_instance_method(_gp.gp_XYZ___mul__)

    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self


    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self

    __imul_wrapper__ = _swig_new_instance_method(_gp.gp_XYZ___imul_wrapper__)

    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self

    __add__ = _swig_new_instance_method(_gp.gp_XYZ___add__)
    __iadd_wrapper__ = _swig_new_instance_method(_gp.gp_XYZ___iadd_wrapper__)

    def __iadd__(self, right):
        self.__iadd_wrapper__(right)
        return self

    __sub__ = _swig_new_instance_method(_gp.gp_XYZ___sub__)
    __isub_wrapper__ = _swig_new_instance_method(_gp.gp_XYZ___isub_wrapper__)

    def __isub__(self, right):
        self.__isub_wrapper__(right)
        return self


    def __truediv__(self, *args):
        return _gp.gp_XYZ___truediv__(self, *args)
    __div__ = __truediv__


    __itruediv_wrapper__ = _swig_new_instance_method(_gp.gp_XYZ___itruediv_wrapper__)

    def __itruediv__(self, right):
        self.__itruediv_wrapper__(right)
        return self


    __repr__ = _dumps_object

    __swig_destroy__ = _gp.delete_gp_XYZ

# Register gp_XYZ in _gp:
_gp.gp_XYZ_swigregister(gp_XYZ)



