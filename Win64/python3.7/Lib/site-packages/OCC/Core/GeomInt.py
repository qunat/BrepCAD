# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
GeomInt module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_geomint.html
"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _GeomInt
else:
    import _GeomInt

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _GeomInt.SWIG_PyInstanceMethod_New
_swig_new_static_method = _GeomInt.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _GeomInt.delete_SwigPyIterator
    value = _swig_new_instance_method(_GeomInt.SwigPyIterator_value)
    incr = _swig_new_instance_method(_GeomInt.SwigPyIterator_incr)
    decr = _swig_new_instance_method(_GeomInt.SwigPyIterator_decr)
    distance = _swig_new_instance_method(_GeomInt.SwigPyIterator_distance)
    equal = _swig_new_instance_method(_GeomInt.SwigPyIterator_equal)
    copy = _swig_new_instance_method(_GeomInt.SwigPyIterator_copy)
    next = _swig_new_instance_method(_GeomInt.SwigPyIterator_next)
    __next__ = _swig_new_instance_method(_GeomInt.SwigPyIterator___next__)
    previous = _swig_new_instance_method(_GeomInt.SwigPyIterator_previous)
    advance = _swig_new_instance_method(_GeomInt.SwigPyIterator_advance)
    __eq__ = _swig_new_instance_method(_GeomInt.SwigPyIterator___eq__)
    __ne__ = _swig_new_instance_method(_GeomInt.SwigPyIterator___ne__)
    __iadd__ = _swig_new_instance_method(_GeomInt.SwigPyIterator___iadd__)
    __isub__ = _swig_new_instance_method(_GeomInt.SwigPyIterator___isub__)
    __add__ = _swig_new_instance_method(_GeomInt.SwigPyIterator___add__)
    __sub__ = _swig_new_instance_method(_GeomInt.SwigPyIterator___sub__)
    def __iter__(self):
        return self

# Register SwigPyIterator in _GeomInt:
_GeomInt.SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.math
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.Message
import OCC.Core.gp
import OCC.Core.AppParCurves
import OCC.Core.TColgp
import OCC.Core.Geom
import OCC.Core.GeomAbs
import OCC.Core.Geom2d
import OCC.Core.IntPatch
import OCC.Core.Intf
import OCC.Core.Bnd
import OCC.Core.BVH
import OCC.Core.Adaptor3d
import OCC.Core.TopAbs
import OCC.Core.Adaptor2d
import OCC.Core.IntSurf
import OCC.Core.IntAna
import OCC.Core.GeomAdaptor
import OCC.Core.Approx
import OCC.Core.AppCont
import OCC.Core.IntImp
import OCC.Core.ApproxInt
class GeomInt_VectorOfReal(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    begin = _swig_new_instance_method(_GeomInt.GeomInt_VectorOfReal_begin)
    end = _swig_new_instance_method(_GeomInt.GeomInt_VectorOfReal_end)
    cbegin = _swig_new_instance_method(_GeomInt.GeomInt_VectorOfReal_cbegin)
    cend = _swig_new_instance_method(_GeomInt.GeomInt_VectorOfReal_cend)

    def __init__(self, *args):
        _GeomInt.GeomInt_VectorOfReal_swiginit(self, _GeomInt.new_GeomInt_VectorOfReal(*args))
    __swig_destroy__ = _GeomInt.delete_GeomInt_VectorOfReal
    Length = _swig_new_instance_method(_GeomInt.GeomInt_VectorOfReal_Length)
    Size = _swig_new_instance_method(_GeomInt.GeomInt_VectorOfReal_Size)
    Lower = _swig_new_instance_method(_GeomInt.GeomInt_VectorOfReal_Lower)
    Upper = _swig_new_instance_method(_GeomInt.GeomInt_VectorOfReal_Upper)
    IsEmpty = _swig_new_instance_method(_GeomInt.GeomInt_VectorOfReal_IsEmpty)
    Assign = _swig_new_instance_method(_GeomInt.GeomInt_VectorOfReal_Assign)
    Set = _swig_new_instance_method(_GeomInt.GeomInt_VectorOfReal_Set)
    Append = _swig_new_instance_method(_GeomInt.GeomInt_VectorOfReal_Append)
    Appended = _swig_new_instance_method(_GeomInt.GeomInt_VectorOfReal_Appended)
    Value = _swig_new_instance_method(_GeomInt.GeomInt_VectorOfReal_Value)
    First = _swig_new_instance_method(_GeomInt.GeomInt_VectorOfReal_First)
    ChangeFirst = _swig_new_instance_method(_GeomInt.GeomInt_VectorOfReal_ChangeFirst)
    Last = _swig_new_instance_method(_GeomInt.GeomInt_VectorOfReal_Last)
    ChangeLast = _swig_new_instance_method(_GeomInt.GeomInt_VectorOfReal_ChangeLast)
    __call__ = _swig_new_instance_method(_GeomInt.GeomInt_VectorOfReal___call__)
    ChangeValue = _swig_new_instance_method(_GeomInt.GeomInt_VectorOfReal_ChangeValue)
    SetValue = _swig_new_instance_method(_GeomInt.GeomInt_VectorOfReal_SetValue)

# Register GeomInt_VectorOfReal in _GeomInt:
_GeomInt.GeomInt_VectorOfReal_swigregister(GeomInt_VectorOfReal)

class GeomInt_SequenceOfParameterAndOrientation(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    begin = _swig_new_instance_method(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_begin)
    end = _swig_new_instance_method(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_end)
    cbegin = _swig_new_instance_method(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_cbegin)
    cend = _swig_new_instance_method(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_cend)

    def __init__(self, *args):
        _GeomInt.GeomInt_SequenceOfParameterAndOrientation_swiginit(self, _GeomInt.new_GeomInt_SequenceOfParameterAndOrientation(*args))
    Size = _swig_new_instance_method(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_Size)
    Length = _swig_new_instance_method(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_Length)
    Lower = _swig_new_instance_method(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_Lower)
    Upper = _swig_new_instance_method(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_Upper)
    IsEmpty = _swig_new_instance_method(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_IsEmpty)
    Reverse = _swig_new_instance_method(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_Reverse)
    Exchange = _swig_new_instance_method(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_Exchange)
    delNode = _swig_new_static_method(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_delNode)
    Clear = _swig_new_instance_method(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_Clear)
    Assign = _swig_new_instance_method(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_Assign)
    Set = _swig_new_instance_method(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_Set)
    Remove = _swig_new_instance_method(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_Remove)
    Append = _swig_new_instance_method(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_Append)
    Prepend = _swig_new_instance_method(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_Prepend)
    InsertBefore = _swig_new_instance_method(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_InsertBefore)
    InsertAfter = _swig_new_instance_method(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_InsertAfter)
    Split = _swig_new_instance_method(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_Split)
    First = _swig_new_instance_method(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_First)
    ChangeFirst = _swig_new_instance_method(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_ChangeFirst)
    Last = _swig_new_instance_method(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_Last)
    ChangeLast = _swig_new_instance_method(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_ChangeLast)
    Value = _swig_new_instance_method(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_Value)
    ChangeValue = _swig_new_instance_method(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_ChangeValue)
    __call__ = _swig_new_instance_method(_GeomInt.GeomInt_SequenceOfParameterAndOrientation___call__)
    SetValue = _swig_new_instance_method(_GeomInt.GeomInt_SequenceOfParameterAndOrientation_SetValue)
    __swig_destroy__ = _GeomInt.delete_GeomInt_SequenceOfParameterAndOrientation

# Register GeomInt_SequenceOfParameterAndOrientation in _GeomInt:
_GeomInt.GeomInt_SequenceOfParameterAndOrientation_swigregister(GeomInt_SequenceOfParameterAndOrientation)
GeomInt_SequenceOfParameterAndOrientation_delNode = _GeomInt.GeomInt_SequenceOfParameterAndOrientation_delNode

class geomint(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    AdjustPeriodic = _swig_new_static_method(_GeomInt.geomint_AdjustPeriodic)

    __repr__ = _dumps_object


    def __init__(self):
        _GeomInt.geomint_swiginit(self, _GeomInt.new_geomint())
    __swig_destroy__ = _GeomInt.delete_geomint

# Register geomint in _GeomInt:
_GeomInt.geomint_swigregister(geomint)
geomint_AdjustPeriodic = _GeomInt.geomint_AdjustPeriodic

class GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox(OCC.Core.math.math_BFGS):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        :param F:
        	:type F: math_MultipleVarFunctionWithGradient
        	:param StartingPoint:
        	:type StartingPoint: math_Vector
        	:param Tolerance3d:
        	:type Tolerance3d: float
        	:param Tolerance2d:
        	:type Tolerance2d: float
        	:param Eps:
        	:type Eps: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:rtype: None
        """
        _GeomInt.GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox

# Register GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox in _GeomInt:
_GeomInt.GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox_swigregister(GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox)

class GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox(OCC.Core.math.math_MultipleVarFunctionWithGradient):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    CurveValue = _swig_new_instance_method(_GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_CurveValue)
    DerivativeFunctionMatrix = _swig_new_instance_method(_GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_DerivativeFunctionMatrix)
    Error = _swig_new_instance_method(_GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_Error)
    FirstConstraint = _swig_new_instance_method(_GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_FirstConstraint)
    FunctionMatrix = _swig_new_instance_method(_GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_FunctionMatrix)

    def __init__(self, *args):
        r"""
        * initializes the fields of the function. The approximating curve has <NbPol> control points.
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        """
        _GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox(*args))
    Index = _swig_new_instance_method(_GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_Index)
    LastConstraint = _swig_new_instance_method(_GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_LastConstraint)
    MaxError2d = _swig_new_instance_method(_GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_MaxError2d)
    MaxError3d = _swig_new_instance_method(_GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_MaxError3d)
    NewParameters = _swig_new_instance_method(_GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_NewParameters)
    SetFirstLambda = _swig_new_instance_method(_GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_SetFirstLambda)
    SetLastLambda = _swig_new_instance_method(_GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_SetLastLambda)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox

# Register GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox in _GeomInt:
_GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_swigregister(GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox)

class GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    BSplineValue = _swig_new_instance_method(_GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_BSplineValue)
    BezierValue = _swig_new_instance_method(_GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_BezierValue)
    DerivativeFunctionMatrix = _swig_new_instance_method(_GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_DerivativeFunctionMatrix)
    Distance = _swig_new_instance_method(_GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_Distance)
    Error = _swig_new_instance_method(_GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_Error)
    ErrorGradient = _swig_new_instance_method(_GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_ErrorGradient)
    FirstLambda = _swig_new_instance_method(_GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_FirstLambda)
    FunctionMatrix = _swig_new_instance_method(_GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_FunctionMatrix)

    def __init__(self, *args):
        r"""
        * given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. NbPol is the number of control points wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the Bernstein matrix computed with the parameters, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None* Initializes the fields of the object.
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None* given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. Deg is the degree wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the BSpline functions matrix computed with <parameters>, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None* Initializes the fields of the object.
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        """
        _GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox(*args))
    IsDone = _swig_new_instance_method(_GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_IsDone)
    KIndex = _swig_new_instance_method(_GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_KIndex)
    LastLambda = _swig_new_instance_method(_GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_LastLambda)
    Perform = _swig_new_instance_method(_GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_Perform)
    Points = _swig_new_instance_method(_GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_Points)
    Poles = _swig_new_instance_method(_GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_Poles)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox

# Register GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox in _GeomInt:
_GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_swigregister(GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox)

class GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox(OCC.Core.math.math_BFGS):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        :param F:
        	:type F: math_MultipleVarFunctionWithGradient
        	:param StartingPoint:
        	:type StartingPoint: math_Vector
        	:param Tolerance3d:
        	:type Tolerance3d: float
        	:param Tolerance2d:
        	:type Tolerance2d: float
        	:param Eps:
        	:type Eps: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:rtype: None
        """
        _GeomInt.GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox

# Register GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox in _GeomInt:
_GeomInt.GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox_swigregister(GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox)

class GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox(OCC.Core.math.math_BFGS):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        :param F:
        	:type F: math_MultipleVarFunctionWithGradient
        	:param StartingPoint:
        	:type StartingPoint: math_Vector
        	:param Tolerance3d:
        	:type Tolerance3d: float
        	:param Tolerance2d:
        	:type Tolerance2d: float
        	:param Eps:
        	:type Eps: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:rtype: None
        """
        _GeomInt.GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox

# Register GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox in _GeomInt:
_GeomInt.GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox_swigregister(GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox)

class GeomInt_IntSS(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Boundary = _swig_new_instance_method(_GeomInt.GeomInt_IntSS_Boundary)
    BuildPCurves = _swig_new_static_method(_GeomInt.GeomInt_IntSS_BuildPCurves)

    def __init__(self, *args):
        r"""
        :rtype: None* performs general intersection of two surfaces just now
        	:param S1:
        	:type S1: Geom_Surface
        	:param S2:
        	:type S2: Geom_Surface
        	:param Tol:
        	:type Tol: float
        	:param Approx: default value is Standard_True
        	:type Approx: bool
        	:param ApproxS1: default value is Standard_False
        	:type ApproxS1: bool
        	:param ApproxS2: default value is Standard_False
        	:type ApproxS2: bool
        	:rtype: None
        """
        _GeomInt.GeomInt_IntSS_swiginit(self, _GeomInt.new_GeomInt_IntSS(*args))
    HasLineOnS1 = _swig_new_instance_method(_GeomInt.GeomInt_IntSS_HasLineOnS1)
    HasLineOnS2 = _swig_new_instance_method(_GeomInt.GeomInt_IntSS_HasLineOnS2)
    IsDone = _swig_new_instance_method(_GeomInt.GeomInt_IntSS_IsDone)
    Line = _swig_new_instance_method(_GeomInt.GeomInt_IntSS_Line)
    LineOnS1 = _swig_new_instance_method(_GeomInt.GeomInt_IntSS_LineOnS1)
    LineOnS2 = _swig_new_instance_method(_GeomInt.GeomInt_IntSS_LineOnS2)
    MakeBSpline = _swig_new_static_method(_GeomInt.GeomInt_IntSS_MakeBSpline)
    MakeBSpline2d = _swig_new_static_method(_GeomInt.GeomInt_IntSS_MakeBSpline2d)
    NbBoundaries = _swig_new_instance_method(_GeomInt.GeomInt_IntSS_NbBoundaries)
    NbLines = _swig_new_instance_method(_GeomInt.GeomInt_IntSS_NbLines)
    NbPoints = _swig_new_instance_method(_GeomInt.GeomInt_IntSS_NbPoints)
    Perform = _swig_new_instance_method(_GeomInt.GeomInt_IntSS_Perform)
    Pnt2d = _swig_new_instance_method(_GeomInt.GeomInt_IntSS_Pnt2d)
    Point = _swig_new_instance_method(_GeomInt.GeomInt_IntSS_Point)
    TolReached2d = _swig_new_instance_method(_GeomInt.GeomInt_IntSS_TolReached2d)
    TolReached3d = _swig_new_instance_method(_GeomInt.GeomInt_IntSS_TolReached3d)
    TreatRLine = _swig_new_static_method(_GeomInt.GeomInt_IntSS_TreatRLine)
    TrimILineOnSurfBoundaries = _swig_new_static_method(_GeomInt.GeomInt_IntSS_TrimILineOnSurfBoundaries)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_IntSS

# Register GeomInt_IntSS in _GeomInt:
_GeomInt.GeomInt_IntSS_swigregister(GeomInt_IntSS)
GeomInt_IntSS_BuildPCurves = _GeomInt.GeomInt_IntSS_BuildPCurves
GeomInt_IntSS_MakeBSpline = _GeomInt.GeomInt_IntSS_MakeBSpline
GeomInt_IntSS_MakeBSpline2d = _GeomInt.GeomInt_IntSS_MakeBSpline2d
GeomInt_IntSS_TreatRLine = _GeomInt.GeomInt_IntSS_TreatRLine
GeomInt_IntSS_TrimILineOnSurfBoundaries = _GeomInt.GeomInt_IntSS_TrimILineOnSurfBoundaries

class GeomInt_LineConstructor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Empty constructor
        	:rtype: None
        """
        _GeomInt.GeomInt_LineConstructor_swiginit(self, _GeomInt.new_GeomInt_LineConstructor(*args))
    IsDone = _swig_new_instance_method(_GeomInt.GeomInt_LineConstructor_IsDone)
    Load = _swig_new_instance_method(_GeomInt.GeomInt_LineConstructor_Load)
    NbParts = _swig_new_instance_method(_GeomInt.GeomInt_LineConstructor_NbParts)
    Part = _swig_new_instance_method(_GeomInt.GeomInt_LineConstructor_Part)
    Perform = _swig_new_instance_method(_GeomInt.GeomInt_LineConstructor_Perform)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_LineConstructor

# Register GeomInt_LineConstructor in _GeomInt:
_GeomInt.GeomInt_LineConstructor_swigregister(GeomInt_LineConstructor)

class GeomInt_LineTool(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DecompositionOfWLine = _swig_new_static_method(_GeomInt.GeomInt_LineTool_DecompositionOfWLine)
    FirstParameter = _swig_new_static_method(_GeomInt.GeomInt_LineTool_FirstParameter)
    LastParameter = _swig_new_static_method(_GeomInt.GeomInt_LineTool_LastParameter)
    NbVertex = _swig_new_static_method(_GeomInt.GeomInt_LineTool_NbVertex)
    Vertex = _swig_new_static_method(_GeomInt.GeomInt_LineTool_Vertex)

    __repr__ = _dumps_object


    def __init__(self):
        _GeomInt.GeomInt_LineTool_swiginit(self, _GeomInt.new_GeomInt_LineTool())
    __swig_destroy__ = _GeomInt.delete_GeomInt_LineTool

# Register GeomInt_LineTool in _GeomInt:
_GeomInt.GeomInt_LineTool_swigregister(GeomInt_LineTool)
GeomInt_LineTool_DecompositionOfWLine = _GeomInt.GeomInt_LineTool_DecompositionOfWLine
GeomInt_LineTool_FirstParameter = _GeomInt.GeomInt_LineTool_FirstParameter
GeomInt_LineTool_LastParameter = _GeomInt.GeomInt_LineTool_LastParameter
GeomInt_LineTool_NbVertex = _GeomInt.GeomInt_LineTool_NbVertex
GeomInt_LineTool_Vertex = _GeomInt.GeomInt_LineTool_Vertex

class GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    AverageError = _swig_new_instance_method(_GeomInt.GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox_AverageError)
    Error = _swig_new_instance_method(_GeomInt.GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox_Error)

    def __init__(self, *args):
        r"""
        * Tries to minimize the sum (square(||Qui - Bi*Pi||)) where Pui describe the approximating BSpline curves'Poles and Qi the MultiLine points with a parameter ui. In this algorithm, the parameters ui are the unknowns. The tolerance required on this sum is given by Tol. The desired degree of the resulting curve is Deg.
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param Deg:
        	:type Deg: int
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tol2d:
        	:type Tol2d: float
        	:param NbIterations: default value is 1
        	:type NbIterations: int
        	:rtype: None* Tries to minimize the sum (square(||Qui - Bi*Pi||)) where Pui describe the approximating BSpline curves'Poles and Qi the MultiLine points with a parameter ui. In this algorithm, the parameters ui are the unknowns. The tolerance required on this sum is given by Tol. The desired degree of the resulting curve is Deg.
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param Deg:
        	:type Deg: int
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tol2d:
        	:type Tol2d: float
        	:param NbIterations:
        	:type NbIterations: int
        	:param lambda1:
        	:type lambda1: float
        	:param lambda2:
        	:type lambda2: float
        	:rtype: None
        """
        _GeomInt.GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox(*args))
    IsDone = _swig_new_instance_method(_GeomInt.GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox_IsDone)
    MaxError2d = _swig_new_instance_method(_GeomInt.GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox_MaxError2d)
    MaxError3d = _swig_new_instance_method(_GeomInt.GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox_MaxError3d)
    Value = _swig_new_instance_method(_GeomInt.GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox_Value)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox

# Register GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox in _GeomInt:
_GeomInt.GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox_swigregister(GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox)

class GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    AverageError = _swig_new_instance_method(_GeomInt.GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox_AverageError)
    Error = _swig_new_instance_method(_GeomInt.GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox_Error)

    def __init__(self, *args):
        r"""
        * Tries to minimize the sum (square(||Qui - Bi*Pi||)) where Pui describe the approximating Bezier curves'Poles and Qi the MultiLine points with a parameter ui. In this algorithm, the parameters ui are the unknowns. The tolerance required on this sum is given by Tol. The desired degree of the resulting curve is Deg.
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tol2d:
        	:type Tol2d: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:rtype: None
        """
        _GeomInt.GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox(*args))
    IsDone = _swig_new_instance_method(_GeomInt.GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox_IsDone)
    MaxError2d = _swig_new_instance_method(_GeomInt.GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox_MaxError2d)
    MaxError3d = _swig_new_instance_method(_GeomInt.GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox_MaxError3d)
    Value = _swig_new_instance_method(_GeomInt.GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox_Value)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox

# Register GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox in _GeomInt:
_GeomInt.GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox_swigregister(GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox)

class GeomInt_MyGradientbisOfTheComputeLineOfWLApprox(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    AverageError = _swig_new_instance_method(_GeomInt.GeomInt_MyGradientbisOfTheComputeLineOfWLApprox_AverageError)
    Error = _swig_new_instance_method(_GeomInt.GeomInt_MyGradientbisOfTheComputeLineOfWLApprox_Error)

    def __init__(self, *args):
        r"""
        * Tries to minimize the sum (square(||Qui - Bi*Pi||)) where Pui describe the approximating Bezier curves'Poles and Qi the MultiLine points with a parameter ui. In this algorithm, the parameters ui are the unknowns. The tolerance required on this sum is given by Tol. The desired degree of the resulting curve is Deg.
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tol2d:
        	:type Tol2d: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:rtype: None
        """
        _GeomInt.GeomInt_MyGradientbisOfTheComputeLineOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_MyGradientbisOfTheComputeLineOfWLApprox(*args))
    IsDone = _swig_new_instance_method(_GeomInt.GeomInt_MyGradientbisOfTheComputeLineOfWLApprox_IsDone)
    MaxError2d = _swig_new_instance_method(_GeomInt.GeomInt_MyGradientbisOfTheComputeLineOfWLApprox_MaxError2d)
    MaxError3d = _swig_new_instance_method(_GeomInt.GeomInt_MyGradientbisOfTheComputeLineOfWLApprox_MaxError3d)
    Value = _swig_new_instance_method(_GeomInt.GeomInt_MyGradientbisOfTheComputeLineOfWLApprox_Value)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_MyGradientbisOfTheComputeLineOfWLApprox

# Register GeomInt_MyGradientbisOfTheComputeLineOfWLApprox in _GeomInt:
_GeomInt.GeomInt_MyGradientbisOfTheComputeLineOfWLApprox_swigregister(GeomInt_MyGradientbisOfTheComputeLineOfWLApprox)

class GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox(OCC.Core.math.math_MultipleVarFunctionWithGradient):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    CurveValue = _swig_new_instance_method(_GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_CurveValue)
    Error = _swig_new_instance_method(_GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_Error)
    FirstConstraint = _swig_new_instance_method(_GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_FirstConstraint)

    def __init__(self, *args):
        r"""
        * initializes the fields of the function. The approximating curve has the desired degree Deg.
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:rtype: None
        """
        _GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox(*args))
    LastConstraint = _swig_new_instance_method(_GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_LastConstraint)
    MaxError2d = _swig_new_instance_method(_GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_MaxError2d)
    MaxError3d = _swig_new_instance_method(_GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_MaxError3d)
    NewParameters = _swig_new_instance_method(_GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_NewParameters)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox

# Register GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox in _GeomInt:
_GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_swigregister(GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox)

class GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox(OCC.Core.math.math_MultipleVarFunctionWithGradient):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    CurveValue = _swig_new_instance_method(_GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_CurveValue)
    Error = _swig_new_instance_method(_GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_Error)
    FirstConstraint = _swig_new_instance_method(_GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_FirstConstraint)

    def __init__(self, *args):
        r"""
        * initializes the fields of the function. The approximating curve has the desired degree Deg.
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:rtype: None
        """
        _GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox(*args))
    LastConstraint = _swig_new_instance_method(_GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_LastConstraint)
    MaxError2d = _swig_new_instance_method(_GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_MaxError2d)
    MaxError3d = _swig_new_instance_method(_GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_MaxError3d)
    NewParameters = _swig_new_instance_method(_GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_NewParameters)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox

# Register GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox in _GeomInt:
_GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_swigregister(GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox)

class GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    BSplineValue = _swig_new_instance_method(_GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_BSplineValue)
    BezierValue = _swig_new_instance_method(_GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_BezierValue)
    DerivativeFunctionMatrix = _swig_new_instance_method(_GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_DerivativeFunctionMatrix)
    Distance = _swig_new_instance_method(_GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_Distance)
    Error = _swig_new_instance_method(_GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_Error)
    ErrorGradient = _swig_new_instance_method(_GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_ErrorGradient)
    FirstLambda = _swig_new_instance_method(_GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_FirstLambda)
    FunctionMatrix = _swig_new_instance_method(_GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_FunctionMatrix)

    def __init__(self, *args):
        r"""
        * given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. NbPol is the number of control points wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the Bernstein matrix computed with the parameters, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None* Initializes the fields of the object.
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None* given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. Deg is the degree wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the BSpline functions matrix computed with <parameters>, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None* Initializes the fields of the object.
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        """
        _GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox(*args))
    IsDone = _swig_new_instance_method(_GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_IsDone)
    KIndex = _swig_new_instance_method(_GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_KIndex)
    LastLambda = _swig_new_instance_method(_GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_LastLambda)
    Perform = _swig_new_instance_method(_GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_Perform)
    Points = _swig_new_instance_method(_GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_Points)
    Poles = _swig_new_instance_method(_GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_Poles)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox

# Register GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox in _GeomInt:
_GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_swigregister(GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox)

class GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    BSplineValue = _swig_new_instance_method(_GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_BSplineValue)
    BezierValue = _swig_new_instance_method(_GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_BezierValue)
    DerivativeFunctionMatrix = _swig_new_instance_method(_GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_DerivativeFunctionMatrix)
    Distance = _swig_new_instance_method(_GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_Distance)
    Error = _swig_new_instance_method(_GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_Error)
    ErrorGradient = _swig_new_instance_method(_GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_ErrorGradient)
    FirstLambda = _swig_new_instance_method(_GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_FirstLambda)
    FunctionMatrix = _swig_new_instance_method(_GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_FunctionMatrix)

    def __init__(self, *args):
        r"""
        * given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. NbPol is the number of control points wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the Bernstein matrix computed with the parameters, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None* Initializes the fields of the object.
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None* given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. Deg is the degree wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the BSpline functions matrix computed with <parameters>, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None* Initializes the fields of the object.
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        """
        _GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox(*args))
    IsDone = _swig_new_instance_method(_GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_IsDone)
    KIndex = _swig_new_instance_method(_GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_KIndex)
    LastLambda = _swig_new_instance_method(_GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_LastLambda)
    Perform = _swig_new_instance_method(_GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_Perform)
    Points = _swig_new_instance_method(_GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_Points)
    Poles = _swig_new_instance_method(_GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_Poles)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox

# Register GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox in _GeomInt:
_GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_swigregister(GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox)

class GeomInt_ParameterAndOrientation(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        :rtype: None:param P:
        	:type P: float
        	:param Or1:
        	:type Or1: TopAbs_Orientation
        	:param Or2:
        	:type Or2: TopAbs_Orientation
        	:rtype: None
        """
        _GeomInt.GeomInt_ParameterAndOrientation_swiginit(self, _GeomInt.new_GeomInt_ParameterAndOrientation(*args))
    Orientation1 = _swig_new_instance_method(_GeomInt.GeomInt_ParameterAndOrientation_Orientation1)
    Orientation2 = _swig_new_instance_method(_GeomInt.GeomInt_ParameterAndOrientation_Orientation2)
    Parameter = _swig_new_instance_method(_GeomInt.GeomInt_ParameterAndOrientation_Parameter)
    SetOrientation1 = _swig_new_instance_method(_GeomInt.GeomInt_ParameterAndOrientation_SetOrientation1)
    SetOrientation2 = _swig_new_instance_method(_GeomInt.GeomInt_ParameterAndOrientation_SetOrientation2)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_ParameterAndOrientation

# Register GeomInt_ParameterAndOrientation in _GeomInt:
_GeomInt.GeomInt_ParameterAndOrientation_swigregister(GeomInt_ParameterAndOrientation)

class GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ConstraintDerivative = _swig_new_instance_method(_GeomInt.GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox_ConstraintDerivative)
    ConstraintMatrix = _swig_new_instance_method(_GeomInt.GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox_ConstraintMatrix)
    Duale = _swig_new_instance_method(_GeomInt.GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox_Duale)

    def __init__(self, *args):
        r"""
        * Given a MultiLine SSP with constraints points, this algorithm finds the best curve solution to approximate it. The poles from SCurv issued for example from the least squares are used as a guess solution for the uzawa algorithm. The tolerance used in the Uzawa algorithms is Tolerance. A is the Bernstein matrix associated to the MultiLine and DA is the derivative bernstein matrix.(They can come from an approximation with ParLeastSquare.) The MultiCurve is modified. New MultiPoles are given.
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param SCurv:
        	:type SCurv: AppParCurves_MultiCurve
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param Constraints:
        	:type Constraints: AppParCurves_HArray1OfConstraintCouple
        	:param Bern:
        	:type Bern: math_Matrix
        	:param DerivativeBern:
        	:type DerivativeBern: math_Matrix
        	:param Tolerance: default value is 1.0e-10
        	:type Tolerance: float
        	:rtype: None
        """
        _GeomInt.GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox(*args))
    InverseMatrix = _swig_new_instance_method(_GeomInt.GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox_InverseMatrix)
    IsDone = _swig_new_instance_method(_GeomInt.GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox_IsDone)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox

# Register GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox in _GeomInt:
_GeomInt.GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox_swigregister(GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox)

class GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ConstraintDerivative = _swig_new_instance_method(_GeomInt.GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox_ConstraintDerivative)
    ConstraintMatrix = _swig_new_instance_method(_GeomInt.GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox_ConstraintMatrix)
    Duale = _swig_new_instance_method(_GeomInt.GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox_Duale)

    def __init__(self, *args):
        r"""
        * Given a MultiLine SSP with constraints points, this algorithm finds the best curve solution to approximate it. The poles from SCurv issued for example from the least squares are used as a guess solution for the uzawa algorithm. The tolerance used in the Uzawa algorithms is Tolerance. A is the Bernstein matrix associated to the MultiLine and DA is the derivative bernstein matrix.(They can come from an approximation with ParLeastSquare.) The MultiCurve is modified. New MultiPoles are given.
        	:param SSP:
        	:type SSP: GeomInt_TheMultiLineOfWLApprox
        	:param SCurv:
        	:type SCurv: AppParCurves_MultiCurve
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param Constraints:
        	:type Constraints: AppParCurves_HArray1OfConstraintCouple
        	:param Bern:
        	:type Bern: math_Matrix
        	:param DerivativeBern:
        	:type DerivativeBern: math_Matrix
        	:param Tolerance: default value is 1.0e-10
        	:type Tolerance: float
        	:rtype: None
        """
        _GeomInt.GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox(*args))
    InverseMatrix = _swig_new_instance_method(_GeomInt.GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox_InverseMatrix)
    IsDone = _swig_new_instance_method(_GeomInt.GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox_IsDone)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox

# Register GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox in _GeomInt:
_GeomInt.GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox_swigregister(GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox)

class GeomInt_TheComputeLineBezierOfWLApprox(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ChangeValue = _swig_new_instance_method(_GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_ChangeValue)
    Error = _swig_new_instance_method(_GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_Error)

    def __init__(self, *args):
        r"""
        * The MultiLine <Line> will be approximated until tolerances will be reached. The approximation will be done from degreemin to degreemax with a cutting if the corresponding boolean is True. If <Squares> is True, the computation will be done with no iteration at all.
        	:param Line:
        	:type Line: GeomInt_TheMultiLineOfWLApprox
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-3
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-6
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param parametrization: default value is Approx_ChordLength
        	:type parametrization: Approx_ParametrizationType
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None* The MultiLine <Line> will be approximated until tolerances will be reached. The approximation will be done from degreemin to degreemax with a cutting if the corresponding boolean is True. If <Squares> is True, the computation will be done with no iteration at all.
        	:param Line:
        	:type Line: GeomInt_TheMultiLineOfWLApprox
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None* Initializes the fields of the algorithm.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None* Initializes the fields of the algorithm.
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param parametrization: default value is Approx_ChordLength
        	:type parametrization: Approx_ParametrizationType
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        """
        _GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_TheComputeLineBezierOfWLApprox(*args))
    Init = _swig_new_instance_method(_GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_Init)
    IsAllApproximated = _swig_new_instance_method(_GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_IsAllApproximated)
    IsToleranceReached = _swig_new_instance_method(_GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_IsToleranceReached)
    NbMultiCurves = _swig_new_instance_method(_GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_NbMultiCurves)
    Parameters = _swig_new_instance_method(_GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_Parameters)
    Parametrization = _swig_new_instance_method(_GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_Parametrization)
    Perform = _swig_new_instance_method(_GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_Perform)
    SetConstraints = _swig_new_instance_method(_GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_SetConstraints)
    SetDegrees = _swig_new_instance_method(_GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_SetDegrees)
    SetTolerances = _swig_new_instance_method(_GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_SetTolerances)
    SplineValue = _swig_new_instance_method(_GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_SplineValue)
    Value = _swig_new_instance_method(_GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_Value)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_TheComputeLineBezierOfWLApprox

# Register GeomInt_TheComputeLineBezierOfWLApprox in _GeomInt:
_GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_swigregister(GeomInt_TheComputeLineBezierOfWLApprox)

class GeomInt_TheComputeLineOfWLApprox(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ChangeValue = _swig_new_instance_method(_GeomInt.GeomInt_TheComputeLineOfWLApprox_ChangeValue)
    Error = _swig_new_instance_method(_GeomInt.GeomInt_TheComputeLineOfWLApprox_Error)

    def __init__(self, *args):
        r"""
        * The MultiLine <Line> will be approximated until tolerances will be reached. The approximation will be done from degreemin to degreemax with a cutting if the corresponding boolean is True. If <Squares> is True, the computation will be done with no iteration at all. //! The multiplicities of the internal knots is set by default.
        	:param Line:
        	:type Line: GeomInt_TheMultiLineOfWLApprox
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-3
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-6
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param parametrization: default value is Approx_ChordLength
        	:type parametrization: Approx_ParametrizationType
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None* The MultiLine <Line> will be approximated until tolerances will be reached. The approximation will be done from degreemin to degreemax with a cutting if the corresponding boolean is True. If <Squares> is True, the computation will be done with no iteration at all.
        	:param Line:
        	:type Line: GeomInt_TheMultiLineOfWLApprox
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None* Initializes the fields of the algorithm.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None* Initializes the fields of the algorithm.
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param parametrization: default value is Approx_ChordLength
        	:type parametrization: Approx_ParametrizationType
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        """
        _GeomInt.GeomInt_TheComputeLineOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_TheComputeLineOfWLApprox(*args))
    Init = _swig_new_instance_method(_GeomInt.GeomInt_TheComputeLineOfWLApprox_Init)
    Interpol = _swig_new_instance_method(_GeomInt.GeomInt_TheComputeLineOfWLApprox_Interpol)
    IsAllApproximated = _swig_new_instance_method(_GeomInt.GeomInt_TheComputeLineOfWLApprox_IsAllApproximated)
    IsToleranceReached = _swig_new_instance_method(_GeomInt.GeomInt_TheComputeLineOfWLApprox_IsToleranceReached)
    Parameters = _swig_new_instance_method(_GeomInt.GeomInt_TheComputeLineOfWLApprox_Parameters)
    Perform = _swig_new_instance_method(_GeomInt.GeomInt_TheComputeLineOfWLApprox_Perform)
    SetConstraints = _swig_new_instance_method(_GeomInt.GeomInt_TheComputeLineOfWLApprox_SetConstraints)
    SetContinuity = _swig_new_instance_method(_GeomInt.GeomInt_TheComputeLineOfWLApprox_SetContinuity)
    SetDegrees = _swig_new_instance_method(_GeomInt.GeomInt_TheComputeLineOfWLApprox_SetDegrees)
    SetKnots = _swig_new_instance_method(_GeomInt.GeomInt_TheComputeLineOfWLApprox_SetKnots)
    SetKnotsAndMultiplicities = _swig_new_instance_method(_GeomInt.GeomInt_TheComputeLineOfWLApprox_SetKnotsAndMultiplicities)
    SetParameters = _swig_new_instance_method(_GeomInt.GeomInt_TheComputeLineOfWLApprox_SetParameters)
    SetPeriodic = _swig_new_instance_method(_GeomInt.GeomInt_TheComputeLineOfWLApprox_SetPeriodic)
    SetTolerances = _swig_new_instance_method(_GeomInt.GeomInt_TheComputeLineOfWLApprox_SetTolerances)
    Value = _swig_new_instance_method(_GeomInt.GeomInt_TheComputeLineOfWLApprox_Value)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_TheComputeLineOfWLApprox

# Register GeomInt_TheComputeLineOfWLApprox in _GeomInt:
_GeomInt.GeomInt_TheComputeLineOfWLApprox_swigregister(GeomInt_TheComputeLineOfWLApprox)

class GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox(OCC.Core.math.math_FunctionSetWithDerivatives):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    AuxillarSurface1 = _swig_new_instance_method(_GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_AuxillarSurface1)
    AuxillarSurface2 = _swig_new_instance_method(_GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_AuxillarSurface2)
    ComputeParameters = _swig_new_instance_method(_GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_ComputeParameters)
    Direction = _swig_new_instance_method(_GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_Direction)
    DirectionOnS1 = _swig_new_instance_method(_GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_DirectionOnS1)
    DirectionOnS2 = _swig_new_instance_method(_GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_DirectionOnS2)

    def __init__(self, *args):
        r"""
        :param S1:
        	:type S1: Adaptor3d_HSurface
        	:param S2:
        	:type S2: Adaptor3d_HSurface
        	:rtype: None
        """
        _GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox(*args))
    IsTangent = _swig_new_instance_method(_GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_IsTangent)
    Point = _swig_new_instance_method(_GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_Point)
    Root = _swig_new_instance_method(_GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_Root)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox

# Register GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox in _GeomInt:
_GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_swigregister(GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox)

class GeomInt_TheImpPrmSvSurfacesOfWLApprox(OCC.Core.ApproxInt.ApproxInt_SvSurfaces):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        :param Surf1:
        	:type Surf1: Adaptor3d_HSurface
        	:param Surf2:
        	:type Surf2: IntSurf_Quadric
        	:rtype: None:param Surf1:
        	:type Surf1: IntSurf_Quadric
        	:param Surf2:
        	:type Surf2: Adaptor3d_HSurface
        	:rtype: None
        """
        _GeomInt.GeomInt_TheImpPrmSvSurfacesOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_TheImpPrmSvSurfacesOfWLApprox(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_TheImpPrmSvSurfacesOfWLApprox

# Register GeomInt_TheImpPrmSvSurfacesOfWLApprox in _GeomInt:
_GeomInt.GeomInt_TheImpPrmSvSurfacesOfWLApprox_swigregister(GeomInt_TheImpPrmSvSurfacesOfWLApprox)

class GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ChangePoint = _swig_new_instance_method(_GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_ChangePoint)
    Direction = _swig_new_instance_method(_GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_Direction)
    DirectionOnS1 = _swig_new_instance_method(_GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_DirectionOnS1)
    DirectionOnS2 = _swig_new_instance_method(_GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_DirectionOnS2)
    Function = _swig_new_instance_method(_GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_Function)

    def __init__(self, *args):
        r"""
        * compute the solution point with the close point
        	:param Param:
        	:type Param: TColStd_Array1OfReal
        	:param S1:
        	:type S1: Adaptor3d_HSurface
        	:param S2:
        	:type S2: Adaptor3d_HSurface
        	:param TolTangency:
        	:type TolTangency: float
        	:rtype: None* initialize the parameters to compute the solution point it 's possible to write to optimize: IntImp_Int2S inter(S1,S2,Func,TolTangency); math_FunctionSetRoot rsnld(inter.Function()); while ...{ Param(1)=... Param(2)=... param(3)=... inter.Perform(Param,rsnld); }
        	:param S1:
        	:type S1: Adaptor3d_HSurface
        	:param S2:
        	:type S2: Adaptor3d_HSurface
        	:param TolTangency:
        	:type TolTangency: float
        	:rtype: None
        """
        _GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox(*args))
    IsDone = _swig_new_instance_method(_GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_IsDone)
    IsEmpty = _swig_new_instance_method(_GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_IsEmpty)
    IsTangent = _swig_new_instance_method(_GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_IsTangent)
    Perform = _swig_new_instance_method(_GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_Perform)
    Point = _swig_new_instance_method(_GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_Point)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox

# Register GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox in _GeomInt:
_GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_swigregister(GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox)

class GeomInt_TheMultiLineOfWLApprox(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Dump = _swig_new_instance_method(_GeomInt.GeomInt_TheMultiLineOfWLApprox_Dump)
    FirstPoint = _swig_new_instance_method(_GeomInt.GeomInt_TheMultiLineOfWLApprox_FirstPoint)

    def __init__(self, *args):
        r"""
        :rtype: None* The class SvSurfaces is used when the approximation algorithm needs some extra points on the line <line>. A New line is then created which shares the same surfaces and functions. SvSurfaces is a deferred class which allows several implementations of this algorithm with different surfaces (bi-parametric ones, or implicit and biparametric ones)
        	:param line:
        	:type line: IntPatch_WLine
        	:param PtrSvSurfaces:
        	:type PtrSvSurfaces: Standard_Address
        	:param NbP3d:
        	:type NbP3d: int
        	:param NbP2d:
        	:type NbP2d: int
        	:param ApproxU1V1:
        	:type ApproxU1V1: bool
        	:param ApproxU2V2:
        	:type ApproxU2V2: bool
        	:param xo:
        	:type xo: float
        	:param yo:
        	:type yo: float
        	:param zo:
        	:type zo: float
        	:param u1o:
        	:type u1o: float
        	:param v1o:
        	:type v1o: float
        	:param u2o:
        	:type u2o: float
        	:param v2o:
        	:type v2o: float
        	:param P2DOnFirst:
        	:type P2DOnFirst: bool
        	:param IndMin: default value is 0
        	:type IndMin: int
        	:param IndMax: default value is 0
        	:type IndMax: int
        	:rtype: None* No Extra points will be added on the current line
        	:param line:
        	:type line: IntPatch_WLine
        	:param NbP3d:
        	:type NbP3d: int
        	:param NbP2d:
        	:type NbP2d: int
        	:param ApproxU1V1:
        	:type ApproxU1V1: bool
        	:param ApproxU2V2:
        	:type ApproxU2V2: bool
        	:param xo:
        	:type xo: float
        	:param yo:
        	:type yo: float
        	:param zo:
        	:type zo: float
        	:param u1o:
        	:type u1o: float
        	:param v1o:
        	:type v1o: float
        	:param u2o:
        	:type u2o: float
        	:param v2o:
        	:type v2o: float
        	:param P2DOnFirst:
        	:type P2DOnFirst: bool
        	:param IndMin: default value is 0
        	:type IndMin: int
        	:param IndMax: default value is 0
        	:type IndMax: int
        	:rtype: None
        """
        _GeomInt.GeomInt_TheMultiLineOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_TheMultiLineOfWLApprox(*args))
    LastPoint = _swig_new_instance_method(_GeomInt.GeomInt_TheMultiLineOfWLApprox_LastPoint)
    MakeMLBetween = _swig_new_instance_method(_GeomInt.GeomInt_TheMultiLineOfWLApprox_MakeMLBetween)
    MakeMLOneMorePoint = _swig_new_instance_method(_GeomInt.GeomInt_TheMultiLineOfWLApprox_MakeMLOneMorePoint)
    NbP2d = _swig_new_instance_method(_GeomInt.GeomInt_TheMultiLineOfWLApprox_NbP2d)
    NbP3d = _swig_new_instance_method(_GeomInt.GeomInt_TheMultiLineOfWLApprox_NbP3d)
    Tangency = _swig_new_instance_method(_GeomInt.GeomInt_TheMultiLineOfWLApprox_Tangency)
    Value = _swig_new_instance_method(_GeomInt.GeomInt_TheMultiLineOfWLApprox_Value)
    WhatStatus = _swig_new_instance_method(_GeomInt.GeomInt_TheMultiLineOfWLApprox_WhatStatus)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_TheMultiLineOfWLApprox

# Register GeomInt_TheMultiLineOfWLApprox in _GeomInt:
_GeomInt.GeomInt_TheMultiLineOfWLApprox_swigregister(GeomInt_TheMultiLineOfWLApprox)

class GeomInt_TheMultiLineToolOfWLApprox(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Curvature = _swig_new_static_method(_GeomInt.GeomInt_TheMultiLineToolOfWLApprox_Curvature)
    Dump = _swig_new_static_method(_GeomInt.GeomInt_TheMultiLineToolOfWLApprox_Dump)
    FirstPoint = _swig_new_static_method(_GeomInt.GeomInt_TheMultiLineToolOfWLApprox_FirstPoint)
    LastPoint = _swig_new_static_method(_GeomInt.GeomInt_TheMultiLineToolOfWLApprox_LastPoint)
    MakeMLBetween = _swig_new_static_method(_GeomInt.GeomInt_TheMultiLineToolOfWLApprox_MakeMLBetween)
    MakeMLOneMorePoint = _swig_new_static_method(_GeomInt.GeomInt_TheMultiLineToolOfWLApprox_MakeMLOneMorePoint)
    NbP2d = _swig_new_static_method(_GeomInt.GeomInt_TheMultiLineToolOfWLApprox_NbP2d)
    NbP3d = _swig_new_static_method(_GeomInt.GeomInt_TheMultiLineToolOfWLApprox_NbP3d)
    Tangency = _swig_new_static_method(_GeomInt.GeomInt_TheMultiLineToolOfWLApprox_Tangency)
    Value = _swig_new_static_method(_GeomInt.GeomInt_TheMultiLineToolOfWLApprox_Value)
    WhatStatus = _swig_new_static_method(_GeomInt.GeomInt_TheMultiLineToolOfWLApprox_WhatStatus)

    __repr__ = _dumps_object


    def __init__(self):
        _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_TheMultiLineToolOfWLApprox())
    __swig_destroy__ = _GeomInt.delete_GeomInt_TheMultiLineToolOfWLApprox

# Register GeomInt_TheMultiLineToolOfWLApprox in _GeomInt:
_GeomInt.GeomInt_TheMultiLineToolOfWLApprox_swigregister(GeomInt_TheMultiLineToolOfWLApprox)
GeomInt_TheMultiLineToolOfWLApprox_Curvature = _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_Curvature
GeomInt_TheMultiLineToolOfWLApprox_Dump = _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_Dump
GeomInt_TheMultiLineToolOfWLApprox_FirstPoint = _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_FirstPoint
GeomInt_TheMultiLineToolOfWLApprox_LastPoint = _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_LastPoint
GeomInt_TheMultiLineToolOfWLApprox_MakeMLBetween = _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_MakeMLBetween
GeomInt_TheMultiLineToolOfWLApprox_MakeMLOneMorePoint = _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_MakeMLOneMorePoint
GeomInt_TheMultiLineToolOfWLApprox_NbP2d = _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_NbP2d
GeomInt_TheMultiLineToolOfWLApprox_NbP3d = _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_NbP3d
GeomInt_TheMultiLineToolOfWLApprox_Tangency = _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_Tangency
GeomInt_TheMultiLineToolOfWLApprox_Value = _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_Value
GeomInt_TheMultiLineToolOfWLApprox_WhatStatus = _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_WhatStatus

class GeomInt_ThePrmPrmSvSurfacesOfWLApprox(OCC.Core.ApproxInt.ApproxInt_SvSurfaces):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        :param Surf1:
        	:type Surf1: Adaptor3d_HSurface
        	:param Surf2:
        	:type Surf2: Adaptor3d_HSurface
        	:rtype: None
        """
        _GeomInt.GeomInt_ThePrmPrmSvSurfacesOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_ThePrmPrmSvSurfacesOfWLApprox(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_ThePrmPrmSvSurfacesOfWLApprox

# Register GeomInt_ThePrmPrmSvSurfacesOfWLApprox in _GeomInt:
_GeomInt.GeomInt_ThePrmPrmSvSurfacesOfWLApprox_swigregister(GeomInt_ThePrmPrmSvSurfacesOfWLApprox)

class GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox(OCC.Core.math.math_FunctionSetWithDerivatives):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Direction2d = _swig_new_instance_method(_GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_Direction2d)
    Direction3d = _swig_new_instance_method(_GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_Direction3d)

    def __init__(self, *args):
        r"""
        :rtype: None:param PS:
        	:type PS: Adaptor3d_HSurface
        	:param IS:
        	:type IS: IntSurf_Quadric
        	:rtype: None:param IS:
        	:type IS: IntSurf_Quadric
        	:rtype: None
        """
        _GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_swiginit(self, _GeomInt.new_GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox(*args))
    ISurface = _swig_new_instance_method(_GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_ISurface)
    IsTangent = _swig_new_instance_method(_GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_IsTangent)
    PSurface = _swig_new_instance_method(_GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_PSurface)
    Point = _swig_new_instance_method(_GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_Point)
    Root = _swig_new_instance_method(_GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_Root)
    Set = _swig_new_instance_method(_GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_Set)
    SetImplicitSurface = _swig_new_instance_method(_GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_SetImplicitSurface)
    Tolerance = _swig_new_instance_method(_GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_Tolerance)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomInt.delete_GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox

# Register GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox in _GeomInt:
_GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_swigregister(GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox)



