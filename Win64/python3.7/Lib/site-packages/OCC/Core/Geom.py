# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
Geom module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_geom.html
"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _Geom
else:
    import _Geom

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _Geom.SWIG_PyInstanceMethod_New
_swig_new_static_method = _Geom.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Geom.delete_SwigPyIterator
    value = _swig_new_instance_method(_Geom.SwigPyIterator_value)
    incr = _swig_new_instance_method(_Geom.SwigPyIterator_incr)
    decr = _swig_new_instance_method(_Geom.SwigPyIterator_decr)
    distance = _swig_new_instance_method(_Geom.SwigPyIterator_distance)
    equal = _swig_new_instance_method(_Geom.SwigPyIterator_equal)
    copy = _swig_new_instance_method(_Geom.SwigPyIterator_copy)
    next = _swig_new_instance_method(_Geom.SwigPyIterator_next)
    __next__ = _swig_new_instance_method(_Geom.SwigPyIterator___next__)
    previous = _swig_new_instance_method(_Geom.SwigPyIterator_previous)
    advance = _swig_new_instance_method(_Geom.SwigPyIterator_advance)
    __eq__ = _swig_new_instance_method(_Geom.SwigPyIterator___eq__)
    __ne__ = _swig_new_instance_method(_Geom.SwigPyIterator___ne__)
    __iadd__ = _swig_new_instance_method(_Geom.SwigPyIterator___iadd__)
    __isub__ = _swig_new_instance_method(_Geom.SwigPyIterator___isub__)
    __add__ = _swig_new_instance_method(_Geom.SwigPyIterator___add__)
    __sub__ = _swig_new_instance_method(_Geom.SwigPyIterator___sub__)
    def __iter__(self):
        return self

# Register SwigPyIterator in _Geom:
_Geom.SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.gp
import OCC.Core.GeomAbs
import OCC.Core.TColgp
import OCC.Core.TColStd
import OCC.Core.TCollection
Handle_Geom_Geometry_Create = _Geom.Handle_Geom_Geometry_Create
Handle_Geom_Geometry_DownCast = _Geom.Handle_Geom_Geometry_DownCast
Handle_Geom_Geometry_IsNull = _Geom.Handle_Geom_Geometry_IsNull
Handle_Geom_OsculatingSurface_Create = _Geom.Handle_Geom_OsculatingSurface_Create
Handle_Geom_OsculatingSurface_DownCast = _Geom.Handle_Geom_OsculatingSurface_DownCast
Handle_Geom_OsculatingSurface_IsNull = _Geom.Handle_Geom_OsculatingSurface_IsNull
Handle_Geom_Transformation_Create = _Geom.Handle_Geom_Transformation_Create
Handle_Geom_Transformation_DownCast = _Geom.Handle_Geom_Transformation_DownCast
Handle_Geom_Transformation_IsNull = _Geom.Handle_Geom_Transformation_IsNull
Handle_Geom_AxisPlacement_Create = _Geom.Handle_Geom_AxisPlacement_Create
Handle_Geom_AxisPlacement_DownCast = _Geom.Handle_Geom_AxisPlacement_DownCast
Handle_Geom_AxisPlacement_IsNull = _Geom.Handle_Geom_AxisPlacement_IsNull
Handle_Geom_Curve_Create = _Geom.Handle_Geom_Curve_Create
Handle_Geom_Curve_DownCast = _Geom.Handle_Geom_Curve_DownCast
Handle_Geom_Curve_IsNull = _Geom.Handle_Geom_Curve_IsNull
Handle_Geom_Point_Create = _Geom.Handle_Geom_Point_Create
Handle_Geom_Point_DownCast = _Geom.Handle_Geom_Point_DownCast
Handle_Geom_Point_IsNull = _Geom.Handle_Geom_Point_IsNull
Handle_Geom_Surface_Create = _Geom.Handle_Geom_Surface_Create
Handle_Geom_Surface_DownCast = _Geom.Handle_Geom_Surface_DownCast
Handle_Geom_Surface_IsNull = _Geom.Handle_Geom_Surface_IsNull
Handle_Geom_Vector_Create = _Geom.Handle_Geom_Vector_Create
Handle_Geom_Vector_DownCast = _Geom.Handle_Geom_Vector_DownCast
Handle_Geom_Vector_IsNull = _Geom.Handle_Geom_Vector_IsNull
Handle_Geom_Axis1Placement_Create = _Geom.Handle_Geom_Axis1Placement_Create
Handle_Geom_Axis1Placement_DownCast = _Geom.Handle_Geom_Axis1Placement_DownCast
Handle_Geom_Axis1Placement_IsNull = _Geom.Handle_Geom_Axis1Placement_IsNull
Handle_Geom_Axis2Placement_Create = _Geom.Handle_Geom_Axis2Placement_Create
Handle_Geom_Axis2Placement_DownCast = _Geom.Handle_Geom_Axis2Placement_DownCast
Handle_Geom_Axis2Placement_IsNull = _Geom.Handle_Geom_Axis2Placement_IsNull
Handle_Geom_BoundedCurve_Create = _Geom.Handle_Geom_BoundedCurve_Create
Handle_Geom_BoundedCurve_DownCast = _Geom.Handle_Geom_BoundedCurve_DownCast
Handle_Geom_BoundedCurve_IsNull = _Geom.Handle_Geom_BoundedCurve_IsNull
Handle_Geom_BoundedSurface_Create = _Geom.Handle_Geom_BoundedSurface_Create
Handle_Geom_BoundedSurface_DownCast = _Geom.Handle_Geom_BoundedSurface_DownCast
Handle_Geom_BoundedSurface_IsNull = _Geom.Handle_Geom_BoundedSurface_IsNull
Handle_Geom_CartesianPoint_Create = _Geom.Handle_Geom_CartesianPoint_Create
Handle_Geom_CartesianPoint_DownCast = _Geom.Handle_Geom_CartesianPoint_DownCast
Handle_Geom_CartesianPoint_IsNull = _Geom.Handle_Geom_CartesianPoint_IsNull
Handle_Geom_Conic_Create = _Geom.Handle_Geom_Conic_Create
Handle_Geom_Conic_DownCast = _Geom.Handle_Geom_Conic_DownCast
Handle_Geom_Conic_IsNull = _Geom.Handle_Geom_Conic_IsNull
Handle_Geom_Direction_Create = _Geom.Handle_Geom_Direction_Create
Handle_Geom_Direction_DownCast = _Geom.Handle_Geom_Direction_DownCast
Handle_Geom_Direction_IsNull = _Geom.Handle_Geom_Direction_IsNull
Handle_Geom_ElementarySurface_Create = _Geom.Handle_Geom_ElementarySurface_Create
Handle_Geom_ElementarySurface_DownCast = _Geom.Handle_Geom_ElementarySurface_DownCast
Handle_Geom_ElementarySurface_IsNull = _Geom.Handle_Geom_ElementarySurface_IsNull
Handle_Geom_Line_Create = _Geom.Handle_Geom_Line_Create
Handle_Geom_Line_DownCast = _Geom.Handle_Geom_Line_DownCast
Handle_Geom_Line_IsNull = _Geom.Handle_Geom_Line_IsNull
Handle_Geom_OffsetCurve_Create = _Geom.Handle_Geom_OffsetCurve_Create
Handle_Geom_OffsetCurve_DownCast = _Geom.Handle_Geom_OffsetCurve_DownCast
Handle_Geom_OffsetCurve_IsNull = _Geom.Handle_Geom_OffsetCurve_IsNull
Handle_Geom_OffsetSurface_Create = _Geom.Handle_Geom_OffsetSurface_Create
Handle_Geom_OffsetSurface_DownCast = _Geom.Handle_Geom_OffsetSurface_DownCast
Handle_Geom_OffsetSurface_IsNull = _Geom.Handle_Geom_OffsetSurface_IsNull
Handle_Geom_SweptSurface_Create = _Geom.Handle_Geom_SweptSurface_Create
Handle_Geom_SweptSurface_DownCast = _Geom.Handle_Geom_SweptSurface_DownCast
Handle_Geom_SweptSurface_IsNull = _Geom.Handle_Geom_SweptSurface_IsNull
Handle_Geom_VectorWithMagnitude_Create = _Geom.Handle_Geom_VectorWithMagnitude_Create
Handle_Geom_VectorWithMagnitude_DownCast = _Geom.Handle_Geom_VectorWithMagnitude_DownCast
Handle_Geom_VectorWithMagnitude_IsNull = _Geom.Handle_Geom_VectorWithMagnitude_IsNull
Handle_Geom_BSplineCurve_Create = _Geom.Handle_Geom_BSplineCurve_Create
Handle_Geom_BSplineCurve_DownCast = _Geom.Handle_Geom_BSplineCurve_DownCast
Handle_Geom_BSplineCurve_IsNull = _Geom.Handle_Geom_BSplineCurve_IsNull
Handle_Geom_BSplineSurface_Create = _Geom.Handle_Geom_BSplineSurface_Create
Handle_Geom_BSplineSurface_DownCast = _Geom.Handle_Geom_BSplineSurface_DownCast
Handle_Geom_BSplineSurface_IsNull = _Geom.Handle_Geom_BSplineSurface_IsNull
Handle_Geom_BezierCurve_Create = _Geom.Handle_Geom_BezierCurve_Create
Handle_Geom_BezierCurve_DownCast = _Geom.Handle_Geom_BezierCurve_DownCast
Handle_Geom_BezierCurve_IsNull = _Geom.Handle_Geom_BezierCurve_IsNull
Handle_Geom_BezierSurface_Create = _Geom.Handle_Geom_BezierSurface_Create
Handle_Geom_BezierSurface_DownCast = _Geom.Handle_Geom_BezierSurface_DownCast
Handle_Geom_BezierSurface_IsNull = _Geom.Handle_Geom_BezierSurface_IsNull
Handle_Geom_Circle_Create = _Geom.Handle_Geom_Circle_Create
Handle_Geom_Circle_DownCast = _Geom.Handle_Geom_Circle_DownCast
Handle_Geom_Circle_IsNull = _Geom.Handle_Geom_Circle_IsNull
Handle_Geom_ConicalSurface_Create = _Geom.Handle_Geom_ConicalSurface_Create
Handle_Geom_ConicalSurface_DownCast = _Geom.Handle_Geom_ConicalSurface_DownCast
Handle_Geom_ConicalSurface_IsNull = _Geom.Handle_Geom_ConicalSurface_IsNull
Handle_Geom_CylindricalSurface_Create = _Geom.Handle_Geom_CylindricalSurface_Create
Handle_Geom_CylindricalSurface_DownCast = _Geom.Handle_Geom_CylindricalSurface_DownCast
Handle_Geom_CylindricalSurface_IsNull = _Geom.Handle_Geom_CylindricalSurface_IsNull
Handle_Geom_Ellipse_Create = _Geom.Handle_Geom_Ellipse_Create
Handle_Geom_Ellipse_DownCast = _Geom.Handle_Geom_Ellipse_DownCast
Handle_Geom_Ellipse_IsNull = _Geom.Handle_Geom_Ellipse_IsNull
Handle_Geom_Hyperbola_Create = _Geom.Handle_Geom_Hyperbola_Create
Handle_Geom_Hyperbola_DownCast = _Geom.Handle_Geom_Hyperbola_DownCast
Handle_Geom_Hyperbola_IsNull = _Geom.Handle_Geom_Hyperbola_IsNull
Handle_Geom_Parabola_Create = _Geom.Handle_Geom_Parabola_Create
Handle_Geom_Parabola_DownCast = _Geom.Handle_Geom_Parabola_DownCast
Handle_Geom_Parabola_IsNull = _Geom.Handle_Geom_Parabola_IsNull
Handle_Geom_Plane_Create = _Geom.Handle_Geom_Plane_Create
Handle_Geom_Plane_DownCast = _Geom.Handle_Geom_Plane_DownCast
Handle_Geom_Plane_IsNull = _Geom.Handle_Geom_Plane_IsNull
Handle_Geom_RectangularTrimmedSurface_Create = _Geom.Handle_Geom_RectangularTrimmedSurface_Create
Handle_Geom_RectangularTrimmedSurface_DownCast = _Geom.Handle_Geom_RectangularTrimmedSurface_DownCast
Handle_Geom_RectangularTrimmedSurface_IsNull = _Geom.Handle_Geom_RectangularTrimmedSurface_IsNull
Handle_Geom_SphericalSurface_Create = _Geom.Handle_Geom_SphericalSurface_Create
Handle_Geom_SphericalSurface_DownCast = _Geom.Handle_Geom_SphericalSurface_DownCast
Handle_Geom_SphericalSurface_IsNull = _Geom.Handle_Geom_SphericalSurface_IsNull
Handle_Geom_SurfaceOfLinearExtrusion_Create = _Geom.Handle_Geom_SurfaceOfLinearExtrusion_Create
Handle_Geom_SurfaceOfLinearExtrusion_DownCast = _Geom.Handle_Geom_SurfaceOfLinearExtrusion_DownCast
Handle_Geom_SurfaceOfLinearExtrusion_IsNull = _Geom.Handle_Geom_SurfaceOfLinearExtrusion_IsNull
Handle_Geom_SurfaceOfRevolution_Create = _Geom.Handle_Geom_SurfaceOfRevolution_Create
Handle_Geom_SurfaceOfRevolution_DownCast = _Geom.Handle_Geom_SurfaceOfRevolution_DownCast
Handle_Geom_SurfaceOfRevolution_IsNull = _Geom.Handle_Geom_SurfaceOfRevolution_IsNull
Handle_Geom_ToroidalSurface_Create = _Geom.Handle_Geom_ToroidalSurface_Create
Handle_Geom_ToroidalSurface_DownCast = _Geom.Handle_Geom_ToroidalSurface_DownCast
Handle_Geom_ToroidalSurface_IsNull = _Geom.Handle_Geom_ToroidalSurface_IsNull
Handle_Geom_TrimmedCurve_Create = _Geom.Handle_Geom_TrimmedCurve_Create
Handle_Geom_TrimmedCurve_DownCast = _Geom.Handle_Geom_TrimmedCurve_DownCast
Handle_Geom_TrimmedCurve_IsNull = _Geom.Handle_Geom_TrimmedCurve_IsNull
Handle_Geom_HSequenceOfBSplineSurface_Create = _Geom.Handle_Geom_HSequenceOfBSplineSurface_Create
Handle_Geom_HSequenceOfBSplineSurface_DownCast = _Geom.Handle_Geom_HSequenceOfBSplineSurface_DownCast
Handle_Geom_HSequenceOfBSplineSurface_IsNull = _Geom.Handle_Geom_HSequenceOfBSplineSurface_IsNull
class Geom_SequenceOfBSplineSurface(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    begin = _swig_new_instance_method(_Geom.Geom_SequenceOfBSplineSurface_begin)
    end = _swig_new_instance_method(_Geom.Geom_SequenceOfBSplineSurface_end)
    cbegin = _swig_new_instance_method(_Geom.Geom_SequenceOfBSplineSurface_cbegin)
    cend = _swig_new_instance_method(_Geom.Geom_SequenceOfBSplineSurface_cend)

    def __init__(self, *args):
        _Geom.Geom_SequenceOfBSplineSurface_swiginit(self, _Geom.new_Geom_SequenceOfBSplineSurface(*args))
    Size = _swig_new_instance_method(_Geom.Geom_SequenceOfBSplineSurface_Size)
    Length = _swig_new_instance_method(_Geom.Geom_SequenceOfBSplineSurface_Length)
    Lower = _swig_new_instance_method(_Geom.Geom_SequenceOfBSplineSurface_Lower)
    Upper = _swig_new_instance_method(_Geom.Geom_SequenceOfBSplineSurface_Upper)
    IsEmpty = _swig_new_instance_method(_Geom.Geom_SequenceOfBSplineSurface_IsEmpty)
    Reverse = _swig_new_instance_method(_Geom.Geom_SequenceOfBSplineSurface_Reverse)
    Exchange = _swig_new_instance_method(_Geom.Geom_SequenceOfBSplineSurface_Exchange)
    delNode = _swig_new_static_method(_Geom.Geom_SequenceOfBSplineSurface_delNode)
    Clear = _swig_new_instance_method(_Geom.Geom_SequenceOfBSplineSurface_Clear)
    Assign = _swig_new_instance_method(_Geom.Geom_SequenceOfBSplineSurface_Assign)
    Set = _swig_new_instance_method(_Geom.Geom_SequenceOfBSplineSurface_Set)
    Remove = _swig_new_instance_method(_Geom.Geom_SequenceOfBSplineSurface_Remove)
    Append = _swig_new_instance_method(_Geom.Geom_SequenceOfBSplineSurface_Append)
    Prepend = _swig_new_instance_method(_Geom.Geom_SequenceOfBSplineSurface_Prepend)
    InsertBefore = _swig_new_instance_method(_Geom.Geom_SequenceOfBSplineSurface_InsertBefore)
    InsertAfter = _swig_new_instance_method(_Geom.Geom_SequenceOfBSplineSurface_InsertAfter)
    Split = _swig_new_instance_method(_Geom.Geom_SequenceOfBSplineSurface_Split)
    First = _swig_new_instance_method(_Geom.Geom_SequenceOfBSplineSurface_First)
    ChangeFirst = _swig_new_instance_method(_Geom.Geom_SequenceOfBSplineSurface_ChangeFirst)
    Last = _swig_new_instance_method(_Geom.Geom_SequenceOfBSplineSurface_Last)
    ChangeLast = _swig_new_instance_method(_Geom.Geom_SequenceOfBSplineSurface_ChangeLast)
    Value = _swig_new_instance_method(_Geom.Geom_SequenceOfBSplineSurface_Value)
    ChangeValue = _swig_new_instance_method(_Geom.Geom_SequenceOfBSplineSurface_ChangeValue)
    __call__ = _swig_new_instance_method(_Geom.Geom_SequenceOfBSplineSurface___call__)
    SetValue = _swig_new_instance_method(_Geom.Geom_SequenceOfBSplineSurface_SetValue)
    __swig_destroy__ = _Geom.delete_Geom_SequenceOfBSplineSurface

# Register Geom_SequenceOfBSplineSurface in _Geom:
_Geom.Geom_SequenceOfBSplineSurface_swigregister(Geom_SequenceOfBSplineSurface)
Geom_SequenceOfBSplineSurface_delNode = _Geom.Geom_SequenceOfBSplineSurface_delNode

class Geom_Geometry(OCC.Core.Standard.Standard_Transient):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Copy = _swig_new_instance_method(_Geom.Geom_Geometry_Copy)
    Mirror = _swig_new_instance_method(_Geom.Geom_Geometry_Mirror)
    Mirrored = _swig_new_instance_method(_Geom.Geom_Geometry_Mirrored)
    Rotate = _swig_new_instance_method(_Geom.Geom_Geometry_Rotate)
    Rotated = _swig_new_instance_method(_Geom.Geom_Geometry_Rotated)
    Scale = _swig_new_instance_method(_Geom.Geom_Geometry_Scale)
    Scaled = _swig_new_instance_method(_Geom.Geom_Geometry_Scaled)
    Transform = _swig_new_instance_method(_Geom.Geom_Geometry_Transform)
    Transformed = _swig_new_instance_method(_Geom.Geom_Geometry_Transformed)
    Translate = _swig_new_instance_method(_Geom.Geom_Geometry_Translate)
    Translated = _swig_new_instance_method(_Geom.Geom_Geometry_Translated)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_Geometry_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_Geometry

# Register Geom_Geometry in _Geom:
_Geom.Geom_Geometry_swigregister(Geom_Geometry)

class Geom_OsculatingSurface(OCC.Core.Standard.Standard_Transient):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    BasisSurface = _swig_new_instance_method(_Geom.Geom_OsculatingSurface_BasisSurface)

    def __init__(self, *args):
        r"""
        :rtype: None* detects if the surface has punctual U or V isoparametric curve along on the bounds of the surface relativly to the tolerance Tol and Builds the corresponding osculating surfaces.
        	:param BS:
        	:type BS: Geom_Surface
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        _Geom.Geom_OsculatingSurface_swiginit(self, _Geom.new_Geom_OsculatingSurface(*args))
    Init = _swig_new_instance_method(_Geom.Geom_OsculatingSurface_Init)
    Tolerance = _swig_new_instance_method(_Geom.Geom_OsculatingSurface_Tolerance)
    UOscSurf = _swig_new_instance_method(_Geom.Geom_OsculatingSurface_UOscSurf)
    VOscSurf = _swig_new_instance_method(_Geom.Geom_OsculatingSurface_VOscSurf)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_OsculatingSurface_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_OsculatingSurface

# Register Geom_OsculatingSurface in _Geom:
_Geom.Geom_OsculatingSurface_swigregister(Geom_OsculatingSurface)

class Geom_Transformation(OCC.Core.Standard.Standard_Transient):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Copy = _swig_new_instance_method(_Geom.Geom_Transformation_Copy)
    Form = _swig_new_instance_method(_Geom.Geom_Transformation_Form)

    def __init__(self, *args):
        r"""
        * Creates an identity transformation.
        	:rtype: None* Creates a transient copy of T.
        	:param T:
        	:type T: gp_Trsf
        	:rtype: None
        """
        _Geom.Geom_Transformation_swiginit(self, _Geom.new_Geom_Transformation(*args))
    Invert = _swig_new_instance_method(_Geom.Geom_Transformation_Invert)
    Inverted = _swig_new_instance_method(_Geom.Geom_Transformation_Inverted)
    IsNegative = _swig_new_instance_method(_Geom.Geom_Transformation_IsNegative)
    Multiplied = _swig_new_instance_method(_Geom.Geom_Transformation_Multiplied)
    Multiply = _swig_new_instance_method(_Geom.Geom_Transformation_Multiply)
    Power = _swig_new_instance_method(_Geom.Geom_Transformation_Power)
    Powered = _swig_new_instance_method(_Geom.Geom_Transformation_Powered)
    PreMultiply = _swig_new_instance_method(_Geom.Geom_Transformation_PreMultiply)
    ScaleFactor = _swig_new_instance_method(_Geom.Geom_Transformation_ScaleFactor)
    SetMirror = _swig_new_instance_method(_Geom.Geom_Transformation_SetMirror)
    SetRotation = _swig_new_instance_method(_Geom.Geom_Transformation_SetRotation)
    SetScale = _swig_new_instance_method(_Geom.Geom_Transformation_SetScale)
    SetTransformation = _swig_new_instance_method(_Geom.Geom_Transformation_SetTransformation)
    SetTranslation = _swig_new_instance_method(_Geom.Geom_Transformation_SetTranslation)
    SetTrsf = _swig_new_instance_method(_Geom.Geom_Transformation_SetTrsf)
    Transforms = _swig_new_instance_method(_Geom.Geom_Transformation_Transforms)
    Trsf = _swig_new_instance_method(_Geom.Geom_Transformation_Trsf)
    Value = _swig_new_instance_method(_Geom.Geom_Transformation_Value)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_Transformation_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_Transformation

# Register Geom_Transformation in _Geom:
_Geom.Geom_Transformation_swigregister(Geom_Transformation)

class Geom_AxisPlacement(Geom_Geometry):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Angle = _swig_new_instance_method(_Geom.Geom_AxisPlacement_Angle)
    Axis = _swig_new_instance_method(_Geom.Geom_AxisPlacement_Axis)
    Direction = _swig_new_instance_method(_Geom.Geom_AxisPlacement_Direction)
    Location = _swig_new_instance_method(_Geom.Geom_AxisPlacement_Location)
    SetAxis = _swig_new_instance_method(_Geom.Geom_AxisPlacement_SetAxis)
    SetDirection = _swig_new_instance_method(_Geom.Geom_AxisPlacement_SetDirection)
    SetLocation = _swig_new_instance_method(_Geom.Geom_AxisPlacement_SetLocation)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_AxisPlacement_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_AxisPlacement

# Register Geom_AxisPlacement in _Geom:
_Geom.Geom_AxisPlacement_swigregister(Geom_AxisPlacement)

class Geom_Curve(Geom_Geometry):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Continuity = _swig_new_instance_method(_Geom.Geom_Curve_Continuity)
    D0 = _swig_new_instance_method(_Geom.Geom_Curve_D0)
    D1 = _swig_new_instance_method(_Geom.Geom_Curve_D1)
    D2 = _swig_new_instance_method(_Geom.Geom_Curve_D2)
    D3 = _swig_new_instance_method(_Geom.Geom_Curve_D3)
    DN = _swig_new_instance_method(_Geom.Geom_Curve_DN)
    FirstParameter = _swig_new_instance_method(_Geom.Geom_Curve_FirstParameter)
    IsCN = _swig_new_instance_method(_Geom.Geom_Curve_IsCN)
    IsClosed = _swig_new_instance_method(_Geom.Geom_Curve_IsClosed)
    IsPeriodic = _swig_new_instance_method(_Geom.Geom_Curve_IsPeriodic)
    LastParameter = _swig_new_instance_method(_Geom.Geom_Curve_LastParameter)
    ParametricTransformation = _swig_new_instance_method(_Geom.Geom_Curve_ParametricTransformation)
    Period = _swig_new_instance_method(_Geom.Geom_Curve_Period)
    Reverse = _swig_new_instance_method(_Geom.Geom_Curve_Reverse)
    Reversed = _swig_new_instance_method(_Geom.Geom_Curve_Reversed)
    ReversedParameter = _swig_new_instance_method(_Geom.Geom_Curve_ReversedParameter)
    TransformedParameter = _swig_new_instance_method(_Geom.Geom_Curve_TransformedParameter)
    Value = _swig_new_instance_method(_Geom.Geom_Curve_Value)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_Curve_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_Curve

# Register Geom_Curve in _Geom:
_Geom.Geom_Curve_swigregister(Geom_Curve)

class Geom_Point(Geom_Geometry):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Coord = _swig_new_instance_method(_Geom.Geom_Point_Coord)
    Distance = _swig_new_instance_method(_Geom.Geom_Point_Distance)
    Pnt = _swig_new_instance_method(_Geom.Geom_Point_Pnt)
    SquareDistance = _swig_new_instance_method(_Geom.Geom_Point_SquareDistance)
    X = _swig_new_instance_method(_Geom.Geom_Point_X)
    Y = _swig_new_instance_method(_Geom.Geom_Point_Y)
    Z = _swig_new_instance_method(_Geom.Geom_Point_Z)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_Point_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_Point

# Register Geom_Point in _Geom:
_Geom.Geom_Point_swigregister(Geom_Point)

class Geom_Surface(Geom_Geometry):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Bounds = _swig_new_instance_method(_Geom.Geom_Surface_Bounds)
    Continuity = _swig_new_instance_method(_Geom.Geom_Surface_Continuity)
    D0 = _swig_new_instance_method(_Geom.Geom_Surface_D0)
    D1 = _swig_new_instance_method(_Geom.Geom_Surface_D1)
    D2 = _swig_new_instance_method(_Geom.Geom_Surface_D2)
    D3 = _swig_new_instance_method(_Geom.Geom_Surface_D3)
    DN = _swig_new_instance_method(_Geom.Geom_Surface_DN)
    IsCNu = _swig_new_instance_method(_Geom.Geom_Surface_IsCNu)
    IsCNv = _swig_new_instance_method(_Geom.Geom_Surface_IsCNv)
    IsUClosed = _swig_new_instance_method(_Geom.Geom_Surface_IsUClosed)
    IsUPeriodic = _swig_new_instance_method(_Geom.Geom_Surface_IsUPeriodic)
    IsVClosed = _swig_new_instance_method(_Geom.Geom_Surface_IsVClosed)
    IsVPeriodic = _swig_new_instance_method(_Geom.Geom_Surface_IsVPeriodic)
    ParametricTransformation = _swig_new_instance_method(_Geom.Geom_Surface_ParametricTransformation)
    TransformParameters = _swig_new_instance_method(_Geom.Geom_Surface_TransformParameters)
    UIso = _swig_new_instance_method(_Geom.Geom_Surface_UIso)
    UPeriod = _swig_new_instance_method(_Geom.Geom_Surface_UPeriod)
    UReverse = _swig_new_instance_method(_Geom.Geom_Surface_UReverse)
    UReversed = _swig_new_instance_method(_Geom.Geom_Surface_UReversed)
    UReversedParameter = _swig_new_instance_method(_Geom.Geom_Surface_UReversedParameter)
    VIso = _swig_new_instance_method(_Geom.Geom_Surface_VIso)
    VPeriod = _swig_new_instance_method(_Geom.Geom_Surface_VPeriod)
    VReverse = _swig_new_instance_method(_Geom.Geom_Surface_VReverse)
    VReversed = _swig_new_instance_method(_Geom.Geom_Surface_VReversed)
    VReversedParameter = _swig_new_instance_method(_Geom.Geom_Surface_VReversedParameter)
    Value = _swig_new_instance_method(_Geom.Geom_Surface_Value)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_Surface_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_Surface

# Register Geom_Surface in _Geom:
_Geom.Geom_Surface_swigregister(Geom_Surface)

class Geom_Vector(Geom_Geometry):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Angle = _swig_new_instance_method(_Geom.Geom_Vector_Angle)
    AngleWithRef = _swig_new_instance_method(_Geom.Geom_Vector_AngleWithRef)
    Coord = _swig_new_instance_method(_Geom.Geom_Vector_Coord)
    Cross = _swig_new_instance_method(_Geom.Geom_Vector_Cross)
    CrossCross = _swig_new_instance_method(_Geom.Geom_Vector_CrossCross)
    CrossCrossed = _swig_new_instance_method(_Geom.Geom_Vector_CrossCrossed)
    Crossed = _swig_new_instance_method(_Geom.Geom_Vector_Crossed)
    Dot = _swig_new_instance_method(_Geom.Geom_Vector_Dot)
    DotCross = _swig_new_instance_method(_Geom.Geom_Vector_DotCross)
    Magnitude = _swig_new_instance_method(_Geom.Geom_Vector_Magnitude)
    Reverse = _swig_new_instance_method(_Geom.Geom_Vector_Reverse)
    Reversed = _swig_new_instance_method(_Geom.Geom_Vector_Reversed)
    SquareMagnitude = _swig_new_instance_method(_Geom.Geom_Vector_SquareMagnitude)
    Vec = _swig_new_instance_method(_Geom.Geom_Vector_Vec)
    X = _swig_new_instance_method(_Geom.Geom_Vector_X)
    Y = _swig_new_instance_method(_Geom.Geom_Vector_Y)
    Z = _swig_new_instance_method(_Geom.Geom_Vector_Z)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_Vector_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_Vector

# Register Geom_Vector in _Geom:
_Geom.Geom_Vector_swigregister(Geom_Vector)

class Geom_Axis1Placement(Geom_AxisPlacement):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Ax1 = _swig_new_instance_method(_Geom.Geom_Axis1Placement_Ax1)

    def __init__(self, *args):
        r"""
        * Returns a transient copy of A1.
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: None* P is the origin of the axis placement and V is the direction of the axis placement.
        	:param P:
        	:type P: gp_Pnt
        	:param V:
        	:type V: gp_Dir
        	:rtype: None
        """
        _Geom.Geom_Axis1Placement_swiginit(self, _Geom.new_Geom_Axis1Placement(*args))
    Reverse = _swig_new_instance_method(_Geom.Geom_Axis1Placement_Reverse)
    Reversed = _swig_new_instance_method(_Geom.Geom_Axis1Placement_Reversed)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_Axis1Placement_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_Axis1Placement

# Register Geom_Axis1Placement in _Geom:
_Geom.Geom_Axis1Placement_swigregister(Geom_Axis1Placement)

class Geom_Axis2Placement(Geom_AxisPlacement):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Ax2 = _swig_new_instance_method(_Geom.Geom_Axis2Placement_Ax2)

    def __init__(self, *args):
        r"""
        * Returns a transient copy of A2.
        	:param A2:
        	:type A2: gp_Ax2
        	:rtype: None* P is the origin of the axis placement, N is the main direction of the axis placement and Vx is the 'XDirection'. If the two directions N and Vx are not orthogonal the 'XDirection' is computed as follow : XDirection = N ^ (Vx ^ N). Raised if N and Vx are parallel.
        	:param P:
        	:type P: gp_Pnt
        	:param N:
        	:type N: gp_Dir
        	:param Vx:
        	:type Vx: gp_Dir
        	:rtype: None
        """
        _Geom.Geom_Axis2Placement_swiginit(self, _Geom.new_Geom_Axis2Placement(*args))
    SetAx2 = _swig_new_instance_method(_Geom.Geom_Axis2Placement_SetAx2)
    SetXDirection = _swig_new_instance_method(_Geom.Geom_Axis2Placement_SetXDirection)
    SetYDirection = _swig_new_instance_method(_Geom.Geom_Axis2Placement_SetYDirection)
    XDirection = _swig_new_instance_method(_Geom.Geom_Axis2Placement_XDirection)
    YDirection = _swig_new_instance_method(_Geom.Geom_Axis2Placement_YDirection)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_Axis2Placement_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_Axis2Placement

# Register Geom_Axis2Placement in _Geom:
_Geom.Geom_Axis2Placement_swigregister(Geom_Axis2Placement)

class Geom_BoundedCurve(Geom_Curve):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    EndPoint = _swig_new_instance_method(_Geom.Geom_BoundedCurve_EndPoint)
    StartPoint = _swig_new_instance_method(_Geom.Geom_BoundedCurve_StartPoint)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_BoundedCurve_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_BoundedCurve

# Register Geom_BoundedCurve in _Geom:
_Geom.Geom_BoundedCurve_swigregister(Geom_BoundedCurve)

class Geom_BoundedSurface(Geom_Surface):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr


    @staticmethod
    def DownCast(t):
      return Handle_Geom_BoundedSurface_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_BoundedSurface

# Register Geom_BoundedSurface in _Geom:
_Geom.Geom_BoundedSurface_swigregister(Geom_BoundedSurface)

class Geom_CartesianPoint(Geom_Point):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Returns a transient copy of P.
        	:param P:
        	:type P: gp_Pnt
        	:rtype: None* Constructs a point defined by its three Cartesian coordinates X, Y and Z.
        	:param X:
        	:type X: float
        	:param Y:
        	:type Y: float
        	:param Z:
        	:type Z: float
        	:rtype: None
        """
        _Geom.Geom_CartesianPoint_swiginit(self, _Geom.new_Geom_CartesianPoint(*args))
    SetCoord = _swig_new_instance_method(_Geom.Geom_CartesianPoint_SetCoord)
    SetPnt = _swig_new_instance_method(_Geom.Geom_CartesianPoint_SetPnt)
    SetX = _swig_new_instance_method(_Geom.Geom_CartesianPoint_SetX)
    SetY = _swig_new_instance_method(_Geom.Geom_CartesianPoint_SetY)
    SetZ = _swig_new_instance_method(_Geom.Geom_CartesianPoint_SetZ)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_CartesianPoint_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_CartesianPoint

# Register Geom_CartesianPoint in _Geom:
_Geom.Geom_CartesianPoint_swigregister(Geom_CartesianPoint)

class Geom_Conic(Geom_Curve):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Axis = _swig_new_instance_method(_Geom.Geom_Conic_Axis)
    Eccentricity = _swig_new_instance_method(_Geom.Geom_Conic_Eccentricity)
    Location = _swig_new_instance_method(_Geom.Geom_Conic_Location)
    Position = _swig_new_instance_method(_Geom.Geom_Conic_Position)
    SetAxis = _swig_new_instance_method(_Geom.Geom_Conic_SetAxis)
    SetLocation = _swig_new_instance_method(_Geom.Geom_Conic_SetLocation)
    SetPosition = _swig_new_instance_method(_Geom.Geom_Conic_SetPosition)
    XAxis = _swig_new_instance_method(_Geom.Geom_Conic_XAxis)
    YAxis = _swig_new_instance_method(_Geom.Geom_Conic_YAxis)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_Conic_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_Conic

# Register Geom_Conic in _Geom:
_Geom.Geom_Conic_swigregister(Geom_Conic)

class Geom_Direction(Geom_Vector):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Dir = _swig_new_instance_method(_Geom.Geom_Direction_Dir)

    def __init__(self, *args):
        r"""
        * Creates a unit vector with it 3 cartesian coordinates. //! Raised if Sqrt( X*X + Y*Y + Z*Z) <= Resolution from gp.
        	:param X:
        	:type X: float
        	:param Y:
        	:type Y: float
        	:param Z:
        	:type Z: float
        	:rtype: None* Creates a transient copy of <self>.
        	:param V:
        	:type V: gp_Dir
        	:rtype: None
        """
        _Geom.Geom_Direction_swiginit(self, _Geom.new_Geom_Direction(*args))
    SetCoord = _swig_new_instance_method(_Geom.Geom_Direction_SetCoord)
    SetDir = _swig_new_instance_method(_Geom.Geom_Direction_SetDir)
    SetX = _swig_new_instance_method(_Geom.Geom_Direction_SetX)
    SetY = _swig_new_instance_method(_Geom.Geom_Direction_SetY)
    SetZ = _swig_new_instance_method(_Geom.Geom_Direction_SetZ)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_Direction_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_Direction

# Register Geom_Direction in _Geom:
_Geom.Geom_Direction_swigregister(Geom_Direction)

class Geom_ElementarySurface(Geom_Surface):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Axis = _swig_new_instance_method(_Geom.Geom_ElementarySurface_Axis)
    Location = _swig_new_instance_method(_Geom.Geom_ElementarySurface_Location)
    Position = _swig_new_instance_method(_Geom.Geom_ElementarySurface_Position)
    SetAxis = _swig_new_instance_method(_Geom.Geom_ElementarySurface_SetAxis)
    SetLocation = _swig_new_instance_method(_Geom.Geom_ElementarySurface_SetLocation)
    SetPosition = _swig_new_instance_method(_Geom.Geom_ElementarySurface_SetPosition)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_ElementarySurface_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_ElementarySurface

# Register Geom_ElementarySurface in _Geom:
_Geom.Geom_ElementarySurface_swigregister(Geom_ElementarySurface)

class Geom_Line(Geom_Curve):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Creates a line located in 3D space with the axis placement A1. The Location of A1 is the origin of the line.
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: None* Creates a line from a non transient line from package gp.
        	:param L:
        	:type L: gp_Lin
        	:rtype: None* Constructs a line passing through point P and parallel to vector V (P and V are, respectively, the origin and the unit vector of the positioning axis of the line).
        	:param P:
        	:type P: gp_Pnt
        	:param V:
        	:type V: gp_Dir
        	:rtype: None
        """
        _Geom.Geom_Line_swiginit(self, _Geom.new_Geom_Line(*args))
    Lin = _swig_new_instance_method(_Geom.Geom_Line_Lin)
    Position = _swig_new_instance_method(_Geom.Geom_Line_Position)
    SetDirection = _swig_new_instance_method(_Geom.Geom_Line_SetDirection)
    SetLin = _swig_new_instance_method(_Geom.Geom_Line_SetLin)
    SetLocation = _swig_new_instance_method(_Geom.Geom_Line_SetLocation)
    SetPosition = _swig_new_instance_method(_Geom.Geom_Line_SetPosition)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_Line_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_Line

# Register Geom_Line in _Geom:
_Geom.Geom_Line_swigregister(Geom_Line)

class Geom_OffsetCurve(Geom_Curve):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    BasisCurve = _swig_new_instance_method(_Geom.Geom_OffsetCurve_BasisCurve)
    Direction = _swig_new_instance_method(_Geom.Geom_OffsetCurve_Direction)

    def __init__(self, *args):
        r"""
        * C is the basis curve, Offset is the distance between <self> and the basis curve at any point. V defines the fixed reference direction (offset direction). If P is a point on the basis curve and T the first derivative with non zero length at this point, the corresponding point on the offset curve is in the direction of the vector-product N = V ^ T where N is a unitary vector. If isNotCheckC0 = True checking if basis curve has C0-continuity is not made. Warnings : In this package the entities are not shared. The OffsetCurve is built with a copy of the curve C. So when C is modified the OffsetCurve is not modified //! Raised if the basis curve C is not at least C1. Warnings : No check is done to know if ||V^T|| != 0.0 at any point.
        	:param C:
        	:type C: Geom_Curve
        	:param Offset:
        	:type Offset: float
        	:param V:
        	:type V: gp_Dir
        	:param isNotCheckC0: default value is Standard_False
        	:type isNotCheckC0: bool
        	:rtype: None
        """
        _Geom.Geom_OffsetCurve_swiginit(self, _Geom.new_Geom_OffsetCurve(*args))
    GetBasisCurveContinuity = _swig_new_instance_method(_Geom.Geom_OffsetCurve_GetBasisCurveContinuity)
    Offset = _swig_new_instance_method(_Geom.Geom_OffsetCurve_Offset)
    SetBasisCurve = _swig_new_instance_method(_Geom.Geom_OffsetCurve_SetBasisCurve)
    SetDirection = _swig_new_instance_method(_Geom.Geom_OffsetCurve_SetDirection)
    SetOffsetValue = _swig_new_instance_method(_Geom.Geom_OffsetCurve_SetOffsetValue)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_OffsetCurve_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_OffsetCurve

# Register Geom_OffsetCurve in _Geom:
_Geom.Geom_OffsetCurve_swigregister(Geom_OffsetCurve)

class Geom_OffsetSurface(Geom_Surface):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    BasisSurface = _swig_new_instance_method(_Geom.Geom_OffsetSurface_BasisSurface)

    def __init__(self, *args):
        r"""
        * Constructs a surface offset from the basis surface S, where Offset is the distance between the offset surface and the basis surface at any point. A point on the offset surface is built by measuring the offset value along a normal vector at a point on S. This normal vector is given by the cross product D1u^D1v, where D1u and D1v are the vectors tangential to the basis surface in the u and v parametric directions at this point. The side of S on which the offset value is measured is indicated by this normal vector if Offset is positive, or is the inverse sense if Offset is negative. If isNotCheckC0 = True checking if basis surface has C0-continuity is not made. Warnings : - The offset surface is built with a copy of the surface S. Therefore, when S is modified the offset surface is not modified. - No check is made at the time of construction to detect points on S with multiple possible normal directions. Raised if S is not at least C1. Warnings : No check is done to verify that a unique normal direction is defined at any point of the basis surface S.
        	:param S:
        	:type S: Geom_Surface
        	:param Offset:
        	:type Offset: float
        	:param isNotCheckC0: default value is Standard_False
        	:type isNotCheckC0: bool
        	:rtype: None
        """
        _Geom.Geom_OffsetSurface_swiginit(self, _Geom.new_Geom_OffsetSurface(*args))
    GetBasisSurfContinuity = _swig_new_instance_method(_Geom.Geom_OffsetSurface_GetBasisSurfContinuity)
    Offset = _swig_new_instance_method(_Geom.Geom_OffsetSurface_Offset)
    OsculatingSurface = _swig_new_instance_method(_Geom.Geom_OffsetSurface_OsculatingSurface)
    SetBasisSurface = _swig_new_instance_method(_Geom.Geom_OffsetSurface_SetBasisSurface)
    SetOffsetValue = _swig_new_instance_method(_Geom.Geom_OffsetSurface_SetOffsetValue)
    Surface = _swig_new_instance_method(_Geom.Geom_OffsetSurface_Surface)
    UOsculatingSurface = _swig_new_instance_method(_Geom.Geom_OffsetSurface_UOsculatingSurface)
    VOsculatingSurface = _swig_new_instance_method(_Geom.Geom_OffsetSurface_VOsculatingSurface)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_OffsetSurface_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_OffsetSurface

# Register Geom_OffsetSurface in _Geom:
_Geom.Geom_OffsetSurface_swigregister(Geom_OffsetSurface)

class Geom_SweptSurface(Geom_Surface):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    BasisCurve = _swig_new_instance_method(_Geom.Geom_SweptSurface_BasisCurve)
    Direction = _swig_new_instance_method(_Geom.Geom_SweptSurface_Direction)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_SweptSurface_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_SweptSurface

# Register Geom_SweptSurface in _Geom:
_Geom.Geom_SweptSurface_swigregister(Geom_SweptSurface)

class Geom_VectorWithMagnitude(Geom_Vector):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Add = _swig_new_instance_method(_Geom.Geom_VectorWithMagnitude_Add)
    Added = _swig_new_instance_method(_Geom.Geom_VectorWithMagnitude_Added)
    Divide = _swig_new_instance_method(_Geom.Geom_VectorWithMagnitude_Divide)
    Divided = _swig_new_instance_method(_Geom.Geom_VectorWithMagnitude_Divided)

    def __init__(self, *args):
        r"""
        * Creates a transient copy of V.
        	:param V:
        	:type V: gp_Vec
        	:rtype: None* Creates a vector with three cartesian coordinates.
        	:param X:
        	:type X: float
        	:param Y:
        	:type Y: float
        	:param Z:
        	:type Z: float
        	:rtype: None* Creates a vector from the point P1 to the point P2. The magnitude of the vector is the distance between P1 and P2
        	:param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: None
        """
        _Geom.Geom_VectorWithMagnitude_swiginit(self, _Geom.new_Geom_VectorWithMagnitude(*args))
    Multiplied = _swig_new_instance_method(_Geom.Geom_VectorWithMagnitude_Multiplied)
    Multiply = _swig_new_instance_method(_Geom.Geom_VectorWithMagnitude_Multiply)
    Normalize = _swig_new_instance_method(_Geom.Geom_VectorWithMagnitude_Normalize)
    Normalized = _swig_new_instance_method(_Geom.Geom_VectorWithMagnitude_Normalized)
    SetCoord = _swig_new_instance_method(_Geom.Geom_VectorWithMagnitude_SetCoord)
    SetVec = _swig_new_instance_method(_Geom.Geom_VectorWithMagnitude_SetVec)
    SetX = _swig_new_instance_method(_Geom.Geom_VectorWithMagnitude_SetX)
    SetY = _swig_new_instance_method(_Geom.Geom_VectorWithMagnitude_SetY)
    SetZ = _swig_new_instance_method(_Geom.Geom_VectorWithMagnitude_SetZ)
    Subtract = _swig_new_instance_method(_Geom.Geom_VectorWithMagnitude_Subtract)
    Subtracted = _swig_new_instance_method(_Geom.Geom_VectorWithMagnitude_Subtracted)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_VectorWithMagnitude_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_VectorWithMagnitude

# Register Geom_VectorWithMagnitude in _Geom:
_Geom.Geom_VectorWithMagnitude_swigregister(Geom_VectorWithMagnitude)

class Geom_BSplineCurve(Geom_BoundedCurve):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Degree = _swig_new_instance_method(_Geom.Geom_BSplineCurve_Degree)
    FirstUKnotIndex = _swig_new_instance_method(_Geom.Geom_BSplineCurve_FirstUKnotIndex)

    def __init__(self, *args):
        r"""
        * Creates a non-rational B_spline curve on the basis <Knots, Multiplicities> of degree <Degree>.
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Multiplicities:
        	:type Multiplicities: TColStd_Array1OfInteger
        	:param Degree:
        	:type Degree: int
        	:param Periodic: default value is Standard_False
        	:type Periodic: bool
        	:rtype: None* Creates a rational B_spline curve on the basis <Knots, Multiplicities> of degree <Degree>. Raises ConstructionError subject to the following conditions 0 < Degree <= MaxDegree. //! Weights.Length() == Poles.Length() //! Knots.Length() == Mults.Length() >= 2 //! Knots(i) < Knots(i+1) (Knots are increasing) //! 1 <= Mults(i) <= Degree //! On a non periodic curve the first and last multiplicities may be Degree+1 (this is even recommanded if you want the curve to start and finish on the first and last pole). //! On a periodic curve the first and the last multicities must be the same. //! on non-periodic curves //! Poles.Length() == Sum(Mults(i)) - Degree - 1 >= 2 //! on periodic curves //! Poles.Length() == Sum(Mults(i)) except the first or last
        	:param Poles:
        	:type Poles: TColgp_Array1OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Multiplicities:
        	:type Multiplicities: TColStd_Array1OfInteger
        	:param Degree:
        	:type Degree: int
        	:param Periodic: default value is Standard_False
        	:type Periodic: bool
        	:param CheckRational: default value is Standard_True
        	:type CheckRational: bool
        	:rtype: None
        """
        _Geom.Geom_BSplineCurve_swiginit(self, _Geom.new_Geom_BSplineCurve(*args))
    IncreaseDegree = _swig_new_instance_method(_Geom.Geom_BSplineCurve_IncreaseDegree)
    IncreaseMultiplicity = _swig_new_instance_method(_Geom.Geom_BSplineCurve_IncreaseMultiplicity)
    IncrementMultiplicity = _swig_new_instance_method(_Geom.Geom_BSplineCurve_IncrementMultiplicity)
    InsertKnot = _swig_new_instance_method(_Geom.Geom_BSplineCurve_InsertKnot)
    InsertKnots = _swig_new_instance_method(_Geom.Geom_BSplineCurve_InsertKnots)
    IsEqual = _swig_new_instance_method(_Geom.Geom_BSplineCurve_IsEqual)
    IsG1 = _swig_new_instance_method(_Geom.Geom_BSplineCurve_IsG1)
    IsRational = _swig_new_instance_method(_Geom.Geom_BSplineCurve_IsRational)
    Knot = _swig_new_instance_method(_Geom.Geom_BSplineCurve_Knot)
    KnotDistribution = _swig_new_instance_method(_Geom.Geom_BSplineCurve_KnotDistribution)
    KnotSequence = _swig_new_instance_method(_Geom.Geom_BSplineCurve_KnotSequence)
    Knots = _swig_new_instance_method(_Geom.Geom_BSplineCurve_Knots)
    LastUKnotIndex = _swig_new_instance_method(_Geom.Geom_BSplineCurve_LastUKnotIndex)
    LocalD0 = _swig_new_instance_method(_Geom.Geom_BSplineCurve_LocalD0)
    LocalD1 = _swig_new_instance_method(_Geom.Geom_BSplineCurve_LocalD1)
    LocalD2 = _swig_new_instance_method(_Geom.Geom_BSplineCurve_LocalD2)
    LocalD3 = _swig_new_instance_method(_Geom.Geom_BSplineCurve_LocalD3)
    LocalDN = _swig_new_instance_method(_Geom.Geom_BSplineCurve_LocalDN)
    LocalValue = _swig_new_instance_method(_Geom.Geom_BSplineCurve_LocalValue)
    LocateU = _swig_new_instance_method(_Geom.Geom_BSplineCurve_LocateU)
    MaxDegree = _swig_new_static_method(_Geom.Geom_BSplineCurve_MaxDegree)
    MovePoint = _swig_new_instance_method(_Geom.Geom_BSplineCurve_MovePoint)
    MovePointAndTangent = _swig_new_instance_method(_Geom.Geom_BSplineCurve_MovePointAndTangent)
    Multiplicities = _swig_new_instance_method(_Geom.Geom_BSplineCurve_Multiplicities)
    Multiplicity = _swig_new_instance_method(_Geom.Geom_BSplineCurve_Multiplicity)
    NbKnots = _swig_new_instance_method(_Geom.Geom_BSplineCurve_NbKnots)
    NbPoles = _swig_new_instance_method(_Geom.Geom_BSplineCurve_NbPoles)
    PeriodicNormalization = _swig_new_instance_method(_Geom.Geom_BSplineCurve_PeriodicNormalization)
    Pole = _swig_new_instance_method(_Geom.Geom_BSplineCurve_Pole)
    Poles = _swig_new_instance_method(_Geom.Geom_BSplineCurve_Poles)
    RemoveKnot = _swig_new_instance_method(_Geom.Geom_BSplineCurve_RemoveKnot)
    Resolution = _swig_new_instance_method(_Geom.Geom_BSplineCurve_Resolution)
    Segment = _swig_new_instance_method(_Geom.Geom_BSplineCurve_Segment)
    SetKnot = _swig_new_instance_method(_Geom.Geom_BSplineCurve_SetKnot)
    SetKnots = _swig_new_instance_method(_Geom.Geom_BSplineCurve_SetKnots)
    SetNotPeriodic = _swig_new_instance_method(_Geom.Geom_BSplineCurve_SetNotPeriodic)
    SetOrigin = _swig_new_instance_method(_Geom.Geom_BSplineCurve_SetOrigin)
    SetPeriodic = _swig_new_instance_method(_Geom.Geom_BSplineCurve_SetPeriodic)
    SetPole = _swig_new_instance_method(_Geom.Geom_BSplineCurve_SetPole)
    SetWeight = _swig_new_instance_method(_Geom.Geom_BSplineCurve_SetWeight)
    Weight = _swig_new_instance_method(_Geom.Geom_BSplineCurve_Weight)
    Weights = _swig_new_instance_method(_Geom.Geom_BSplineCurve_Weights)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_BSplineCurve_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_BSplineCurve

# Register Geom_BSplineCurve in _Geom:
_Geom.Geom_BSplineCurve_swigregister(Geom_BSplineCurve)
Geom_BSplineCurve_MaxDegree = _Geom.Geom_BSplineCurve_MaxDegree

class Geom_BSplineSurface(Geom_BoundedSurface):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    CheckAndSegment = _swig_new_instance_method(_Geom.Geom_BSplineSurface_CheckAndSegment)
    ExchangeUV = _swig_new_instance_method(_Geom.Geom_BSplineSurface_ExchangeUV)
    FirstUKnotIndex = _swig_new_instance_method(_Geom.Geom_BSplineSurface_FirstUKnotIndex)
    FirstVKnotIndex = _swig_new_instance_method(_Geom.Geom_BSplineSurface_FirstVKnotIndex)

    def __init__(self, *args):
        r"""
        * Creates a non-rational b-spline surface (weights default value is 1.). The following conditions must be verified. 0 < UDegree <= MaxDegree. UKnots.Length() == UMults.Length() >= 2 UKnots(i) < UKnots(i+1) (Knots are increasing) 1 <= UMults(i) <= UDegree On a non uperiodic surface the first and last umultiplicities may be UDegree+1 (this is even recommanded if you want the curve to start and finish on the first and last pole). On a uperiodic surface the first and the last umultiplicities must be the same. on non-uperiodic surfaces Poles.ColLength() == Sum(UMults(i)) - UDegree - 1 >= 2 on uperiodic surfaces Poles.ColLength() == Sum(UMults(i)) except the first or last The previous conditions for U holds also for V, with the RowLength of the poles.
        	:param Poles:
        	:type Poles: TColgp_Array2OfPnt
        	:param UKnots:
        	:type UKnots: TColStd_Array1OfReal
        	:param VKnots:
        	:type VKnots: TColStd_Array1OfReal
        	:param UMults:
        	:type UMults: TColStd_Array1OfInteger
        	:param VMults:
        	:type VMults: TColStd_Array1OfInteger
        	:param UDegree:
        	:type UDegree: int
        	:param VDegree:
        	:type VDegree: int
        	:param UPeriodic: default value is Standard_False
        	:type UPeriodic: bool
        	:param VPeriodic: default value is Standard_False
        	:type VPeriodic: bool
        	:rtype: None* Creates a non-rational b-spline surface (weights default value is 1.). //! The following conditions must be verified. 0 < UDegree <= MaxDegree. //! UKnots.Length() == UMults.Length() >= 2 //! UKnots(i) < UKnots(i+1) (Knots are increasing) 1 <= UMults(i) <= UDegree //! On a non uperiodic surface the first and last umultiplicities may be UDegree+1 (this is even recommanded if you want the curve to start and finish on the first and last pole). //! On a uperiodic surface the first and the last umultiplicities must be the same. //! on non-uperiodic surfaces //! Poles.ColLength() == Sum(UMults(i)) - UDegree - 1 >= 2 //! on uperiodic surfaces //! Poles.ColLength() == Sum(UMults(i)) except the first or last //! The previous conditions for U holds also for V, with the RowLength of the poles.
        	:param Poles:
        	:type Poles: TColgp_Array2OfPnt
        	:param Weights:
        	:type Weights: TColStd_Array2OfReal
        	:param UKnots:
        	:type UKnots: TColStd_Array1OfReal
        	:param VKnots:
        	:type VKnots: TColStd_Array1OfReal
        	:param UMults:
        	:type UMults: TColStd_Array1OfInteger
        	:param VMults:
        	:type VMults: TColStd_Array1OfInteger
        	:param UDegree:
        	:type UDegree: int
        	:param VDegree:
        	:type VDegree: int
        	:param UPeriodic: default value is Standard_False
        	:type UPeriodic: bool
        	:param VPeriodic: default value is Standard_False
        	:type VPeriodic: bool
        	:rtype: None
        """
        _Geom.Geom_BSplineSurface_swiginit(self, _Geom.new_Geom_BSplineSurface(*args))
    IncreaseDegree = _swig_new_instance_method(_Geom.Geom_BSplineSurface_IncreaseDegree)
    IncreaseUMultiplicity = _swig_new_instance_method(_Geom.Geom_BSplineSurface_IncreaseUMultiplicity)
    IncreaseVMultiplicity = _swig_new_instance_method(_Geom.Geom_BSplineSurface_IncreaseVMultiplicity)
    IncrementUMultiplicity = _swig_new_instance_method(_Geom.Geom_BSplineSurface_IncrementUMultiplicity)
    IncrementVMultiplicity = _swig_new_instance_method(_Geom.Geom_BSplineSurface_IncrementVMultiplicity)
    InsertUKnot = _swig_new_instance_method(_Geom.Geom_BSplineSurface_InsertUKnot)
    InsertUKnots = _swig_new_instance_method(_Geom.Geom_BSplineSurface_InsertUKnots)
    InsertVKnot = _swig_new_instance_method(_Geom.Geom_BSplineSurface_InsertVKnot)
    InsertVKnots = _swig_new_instance_method(_Geom.Geom_BSplineSurface_InsertVKnots)
    IsURational = _swig_new_instance_method(_Geom.Geom_BSplineSurface_IsURational)
    IsVRational = _swig_new_instance_method(_Geom.Geom_BSplineSurface_IsVRational)
    LastUKnotIndex = _swig_new_instance_method(_Geom.Geom_BSplineSurface_LastUKnotIndex)
    LastVKnotIndex = _swig_new_instance_method(_Geom.Geom_BSplineSurface_LastVKnotIndex)
    LocalD0 = _swig_new_instance_method(_Geom.Geom_BSplineSurface_LocalD0)
    LocalD1 = _swig_new_instance_method(_Geom.Geom_BSplineSurface_LocalD1)
    LocalD2 = _swig_new_instance_method(_Geom.Geom_BSplineSurface_LocalD2)
    LocalD3 = _swig_new_instance_method(_Geom.Geom_BSplineSurface_LocalD3)
    LocalDN = _swig_new_instance_method(_Geom.Geom_BSplineSurface_LocalDN)
    LocalValue = _swig_new_instance_method(_Geom.Geom_BSplineSurface_LocalValue)
    LocateU = _swig_new_instance_method(_Geom.Geom_BSplineSurface_LocateU)
    LocateV = _swig_new_instance_method(_Geom.Geom_BSplineSurface_LocateV)
    MaxDegree = _swig_new_static_method(_Geom.Geom_BSplineSurface_MaxDegree)
    MovePoint = _swig_new_instance_method(_Geom.Geom_BSplineSurface_MovePoint)
    NbUKnots = _swig_new_instance_method(_Geom.Geom_BSplineSurface_NbUKnots)
    NbUPoles = _swig_new_instance_method(_Geom.Geom_BSplineSurface_NbUPoles)
    NbVKnots = _swig_new_instance_method(_Geom.Geom_BSplineSurface_NbVKnots)
    NbVPoles = _swig_new_instance_method(_Geom.Geom_BSplineSurface_NbVPoles)
    PeriodicNormalization = _swig_new_instance_method(_Geom.Geom_BSplineSurface_PeriodicNormalization)
    Pole = _swig_new_instance_method(_Geom.Geom_BSplineSurface_Pole)
    Poles = _swig_new_instance_method(_Geom.Geom_BSplineSurface_Poles)
    RemoveUKnot = _swig_new_instance_method(_Geom.Geom_BSplineSurface_RemoveUKnot)
    RemoveVKnot = _swig_new_instance_method(_Geom.Geom_BSplineSurface_RemoveVKnot)
    Resolution = _swig_new_instance_method(_Geom.Geom_BSplineSurface_Resolution)
    Segment = _swig_new_instance_method(_Geom.Geom_BSplineSurface_Segment)
    SetPole = _swig_new_instance_method(_Geom.Geom_BSplineSurface_SetPole)
    SetPoleCol = _swig_new_instance_method(_Geom.Geom_BSplineSurface_SetPoleCol)
    SetPoleRow = _swig_new_instance_method(_Geom.Geom_BSplineSurface_SetPoleRow)
    SetUKnot = _swig_new_instance_method(_Geom.Geom_BSplineSurface_SetUKnot)
    SetUKnots = _swig_new_instance_method(_Geom.Geom_BSplineSurface_SetUKnots)
    SetUNotPeriodic = _swig_new_instance_method(_Geom.Geom_BSplineSurface_SetUNotPeriodic)
    SetUOrigin = _swig_new_instance_method(_Geom.Geom_BSplineSurface_SetUOrigin)
    SetUPeriodic = _swig_new_instance_method(_Geom.Geom_BSplineSurface_SetUPeriodic)
    SetVKnot = _swig_new_instance_method(_Geom.Geom_BSplineSurface_SetVKnot)
    SetVKnots = _swig_new_instance_method(_Geom.Geom_BSplineSurface_SetVKnots)
    SetVNotPeriodic = _swig_new_instance_method(_Geom.Geom_BSplineSurface_SetVNotPeriodic)
    SetVOrigin = _swig_new_instance_method(_Geom.Geom_BSplineSurface_SetVOrigin)
    SetVPeriodic = _swig_new_instance_method(_Geom.Geom_BSplineSurface_SetVPeriodic)
    SetWeight = _swig_new_instance_method(_Geom.Geom_BSplineSurface_SetWeight)
    SetWeightCol = _swig_new_instance_method(_Geom.Geom_BSplineSurface_SetWeightCol)
    SetWeightRow = _swig_new_instance_method(_Geom.Geom_BSplineSurface_SetWeightRow)
    UDegree = _swig_new_instance_method(_Geom.Geom_BSplineSurface_UDegree)
    UIso = _swig_new_instance_method(_Geom.Geom_BSplineSurface_UIso)
    UKnot = _swig_new_instance_method(_Geom.Geom_BSplineSurface_UKnot)
    UKnotDistribution = _swig_new_instance_method(_Geom.Geom_BSplineSurface_UKnotDistribution)
    UKnotSequence = _swig_new_instance_method(_Geom.Geom_BSplineSurface_UKnotSequence)
    UKnots = _swig_new_instance_method(_Geom.Geom_BSplineSurface_UKnots)
    UMultiplicities = _swig_new_instance_method(_Geom.Geom_BSplineSurface_UMultiplicities)
    UMultiplicity = _swig_new_instance_method(_Geom.Geom_BSplineSurface_UMultiplicity)
    VDegree = _swig_new_instance_method(_Geom.Geom_BSplineSurface_VDegree)
    VIso = _swig_new_instance_method(_Geom.Geom_BSplineSurface_VIso)
    VKnot = _swig_new_instance_method(_Geom.Geom_BSplineSurface_VKnot)
    VKnotDistribution = _swig_new_instance_method(_Geom.Geom_BSplineSurface_VKnotDistribution)
    VKnotSequence = _swig_new_instance_method(_Geom.Geom_BSplineSurface_VKnotSequence)
    VKnots = _swig_new_instance_method(_Geom.Geom_BSplineSurface_VKnots)
    VMultiplicities = _swig_new_instance_method(_Geom.Geom_BSplineSurface_VMultiplicities)
    VMultiplicity = _swig_new_instance_method(_Geom.Geom_BSplineSurface_VMultiplicity)
    Weight = _swig_new_instance_method(_Geom.Geom_BSplineSurface_Weight)
    Weights = _swig_new_instance_method(_Geom.Geom_BSplineSurface_Weights)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_BSplineSurface_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_BSplineSurface

# Register Geom_BSplineSurface in _Geom:
_Geom.Geom_BSplineSurface_swigregister(Geom_BSplineSurface)
Geom_BSplineSurface_MaxDegree = _Geom.Geom_BSplineSurface_MaxDegree

class Geom_BezierCurve(Geom_BoundedCurve):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Degree = _swig_new_instance_method(_Geom.Geom_BezierCurve_Degree)

    def __init__(self, *args):
        r"""
        * Creates a non rational Bezier curve with a set of poles CurvePoles. The weights are defaulted to all being 1. Raises ConstructionError if the number of poles is greater than MaxDegree + 1 or lower than 2.
        	:param CurvePoles:
        	:type CurvePoles: TColgp_Array1OfPnt
        	:rtype: None* Creates a rational Bezier curve with the set of poles CurvePoles and the set of weights PoleWeights . If all the weights are identical the curve is considered as non rational. Raises ConstructionError if the number of poles is greater than MaxDegree + 1 or lower than 2 or CurvePoles and CurveWeights have not the same length or one weight value is lower or equal to Resolution from package gp.
        	:param CurvePoles:
        	:type CurvePoles: TColgp_Array1OfPnt
        	:param PoleWeights:
        	:type PoleWeights: TColStd_Array1OfReal
        	:rtype: None
        """
        _Geom.Geom_BezierCurve_swiginit(self, _Geom.new_Geom_BezierCurve(*args))
    Increase = _swig_new_instance_method(_Geom.Geom_BezierCurve_Increase)
    InsertPoleAfter = _swig_new_instance_method(_Geom.Geom_BezierCurve_InsertPoleAfter)
    InsertPoleBefore = _swig_new_instance_method(_Geom.Geom_BezierCurve_InsertPoleBefore)
    IsRational = _swig_new_instance_method(_Geom.Geom_BezierCurve_IsRational)
    MaxDegree = _swig_new_static_method(_Geom.Geom_BezierCurve_MaxDegree)
    NbPoles = _swig_new_instance_method(_Geom.Geom_BezierCurve_NbPoles)
    Pole = _swig_new_instance_method(_Geom.Geom_BezierCurve_Pole)
    Poles = _swig_new_instance_method(_Geom.Geom_BezierCurve_Poles)
    RemovePole = _swig_new_instance_method(_Geom.Geom_BezierCurve_RemovePole)
    Resolution = _swig_new_instance_method(_Geom.Geom_BezierCurve_Resolution)
    Segment = _swig_new_instance_method(_Geom.Geom_BezierCurve_Segment)
    SetPole = _swig_new_instance_method(_Geom.Geom_BezierCurve_SetPole)
    SetWeight = _swig_new_instance_method(_Geom.Geom_BezierCurve_SetWeight)
    Weight = _swig_new_instance_method(_Geom.Geom_BezierCurve_Weight)
    Weights = _swig_new_instance_method(_Geom.Geom_BezierCurve_Weights)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_BezierCurve_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_BezierCurve

# Register Geom_BezierCurve in _Geom:
_Geom.Geom_BezierCurve_swigregister(Geom_BezierCurve)
Geom_BezierCurve_MaxDegree = _Geom.Geom_BezierCurve_MaxDegree

class Geom_BezierSurface(Geom_BoundedSurface):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ExchangeUV = _swig_new_instance_method(_Geom.Geom_BezierSurface_ExchangeUV)

    def __init__(self, *args):
        r"""
        * Creates a non-rational Bezier surface with a set of poles. Control points representation : SPoles(Uorigin,Vorigin) ...................SPoles(Uorigin,Vend) .  . .  . SPoles(Uend, Vorigin) .....................SPoles(Uend, Vend) For the double array the row indice corresponds to the parametric U direction and the columns indice corresponds to the parametric V direction. The weights are defaulted to all being 1. //! Raised if the number of poles of the surface is lower than 2 or greater than MaxDegree + 1 in one of the two directions U or V.
        	:param SurfacePoles:
        	:type SurfacePoles: TColgp_Array2OfPnt
        	:rtype: None* ---Purpose Creates a rational Bezier surface with a set of poles and a set of weights. For the double array the row indice corresponds to the parametric U direction and the columns indice corresponds to the parametric V direction. If all the weights are identical the surface is considered as non-rational (the tolerance criterion is Resolution from package gp). //! Raised if SurfacePoles and PoleWeights have not the same Rowlength or have not the same ColLength. Raised if PoleWeights (i, j) <= Resolution from gp; Raised if the number of poles of the surface is lower than 2 or greater than MaxDegree + 1 in one of the two directions U or V.
        	:param SurfacePoles:
        	:type SurfacePoles: TColgp_Array2OfPnt
        	:param PoleWeights:
        	:type PoleWeights: TColStd_Array2OfReal
        	:rtype: None
        """
        _Geom.Geom_BezierSurface_swiginit(self, _Geom.new_Geom_BezierSurface(*args))
    Increase = _swig_new_instance_method(_Geom.Geom_BezierSurface_Increase)
    InsertPoleColAfter = _swig_new_instance_method(_Geom.Geom_BezierSurface_InsertPoleColAfter)
    InsertPoleColBefore = _swig_new_instance_method(_Geom.Geom_BezierSurface_InsertPoleColBefore)
    InsertPoleRowAfter = _swig_new_instance_method(_Geom.Geom_BezierSurface_InsertPoleRowAfter)
    InsertPoleRowBefore = _swig_new_instance_method(_Geom.Geom_BezierSurface_InsertPoleRowBefore)
    IsURational = _swig_new_instance_method(_Geom.Geom_BezierSurface_IsURational)
    IsVRational = _swig_new_instance_method(_Geom.Geom_BezierSurface_IsVRational)
    MaxDegree = _swig_new_static_method(_Geom.Geom_BezierSurface_MaxDegree)
    NbUPoles = _swig_new_instance_method(_Geom.Geom_BezierSurface_NbUPoles)
    NbVPoles = _swig_new_instance_method(_Geom.Geom_BezierSurface_NbVPoles)
    Pole = _swig_new_instance_method(_Geom.Geom_BezierSurface_Pole)
    Poles = _swig_new_instance_method(_Geom.Geom_BezierSurface_Poles)
    RemovePoleCol = _swig_new_instance_method(_Geom.Geom_BezierSurface_RemovePoleCol)
    RemovePoleRow = _swig_new_instance_method(_Geom.Geom_BezierSurface_RemovePoleRow)
    Resolution = _swig_new_instance_method(_Geom.Geom_BezierSurface_Resolution)
    Segment = _swig_new_instance_method(_Geom.Geom_BezierSurface_Segment)
    SetPole = _swig_new_instance_method(_Geom.Geom_BezierSurface_SetPole)
    SetPoleCol = _swig_new_instance_method(_Geom.Geom_BezierSurface_SetPoleCol)
    SetPoleRow = _swig_new_instance_method(_Geom.Geom_BezierSurface_SetPoleRow)
    SetWeight = _swig_new_instance_method(_Geom.Geom_BezierSurface_SetWeight)
    SetWeightCol = _swig_new_instance_method(_Geom.Geom_BezierSurface_SetWeightCol)
    SetWeightRow = _swig_new_instance_method(_Geom.Geom_BezierSurface_SetWeightRow)
    UDegree = _swig_new_instance_method(_Geom.Geom_BezierSurface_UDegree)
    VDegree = _swig_new_instance_method(_Geom.Geom_BezierSurface_VDegree)
    Weight = _swig_new_instance_method(_Geom.Geom_BezierSurface_Weight)
    Weights = _swig_new_instance_method(_Geom.Geom_BezierSurface_Weights)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_BezierSurface_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_BezierSurface

# Register Geom_BezierSurface in _Geom:
_Geom.Geom_BezierSurface_swigregister(Geom_BezierSurface)
Geom_BezierSurface_MaxDegree = _Geom.Geom_BezierSurface_MaxDegree

class Geom_Circle(Geom_Conic):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Circ = _swig_new_instance_method(_Geom.Geom_Circle_Circ)

    def __init__(self, *args):
        r"""
        * Constructs a circle by conversion of the gp_Circ circle C.
        	:param C:
        	:type C: gp_Circ
        	:rtype: None* Constructs a circle of radius Radius, where A2 locates the circle and defines its orientation in 3D space such that: - the center of the circle is the origin of A2, - the origin, 'X Direction' and 'Y Direction' of A2 define the plane of the circle, - A2 is the local coordinate system of the circle. Note: It is possible to create a circle where Radius is equal to 0.0. raised if Radius < 0.
        	:param A2:
        	:type A2: gp_Ax2
        	:param Radius:
        	:type Radius: float
        	:rtype: None
        """
        _Geom.Geom_Circle_swiginit(self, _Geom.new_Geom_Circle(*args))
    Radius = _swig_new_instance_method(_Geom.Geom_Circle_Radius)
    SetCirc = _swig_new_instance_method(_Geom.Geom_Circle_SetCirc)
    SetRadius = _swig_new_instance_method(_Geom.Geom_Circle_SetRadius)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_Circle_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_Circle

# Register Geom_Circle in _Geom:
_Geom.Geom_Circle_swigregister(Geom_Circle)

class Geom_ConicalSurface(Geom_ElementarySurface):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Apex = _swig_new_instance_method(_Geom.Geom_ConicalSurface_Apex)
    Coefficients = _swig_new_instance_method(_Geom.Geom_ConicalSurface_Coefficients)
    Cone = _swig_new_instance_method(_Geom.Geom_ConicalSurface_Cone)

    def __init__(self, *args):
        r"""
        * A3 defines the local coordinate system of the conical surface. Ang is the conical surface semi-angle. Its absolute value is in range ]0, PI/2[. Radius is the radius of the circle Viso in the placement plane of the conical surface defined with 'XAxis' and 'YAxis'. The 'ZDirection' of A3 defines the direction of the surface's axis of symmetry. If the location point of A3 is the apex of the surface Radius = 0 . At the creation the parametrization of the surface is defined such that the normal Vector (N = D1U ^ D1V) is oriented towards the 'outside region' of the surface. //! Raised if Radius < 0.0 or Abs(Ang) < Resolution from gp or Abs(Ang) >= PI/2 - Resolution
        	:param A3:
        	:type A3: gp_Ax3
        	:param Ang:
        	:type Ang: float
        	:param Radius:
        	:type Radius: float
        	:rtype: None* Creates a ConicalSurface from a non transient Cone from package gp.
        	:param C:
        	:type C: gp_Cone
        	:rtype: None
        """
        _Geom.Geom_ConicalSurface_swiginit(self, _Geom.new_Geom_ConicalSurface(*args))
    RefRadius = _swig_new_instance_method(_Geom.Geom_ConicalSurface_RefRadius)
    SemiAngle = _swig_new_instance_method(_Geom.Geom_ConicalSurface_SemiAngle)
    SetCone = _swig_new_instance_method(_Geom.Geom_ConicalSurface_SetCone)
    SetRadius = _swig_new_instance_method(_Geom.Geom_ConicalSurface_SetRadius)
    SetSemiAngle = _swig_new_instance_method(_Geom.Geom_ConicalSurface_SetSemiAngle)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_ConicalSurface_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_ConicalSurface

# Register Geom_ConicalSurface in _Geom:
_Geom.Geom_ConicalSurface_swigregister(Geom_ConicalSurface)

class Geom_CylindricalSurface(Geom_ElementarySurface):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Coefficients = _swig_new_instance_method(_Geom.Geom_CylindricalSurface_Coefficients)
    Cylinder = _swig_new_instance_method(_Geom.Geom_CylindricalSurface_Cylinder)

    def __init__(self, *args):
        r"""
        * A3 defines the local coordinate system of the cylindrical surface. The 'ZDirection' of A3 defines the direction of the surface's axis of symmetry. At the creation the parametrization of the surface is defined such that the normal Vector (N = D1U ^ D1V) is oriented towards the 'outside region' of the surface. Warnings : It is not forbidden to create a cylindrical surface with Radius = 0.0 Raised if Radius < 0.0
        	:param A3:
        	:type A3: gp_Ax3
        	:param Radius:
        	:type Radius: float
        	:rtype: None* Creates a CylindricalSurface from a non transient Cylinder from package gp.
        	:param C:
        	:type C: gp_Cylinder
        	:rtype: None
        """
        _Geom.Geom_CylindricalSurface_swiginit(self, _Geom.new_Geom_CylindricalSurface(*args))
    Radius = _swig_new_instance_method(_Geom.Geom_CylindricalSurface_Radius)
    SetCylinder = _swig_new_instance_method(_Geom.Geom_CylindricalSurface_SetCylinder)
    SetRadius = _swig_new_instance_method(_Geom.Geom_CylindricalSurface_SetRadius)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_CylindricalSurface_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_CylindricalSurface

# Register Geom_CylindricalSurface in _Geom:
_Geom.Geom_CylindricalSurface_swigregister(Geom_CylindricalSurface)

class Geom_Ellipse(Geom_Conic):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Directrix1 = _swig_new_instance_method(_Geom.Geom_Ellipse_Directrix1)
    Directrix2 = _swig_new_instance_method(_Geom.Geom_Ellipse_Directrix2)
    Elips = _swig_new_instance_method(_Geom.Geom_Ellipse_Elips)
    Focal = _swig_new_instance_method(_Geom.Geom_Ellipse_Focal)
    Focus1 = _swig_new_instance_method(_Geom.Geom_Ellipse_Focus1)
    Focus2 = _swig_new_instance_method(_Geom.Geom_Ellipse_Focus2)

    def __init__(self, *args):
        r"""
        * Constructs an ellipse by conversion of the gp_Elips ellipse E.
        	:param E:
        	:type E: gp_Elips
        	:rtype: None* Constructs an ellipse defined by its major and minor radii, MajorRadius and MinorRadius, where A2 locates the ellipse and defines its orientation in 3D space such that: - the center of the ellipse is the origin of A2, - the 'X Direction' of A2 defines the major axis of the ellipse, i.e. the major radius MajorRadius is measured along this axis, - the 'Y Direction' of A2 defines the minor axis of the ellipse, i.e. the minor radius MinorRadius is measured along this axis, - A2 is the local coordinate system of the ellipse. Exceptions Standard_ConstructionError if: - MajorRadius is less than MinorRadius, or - MinorRadius is less than 0. Warning The Geom package does not prevent the construction of an ellipse where MajorRadius and MinorRadius are equal.
        	:param A2:
        	:type A2: gp_Ax2
        	:param MajorRadius:
        	:type MajorRadius: float
        	:param MinorRadius:
        	:type MinorRadius: float
        	:rtype: None
        """
        _Geom.Geom_Ellipse_swiginit(self, _Geom.new_Geom_Ellipse(*args))
    MajorRadius = _swig_new_instance_method(_Geom.Geom_Ellipse_MajorRadius)
    MinorRadius = _swig_new_instance_method(_Geom.Geom_Ellipse_MinorRadius)
    Parameter = _swig_new_instance_method(_Geom.Geom_Ellipse_Parameter)
    SetElips = _swig_new_instance_method(_Geom.Geom_Ellipse_SetElips)
    SetMajorRadius = _swig_new_instance_method(_Geom.Geom_Ellipse_SetMajorRadius)
    SetMinorRadius = _swig_new_instance_method(_Geom.Geom_Ellipse_SetMinorRadius)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_Ellipse_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_Ellipse

# Register Geom_Ellipse in _Geom:
_Geom.Geom_Ellipse_swigregister(Geom_Ellipse)

class Geom_Hyperbola(Geom_Conic):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Asymptote1 = _swig_new_instance_method(_Geom.Geom_Hyperbola_Asymptote1)
    Asymptote2 = _swig_new_instance_method(_Geom.Geom_Hyperbola_Asymptote2)
    ConjugateBranch1 = _swig_new_instance_method(_Geom.Geom_Hyperbola_ConjugateBranch1)
    ConjugateBranch2 = _swig_new_instance_method(_Geom.Geom_Hyperbola_ConjugateBranch2)
    Directrix1 = _swig_new_instance_method(_Geom.Geom_Hyperbola_Directrix1)
    Directrix2 = _swig_new_instance_method(_Geom.Geom_Hyperbola_Directrix2)
    Focal = _swig_new_instance_method(_Geom.Geom_Hyperbola_Focal)
    Focus1 = _swig_new_instance_method(_Geom.Geom_Hyperbola_Focus1)
    Focus2 = _swig_new_instance_method(_Geom.Geom_Hyperbola_Focus2)

    def __init__(self, *args):
        r"""
        * Constructs a hyperbola by conversion of the gp_Hypr hyperbola H.
        	:param H:
        	:type H: gp_Hypr
        	:rtype: None* Constructs a hyperbola defined by its major and minor radii, MajorRadius and MinorRadius, where A2 locates the hyperbola and defines its orientation in 3D space such that: - the center of the hyperbola is the origin of A2, - the 'X Direction' of A2 defines the major axis of the hyperbola, i.e. the major radius MajorRadius is measured along this axis, - the 'Y Direction' of A2 defines the minor axis of the hyperbola, i.e. the minor radius MinorRadius is measured along this axis, - A2 is the local coordinate system of the hyperbola. Exceptions Standard_ConstructionError if: - MajorRadius is less than 0.0, - MinorRadius is less than 0.0.
        	:param A2:
        	:type A2: gp_Ax2
        	:param MajorRadius:
        	:type MajorRadius: float
        	:param MinorRadius:
        	:type MinorRadius: float
        	:rtype: None
        """
        _Geom.Geom_Hyperbola_swiginit(self, _Geom.new_Geom_Hyperbola(*args))
    Hypr = _swig_new_instance_method(_Geom.Geom_Hyperbola_Hypr)
    MajorRadius = _swig_new_instance_method(_Geom.Geom_Hyperbola_MajorRadius)
    MinorRadius = _swig_new_instance_method(_Geom.Geom_Hyperbola_MinorRadius)
    OtherBranch = _swig_new_instance_method(_Geom.Geom_Hyperbola_OtherBranch)
    Parameter = _swig_new_instance_method(_Geom.Geom_Hyperbola_Parameter)
    SetHypr = _swig_new_instance_method(_Geom.Geom_Hyperbola_SetHypr)
    SetMajorRadius = _swig_new_instance_method(_Geom.Geom_Hyperbola_SetMajorRadius)
    SetMinorRadius = _swig_new_instance_method(_Geom.Geom_Hyperbola_SetMinorRadius)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_Hyperbola_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_Hyperbola

# Register Geom_Hyperbola in _Geom:
_Geom.Geom_Hyperbola_swigregister(Geom_Hyperbola)

class Geom_Parabola(Geom_Conic):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Directrix = _swig_new_instance_method(_Geom.Geom_Parabola_Directrix)
    Focal = _swig_new_instance_method(_Geom.Geom_Parabola_Focal)
    Focus = _swig_new_instance_method(_Geom.Geom_Parabola_Focus)

    def __init__(self, *args):
        r"""
        * Creates a parabola from a non transient one.
        	:param Prb:
        	:type Prb: gp_Parab
        	:rtype: None* Creates a parabola with its local coordinate system 'A2' and it's focal length 'Focal'. The XDirection of A2 defines the axis of symmetry of the parabola. The YDirection of A2 is parallel to the directrix of the parabola. The Location point of A2 is the vertex of the parabola Raised if Focal < 0.0
        	:param A2:
        	:type A2: gp_Ax2
        	:param Focal:
        	:type Focal: float
        	:rtype: None* D is the directrix of the parabola and F the focus point. The symmetry axis (XAxis) of the parabola is normal to the directrix and pass through the focus point F, but its location point is the vertex of the parabola. The YAxis of the parabola is parallel to D and its location point is the vertex of the parabola. The normal to the plane of the parabola is the cross product between the XAxis and the YAxis.
        	:param D:
        	:type D: gp_Ax1
        	:param F:
        	:type F: gp_Pnt
        	:rtype: None
        """
        _Geom.Geom_Parabola_swiginit(self, _Geom.new_Geom_Parabola(*args))
    Parab = _swig_new_instance_method(_Geom.Geom_Parabola_Parab)
    Parameter = _swig_new_instance_method(_Geom.Geom_Parabola_Parameter)
    SetFocal = _swig_new_instance_method(_Geom.Geom_Parabola_SetFocal)
    SetParab = _swig_new_instance_method(_Geom.Geom_Parabola_SetParab)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_Parabola_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_Parabola

# Register Geom_Parabola in _Geom:
_Geom.Geom_Parabola_swigregister(Geom_Parabola)

class Geom_Plane(Geom_ElementarySurface):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Coefficients = _swig_new_instance_method(_Geom.Geom_Plane_Coefficients)

    def __init__(self, *args):
        r"""
        * Creates a plane located in 3D space with an axis placement three axis. The 'ZDirection' of 'A3' is the direction normal to the plane. The 'Location' point of 'A3' is the origin of the plane. The 'XDirection' and 'YDirection' of 'A3' define the directions of the U isoparametric and V isoparametric curves.
        	:param A3:
        	:type A3: gp_Ax3
        	:rtype: None* Creates a plane from a non transient plane from package gp.
        	:param Pl:
        	:type Pl: gp_Pln
        	:rtype: None* P is the 'Location' point or origin of the plane. V is the direction normal to the plane.
        	:param P:
        	:type P: gp_Pnt
        	:param V:
        	:type V: gp_Dir
        	:rtype: None* Creates a plane from its cartesian equation : Ax + By + Cz + D = 0.0 //! Raised if Sqrt (A*A + B*B + C*C) <= Resolution from gp
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param C:
        	:type C: float
        	:param D:
        	:type D: float
        	:rtype: None
        """
        _Geom.Geom_Plane_swiginit(self, _Geom.new_Geom_Plane(*args))
    Pln = _swig_new_instance_method(_Geom.Geom_Plane_Pln)
    SetPln = _swig_new_instance_method(_Geom.Geom_Plane_SetPln)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_Plane_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_Plane

# Register Geom_Plane in _Geom:
_Geom.Geom_Plane_swigregister(Geom_Plane)

class Geom_RectangularTrimmedSurface(Geom_BoundedSurface):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    BasisSurface = _swig_new_instance_method(_Geom.Geom_RectangularTrimmedSurface_BasisSurface)

    def __init__(self, *args):
        r"""
        * The U parametric direction of the surface is oriented from U1 to U2. The V parametric direction of the surface is oriented from V1 to V2. These two directions define the orientation of the surface (normal). If the surface is not periodic USense and VSense are not used for the construction. If the surface S is periodic in one direction USense and VSense give the available part of the surface. By default in this case the surface has the same orientation as the basis surface S. The returned surface is not closed and not periodic. ConstructionError Raised if S is not periodic in the UDirection and U1 or U2 are out of the bounds of S. S is not periodic in the VDirection and V1 or V2 are out of the bounds of S. U1 = U2 or V1 = V2
        	:param S:
        	:type S: Geom_Surface
        	:param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:param V1:
        	:type V1: float
        	:param V2:
        	:type V2: float
        	:param USense: default value is Standard_True
        	:type USense: bool
        	:param VSense: default value is Standard_True
        	:type VSense: bool
        	:rtype: None* The basis surface S is only trim in one parametric direction. If UTrim = True the surface is trimmed in the U parametric direction else the surface is trimmed in the V parametric direction. In the considered parametric direction the resulting surface is oriented from Param1 to Param2. If S is periodic Sense gives the available part of the surface. By default the trimmed surface has the same orientation as the basis surface S in the considered parametric direction (Sense = True). If the basis surface S is closed or periodic in the parametric direction opposite to the trimming direction the trimmed surface has the same characteristics as the surface S in this direction. Warnings : In this package the entities are not shared. The RectangularTrimmedSurface is built with a copy of the surface S. So when S is modified the RectangularTrimmedSurface is not modified Raised if S is not periodic in the considered parametric direction and Param1 or Param2 are out of the bounds of S. Param1 = Param2
        	:param S:
        	:type S: Geom_Surface
        	:param Param1:
        	:type Param1: float
        	:param Param2:
        	:type Param2: float
        	:param UTrim:
        	:type UTrim: bool
        	:param Sense: default value is Standard_True
        	:type Sense: bool
        	:rtype: None
        """
        _Geom.Geom_RectangularTrimmedSurface_swiginit(self, _Geom.new_Geom_RectangularTrimmedSurface(*args))
    SetTrim = _swig_new_instance_method(_Geom.Geom_RectangularTrimmedSurface_SetTrim)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_RectangularTrimmedSurface_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_RectangularTrimmedSurface

# Register Geom_RectangularTrimmedSurface in _Geom:
_Geom.Geom_RectangularTrimmedSurface_swigregister(Geom_RectangularTrimmedSurface)

class Geom_SphericalSurface(Geom_ElementarySurface):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Area = _swig_new_instance_method(_Geom.Geom_SphericalSurface_Area)
    Coefficients = _swig_new_instance_method(_Geom.Geom_SphericalSurface_Coefficients)

    def __init__(self, *args):
        r"""
        * A3 is the local coordinate system of the surface. At the creation the parametrization of the surface is defined such as the normal Vector (N = D1U ^ D1V) is directed away from the center of the sphere. The direction of increasing parametric value V is defined by the rotation around the 'YDirection' of A2 in the trigonometric sense and the orientation of increasing parametric value U is defined by the rotation around the main direction of A2 in the trigonometric sense. Warnings : It is not forbidden to create a spherical surface with Radius = 0.0 Raised if Radius < 0.0.
        	:param A3:
        	:type A3: gp_Ax3
        	:param Radius:
        	:type Radius: float
        	:rtype: None* Creates a SphericalSurface from a non persistent Sphere from package gp.
        	:param S:
        	:type S: gp_Sphere
        	:rtype: None
        """
        _Geom.Geom_SphericalSurface_swiginit(self, _Geom.new_Geom_SphericalSurface(*args))
    Radius = _swig_new_instance_method(_Geom.Geom_SphericalSurface_Radius)
    SetRadius = _swig_new_instance_method(_Geom.Geom_SphericalSurface_SetRadius)
    SetSphere = _swig_new_instance_method(_Geom.Geom_SphericalSurface_SetSphere)
    Sphere = _swig_new_instance_method(_Geom.Geom_SphericalSurface_Sphere)
    Volume = _swig_new_instance_method(_Geom.Geom_SphericalSurface_Volume)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_SphericalSurface_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_SphericalSurface

# Register Geom_SphericalSurface in _Geom:
_Geom.Geom_SphericalSurface_swigregister(Geom_SphericalSurface)

class Geom_SurfaceOfLinearExtrusion(Geom_SweptSurface):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * V is the direction of extrusion. C is the extruded curve. The form of a SurfaceOfLinearExtrusion can be : . ruled surface (RuledForm), . a cylindrical surface if the extruded curve is a circle or a trimmed circle (CylindricalForm), . a plane surface if the extruded curve is a Line (PlanarForm). Warnings : Degenerated surface cases are not detected. For example if the curve C is a line and V is parallel to the direction of this line.
        	:param C:
        	:type C: Geom_Curve
        	:param V:
        	:type V: gp_Dir
        	:rtype: None
        """
        _Geom.Geom_SurfaceOfLinearExtrusion_swiginit(self, _Geom.new_Geom_SurfaceOfLinearExtrusion(*args))
    SetBasisCurve = _swig_new_instance_method(_Geom.Geom_SurfaceOfLinearExtrusion_SetBasisCurve)
    SetDirection = _swig_new_instance_method(_Geom.Geom_SurfaceOfLinearExtrusion_SetDirection)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_SurfaceOfLinearExtrusion_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_SurfaceOfLinearExtrusion

# Register Geom_SurfaceOfLinearExtrusion in _Geom:
_Geom.Geom_SurfaceOfLinearExtrusion_swigregister(Geom_SurfaceOfLinearExtrusion)

class Geom_SurfaceOfRevolution(Geom_SweptSurface):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Axis = _swig_new_instance_method(_Geom.Geom_SurfaceOfRevolution_Axis)

    def __init__(self, *args):
        r"""
        * C : is the meridian or the referenced curve. A1 is the axis of revolution. The form of a SurfaceOfRevolution can be : . a general revolution surface (RevolutionForm), . a conical surface if the meridian is a line or a trimmed line (ConicalForm), . a cylindrical surface if the meridian is a line or a trimmed line parallel to the revolution axis (CylindricalForm), . a planar surface if the meridian is a line perpendicular to the revolution axis of the surface (PlanarForm). . a spherical surface, . a toroidal surface, . a quadric surface. Warnings : It is not checked that the curve C is planar and that the surface axis is in the plane of the curve. It is not checked that the revolved curve C doesn't self-intersects.
        	:param C:
        	:type C: Geom_Curve
        	:param A1:
        	:type A1: gp_Ax1
        	:rtype: None
        """
        _Geom.Geom_SurfaceOfRevolution_swiginit(self, _Geom.new_Geom_SurfaceOfRevolution(*args))
    Location = _swig_new_instance_method(_Geom.Geom_SurfaceOfRevolution_Location)
    ReferencePlane = _swig_new_instance_method(_Geom.Geom_SurfaceOfRevolution_ReferencePlane)
    SetAxis = _swig_new_instance_method(_Geom.Geom_SurfaceOfRevolution_SetAxis)
    SetBasisCurve = _swig_new_instance_method(_Geom.Geom_SurfaceOfRevolution_SetBasisCurve)
    SetDirection = _swig_new_instance_method(_Geom.Geom_SurfaceOfRevolution_SetDirection)
    SetLocation = _swig_new_instance_method(_Geom.Geom_SurfaceOfRevolution_SetLocation)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_SurfaceOfRevolution_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_SurfaceOfRevolution

# Register Geom_SurfaceOfRevolution in _Geom:
_Geom.Geom_SurfaceOfRevolution_swigregister(Geom_SurfaceOfRevolution)

class Geom_ToroidalSurface(Geom_ElementarySurface):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Area = _swig_new_instance_method(_Geom.Geom_ToroidalSurface_Area)
    Coefficients = _swig_new_instance_method(_Geom.Geom_ToroidalSurface_Coefficients)

    def __init__(self, *args):
        r"""
        * A3 is the local coordinate system of the surface. The orientation of increasing V parametric value is defined by the rotation around the main axis (ZAxis) in the trigonometric sense. The parametrization of the surface in the U direction is defined such as the normal Vector (N = D1U ^ D1V) is oriented towards the 'outside region' of the surface. Warnings : It is not forbidden to create a toroidal surface with MajorRadius = MinorRadius = 0.0 //! Raised if MinorRadius < 0.0 or if MajorRadius < 0.0
        	:param A3:
        	:type A3: gp_Ax3
        	:param MajorRadius:
        	:type MajorRadius: float
        	:param MinorRadius:
        	:type MinorRadius: float
        	:rtype: None* Creates a ToroidalSurface from a non transient Torus from package gp.
        	:param T:
        	:type T: gp_Torus
        	:rtype: None
        """
        _Geom.Geom_ToroidalSurface_swiginit(self, _Geom.new_Geom_ToroidalSurface(*args))
    MajorRadius = _swig_new_instance_method(_Geom.Geom_ToroidalSurface_MajorRadius)
    MinorRadius = _swig_new_instance_method(_Geom.Geom_ToroidalSurface_MinorRadius)
    SetMajorRadius = _swig_new_instance_method(_Geom.Geom_ToroidalSurface_SetMajorRadius)
    SetMinorRadius = _swig_new_instance_method(_Geom.Geom_ToroidalSurface_SetMinorRadius)
    SetTorus = _swig_new_instance_method(_Geom.Geom_ToroidalSurface_SetTorus)
    Torus = _swig_new_instance_method(_Geom.Geom_ToroidalSurface_Torus)
    Volume = _swig_new_instance_method(_Geom.Geom_ToroidalSurface_Volume)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_ToroidalSurface_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_ToroidalSurface

# Register Geom_ToroidalSurface in _Geom:
_Geom.Geom_ToroidalSurface_swigregister(Geom_ToroidalSurface)

class Geom_TrimmedCurve(Geom_BoundedCurve):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    BasisCurve = _swig_new_instance_method(_Geom.Geom_TrimmedCurve_BasisCurve)

    def __init__(self, *args):
        r"""
        * Constructs a trimmed curve from the basis curve C which is limited between parameter values U1 and U2. Note: - U1 can be greater or less than U2; in both cases, the returned curve is oriented from U1 to U2. - If the basis curve C is periodic, there is an ambiguity because two parts are available. In this case, the trimmed curve has the same orientation as the basis curve if Sense is true (default value) or the opposite orientation if Sense is false. - If the curve is closed but not periodic, it is not possible to keep the part of the curve which includes the junction point (except if the junction point is at the beginning or at the end of the trimmed curve). If you tried to do this, you could alter the fundamental characteristics of the basis curve, which are used, for example, to compute the derivatives of the trimmed curve. The rules for a closed curve are therefore the same as those for an open curve. Warning: The trimmed curve is built from a copy of curve C. Therefore, when C is modified, the trimmed curve is not modified. - If the basis curve is periodic and theAdjustPeriodic is True, the bounds of the trimmed curve may be different from U1 and U2 if the parametric origin of the basis curve is within the arc of the trimmed curve. In this case, the modified parameter will be equal to U1 or U2 plus or minus the period. When theAdjustPeriodic is False, parameters U1 and U2 will be the same, without adjustment into the first period. Exceptions Standard_ConstructionError if: - C is not periodic and U1 or U2 is outside the bounds of C, or - U1 is equal to U2.
        	:param C:
        	:type C: Geom_Curve
        	:param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:param Sense: default value is Standard_True
        	:type Sense: bool
        	:param theAdjustPeriodic: default value is Standard_True
        	:type theAdjustPeriodic: bool
        	:rtype: None
        """
        _Geom.Geom_TrimmedCurve_swiginit(self, _Geom.new_Geom_TrimmedCurve(*args))
    SetTrim = _swig_new_instance_method(_Geom.Geom_TrimmedCurve_SetTrim)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_TrimmedCurve_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Geom.delete_Geom_TrimmedCurve

# Register Geom_TrimmedCurve in _Geom:
_Geom.Geom_TrimmedCurve_swigregister(Geom_TrimmedCurve)

class Geom_HSequenceOfBSplineSurface(Geom_SequenceOfBSplineSurface, OCC.Core.Standard.Standard_Transient):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Geom.Geom_HSequenceOfBSplineSurface_swiginit(self, _Geom.new_Geom_HSequenceOfBSplineSurface(*args))
    Sequence = _swig_new_instance_method(_Geom.Geom_HSequenceOfBSplineSurface_Sequence)
    Append = _swig_new_instance_method(_Geom.Geom_HSequenceOfBSplineSurface_Append)
    ChangeSequence = _swig_new_instance_method(_Geom.Geom_HSequenceOfBSplineSurface_ChangeSequence)


    @staticmethod
    def DownCast(t):
      return Handle_Geom_HSequenceOfBSplineSurface_DownCast(t)

    __swig_destroy__ = _Geom.delete_Geom_HSequenceOfBSplineSurface

# Register Geom_HSequenceOfBSplineSurface in _Geom:
_Geom.Geom_HSequenceOfBSplineSurface_swigregister(Geom_HSequenceOfBSplineSurface)



