# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
BRepGProp module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_brepgprop.html
"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _BRepGProp
else:
    import _BRepGProp

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _BRepGProp.SWIG_PyInstanceMethod_New
_swig_new_static_method = _BRepGProp.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BRepGProp.delete_SwigPyIterator
    value = _swig_new_instance_method(_BRepGProp.SwigPyIterator_value)
    incr = _swig_new_instance_method(_BRepGProp.SwigPyIterator_incr)
    decr = _swig_new_instance_method(_BRepGProp.SwigPyIterator_decr)
    distance = _swig_new_instance_method(_BRepGProp.SwigPyIterator_distance)
    equal = _swig_new_instance_method(_BRepGProp.SwigPyIterator_equal)
    copy = _swig_new_instance_method(_BRepGProp.SwigPyIterator_copy)
    next = _swig_new_instance_method(_BRepGProp.SwigPyIterator_next)
    __next__ = _swig_new_instance_method(_BRepGProp.SwigPyIterator___next__)
    previous = _swig_new_instance_method(_BRepGProp.SwigPyIterator_previous)
    advance = _swig_new_instance_method(_BRepGProp.SwigPyIterator_advance)
    __eq__ = _swig_new_instance_method(_BRepGProp.SwigPyIterator___eq__)
    __ne__ = _swig_new_instance_method(_BRepGProp.SwigPyIterator___ne__)
    __iadd__ = _swig_new_instance_method(_BRepGProp.SwigPyIterator___iadd__)
    __isub__ = _swig_new_instance_method(_BRepGProp.SwigPyIterator___isub__)
    __add__ = _swig_new_instance_method(_BRepGProp.SwigPyIterator___add__)
    __sub__ = _swig_new_instance_method(_BRepGProp.SwigPyIterator___sub__)
    def __iter__(self):
        return self

# Register SwigPyIterator in _BRepGProp:
_BRepGProp.SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.TopoDS
import OCC.Core.Message
import OCC.Core.TopAbs
import OCC.Core.TopLoc
import OCC.Core.gp
import OCC.Core.GProp
import OCC.Core.TColgp
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.BRepAdaptor
import OCC.Core.Adaptor3d
import OCC.Core.Geom
import OCC.Core.GeomAbs
import OCC.Core.Adaptor2d
import OCC.Core.Geom2d
import OCC.Core.math
import OCC.Core.GeomAdaptor
import OCC.Core.Geom2dAdaptor
class brepgprop(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    LinearProperties = _swig_new_static_method(_BRepGProp.brepgprop_LinearProperties)
    SurfaceProperties = _swig_new_static_method(_BRepGProp.brepgprop_SurfaceProperties)
    VolumeProperties = _swig_new_static_method(_BRepGProp.brepgprop_VolumeProperties)
    VolumePropertiesGK = _swig_new_static_method(_BRepGProp.brepgprop_VolumePropertiesGK)

    __repr__ = _dumps_object


    def __init__(self):
        _BRepGProp.brepgprop_swiginit(self, _BRepGProp.new_brepgprop())
    __swig_destroy__ = _BRepGProp.delete_brepgprop

# Register brepgprop in _BRepGProp:
_BRepGProp.brepgprop_swigregister(brepgprop)
brepgprop_LinearProperties = _BRepGProp.brepgprop_LinearProperties
brepgprop_SurfaceProperties = _BRepGProp.brepgprop_SurfaceProperties
brepgprop_VolumeProperties = _BRepGProp.brepgprop_VolumeProperties
brepgprop_VolumePropertiesGK = _BRepGProp.brepgprop_VolumePropertiesGK

class BRepGProp_Cinert(OCC.Core.GProp.GProp_GProps):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        :rtype: None:param C:
        	:type C: BRepAdaptor_Curve
        	:param CLocation:
        	:type CLocation: gp_Pnt
        	:rtype: None
        """
        _BRepGProp.BRepGProp_Cinert_swiginit(self, _BRepGProp.new_BRepGProp_Cinert(*args))
    Perform = _swig_new_instance_method(_BRepGProp.BRepGProp_Cinert_Perform)
    SetLocation = _swig_new_instance_method(_BRepGProp.BRepGProp_Cinert_SetLocation)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepGProp.delete_BRepGProp_Cinert

# Register BRepGProp_Cinert in _BRepGProp:
_BRepGProp.BRepGProp_Cinert_swigregister(BRepGProp_Cinert)

class BRepGProp_Domain(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Empty constructor.
        	:rtype: None* Constructor. Initializes the domain with the face.
        	:param F:
        	:type F: TopoDS_Face
        	:rtype: None
        """
        _BRepGProp.BRepGProp_Domain_swiginit(self, _BRepGProp.new_BRepGProp_Domain(*args))
    Init = _swig_new_instance_method(_BRepGProp.BRepGProp_Domain_Init)
    More = _swig_new_instance_method(_BRepGProp.BRepGProp_Domain_More)
    Next = _swig_new_instance_method(_BRepGProp.BRepGProp_Domain_Next)
    Value = _swig_new_instance_method(_BRepGProp.BRepGProp_Domain_Value)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepGProp.delete_BRepGProp_Domain

# Register BRepGProp_Domain in _BRepGProp:
_BRepGProp.BRepGProp_Domain_swigregister(BRepGProp_Domain)

class BRepGProp_EdgeTool(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    D1 = _swig_new_static_method(_BRepGProp.BRepGProp_EdgeTool_D1)
    FirstParameter = _swig_new_static_method(_BRepGProp.BRepGProp_EdgeTool_FirstParameter)
    IntegrationOrder = _swig_new_static_method(_BRepGProp.BRepGProp_EdgeTool_IntegrationOrder)
    Intervals = _swig_new_static_method(_BRepGProp.BRepGProp_EdgeTool_Intervals)
    LastParameter = _swig_new_static_method(_BRepGProp.BRepGProp_EdgeTool_LastParameter)
    NbIntervals = _swig_new_static_method(_BRepGProp.BRepGProp_EdgeTool_NbIntervals)
    Value = _swig_new_static_method(_BRepGProp.BRepGProp_EdgeTool_Value)

    __repr__ = _dumps_object


    def __init__(self):
        _BRepGProp.BRepGProp_EdgeTool_swiginit(self, _BRepGProp.new_BRepGProp_EdgeTool())
    __swig_destroy__ = _BRepGProp.delete_BRepGProp_EdgeTool

# Register BRepGProp_EdgeTool in _BRepGProp:
_BRepGProp.BRepGProp_EdgeTool_swigregister(BRepGProp_EdgeTool)
BRepGProp_EdgeTool_D1 = _BRepGProp.BRepGProp_EdgeTool_D1
BRepGProp_EdgeTool_FirstParameter = _BRepGProp.BRepGProp_EdgeTool_FirstParameter
BRepGProp_EdgeTool_IntegrationOrder = _BRepGProp.BRepGProp_EdgeTool_IntegrationOrder
BRepGProp_EdgeTool_Intervals = _BRepGProp.BRepGProp_EdgeTool_Intervals
BRepGProp_EdgeTool_LastParameter = _BRepGProp.BRepGProp_EdgeTool_LastParameter
BRepGProp_EdgeTool_NbIntervals = _BRepGProp.BRepGProp_EdgeTool_NbIntervals
BRepGProp_EdgeTool_Value = _BRepGProp.BRepGProp_EdgeTool_Value

class BRepGProp_Face(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Constructor. Initializes the object with a flag IsUseSpan that says if it is necessary to define spans on a face. This option has an effect only for BSpline faces. Spans are returned by the methods GetUKnots and GetTKnots.
        	:param IsUseSpan: default value is Standard_False
        	:type IsUseSpan: bool
        	:rtype: None* Constructor. Initializes the object with the face and the flag IsUseSpan that says if it is necessary to define spans on a face. This option has an effect only for BSpline faces. Spans are returned by the methods GetUKnots and GetTKnots.
        	:param F:
        	:type F: TopoDS_Face
        	:param IsUseSpan: default value is Standard_False
        	:type IsUseSpan: bool
        	:rtype: None
        """
        _BRepGProp.BRepGProp_Face_swiginit(self, _BRepGProp.new_BRepGProp_Face(*args))
    Bounds = _swig_new_instance_method(_BRepGProp.BRepGProp_Face_Bounds)
    D12d = _swig_new_instance_method(_BRepGProp.BRepGProp_Face_D12d)
    FirstParameter = _swig_new_instance_method(_BRepGProp.BRepGProp_Face_FirstParameter)
    GetFace = _swig_new_instance_method(_BRepGProp.BRepGProp_Face_GetFace)
    GetTKnots = _swig_new_instance_method(_BRepGProp.BRepGProp_Face_GetTKnots)
    GetUKnots = _swig_new_instance_method(_BRepGProp.BRepGProp_Face_GetUKnots)
    IntegrationOrder = _swig_new_instance_method(_BRepGProp.BRepGProp_Face_IntegrationOrder)
    LIntOrder = _swig_new_instance_method(_BRepGProp.BRepGProp_Face_LIntOrder)
    LIntSubs = _swig_new_instance_method(_BRepGProp.BRepGProp_Face_LIntSubs)
    LKnots = _swig_new_instance_method(_BRepGProp.BRepGProp_Face_LKnots)
    LastParameter = _swig_new_instance_method(_BRepGProp.BRepGProp_Face_LastParameter)
    Load = _swig_new_instance_method(_BRepGProp.BRepGProp_Face_Load)
    NaturalRestriction = _swig_new_instance_method(_BRepGProp.BRepGProp_Face_NaturalRestriction)
    Normal = _swig_new_instance_method(_BRepGProp.BRepGProp_Face_Normal)
    SIntOrder = _swig_new_instance_method(_BRepGProp.BRepGProp_Face_SIntOrder)
    SUIntSubs = _swig_new_instance_method(_BRepGProp.BRepGProp_Face_SUIntSubs)
    SVIntSubs = _swig_new_instance_method(_BRepGProp.BRepGProp_Face_SVIntSubs)
    UIntegrationOrder = _swig_new_instance_method(_BRepGProp.BRepGProp_Face_UIntegrationOrder)
    UKnots = _swig_new_instance_method(_BRepGProp.BRepGProp_Face_UKnots)
    VIntegrationOrder = _swig_new_instance_method(_BRepGProp.BRepGProp_Face_VIntegrationOrder)
    VKnots = _swig_new_instance_method(_BRepGProp.BRepGProp_Face_VKnots)
    Value2d = _swig_new_instance_method(_BRepGProp.BRepGProp_Face_Value2d)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepGProp.delete_BRepGProp_Face

# Register BRepGProp_Face in _BRepGProp:
_BRepGProp.BRepGProp_Face_swigregister(BRepGProp_Face)

class BRepGProp_Gauss(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Vinert = _BRepGProp.BRepGProp_Gauss_Vinert
    Sinert = _BRepGProp.BRepGProp_Gauss_Sinert

    def __init__(self, *args):
        r"""
        * Constructor
        	:param theType:
        	:type theType: BRepGProp_GaussType
        	:rtype: None
        """
        _BRepGProp.BRepGProp_Gauss_swiginit(self, _BRepGProp.new_BRepGProp_Gauss(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepGProp.delete_BRepGProp_Gauss

# Register BRepGProp_Gauss in _BRepGProp:
_BRepGProp.BRepGProp_Gauss_swigregister(BRepGProp_Gauss)

class BRepGProp_MeshCinert(OCC.Core.GProp.GProp_GProps):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r""":rtype: None"""
        _BRepGProp.BRepGProp_MeshCinert_swiginit(self, _BRepGProp.new_BRepGProp_MeshCinert(*args))
    Perform = _swig_new_instance_method(_BRepGProp.BRepGProp_MeshCinert_Perform)
    PreparePolygon = _swig_new_static_method(_BRepGProp.BRepGProp_MeshCinert_PreparePolygon)
    SetLocation = _swig_new_instance_method(_BRepGProp.BRepGProp_MeshCinert_SetLocation)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepGProp.delete_BRepGProp_MeshCinert

# Register BRepGProp_MeshCinert in _BRepGProp:
_BRepGProp.BRepGProp_MeshCinert_swigregister(BRepGProp_MeshCinert)
BRepGProp_MeshCinert_PreparePolygon = _BRepGProp.BRepGProp_MeshCinert_PreparePolygon

class BRepGProp_Sinert(OCC.Core.GProp.GProp_GProps):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        :rtype: None:param S:
        	:type S: BRepGProp_Face
        	:param SLocation:
        	:type SLocation: gp_Pnt
        	:rtype: None* Builds a Sinert to evaluate the global properties of the face <S>. If isNaturalRestriction is true the domain of S is defined with the natural bounds, else it defined with an iterator of Edge from TopoDS (see DomainTool from GProp)
        	:param S:
        	:type S: BRepGProp_Face
        	:param D:
        	:type D: BRepGProp_Domain
        	:param SLocation:
        	:type SLocation: gp_Pnt
        	:rtype: None:param S:
        	:type S: BRepGProp_Face
        	:param SLocation:
        	:type SLocation: gp_Pnt
        	:param Eps:
        	:type Eps: float
        	:rtype: None:param S:
        	:type S: BRepGProp_Face
        	:param D:
        	:type D: BRepGProp_Domain
        	:param SLocation:
        	:type SLocation: gp_Pnt
        	:param Eps:
        	:type Eps: float
        	:rtype: None
        """
        _BRepGProp.BRepGProp_Sinert_swiginit(self, _BRepGProp.new_BRepGProp_Sinert(*args))
    GetEpsilon = _swig_new_instance_method(_BRepGProp.BRepGProp_Sinert_GetEpsilon)
    Perform = _swig_new_instance_method(_BRepGProp.BRepGProp_Sinert_Perform)
    SetLocation = _swig_new_instance_method(_BRepGProp.BRepGProp_Sinert_SetLocation)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepGProp.delete_BRepGProp_Sinert

# Register BRepGProp_Sinert in _BRepGProp:
_BRepGProp.BRepGProp_Sinert_swigregister(BRepGProp_Sinert)

class BRepGProp_TFunction(OCC.Core.math.math_Function):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    AbsolutError = _swig_new_instance_method(_BRepGProp.BRepGProp_TFunction_AbsolutError)

    def __init__(self, *args):
        r"""
        * Constructor. Initializes the function with the face, the location point, the flag IsByPoint, the coefficients theCoeff that have different meaning depending on the value of IsByPoint. The last two parameters are theUMin - the lower bound of the inner integral. This value is fixed for any integral. And the value of tolerance of inner integral computation. If IsByPoint is equal to Standard_True, the number of the coefficients is equal to 3 and they represent X, Y and Z coordinates (theCoeff[0], theCoeff[1] and theCoeff[2] correspondingly) of the shift if the inertia is computed with respect to the point different then the location. If IsByPoint is equal to Standard_False, the number of the coefficients is 4 and they represent the compbination of plane parameters and shift values.
        	:param theSurface:
        	:type theSurface: BRepGProp_Face
        	:param theVertex:
        	:type theVertex: gp_Pnt
        	:param IsByPoint:
        	:type IsByPoint: bool
        	:param theCoeffs:
        	:type theCoeffs: Standard_Address
        	:param theUMin:
        	:type theUMin: float
        	:param theTolerance:
        	:type theTolerance: float
        	:rtype: None
        """
        _BRepGProp.BRepGProp_TFunction_swiginit(self, _BRepGProp.new_BRepGProp_TFunction(*args))
    ErrorReached = _swig_new_instance_method(_BRepGProp.BRepGProp_TFunction_ErrorReached)
    Init = _swig_new_instance_method(_BRepGProp.BRepGProp_TFunction_Init)
    SetNbKronrodPoints = _swig_new_instance_method(_BRepGProp.BRepGProp_TFunction_SetNbKronrodPoints)
    SetTolerance = _swig_new_instance_method(_BRepGProp.BRepGProp_TFunction_SetTolerance)
    SetValueType = _swig_new_instance_method(_BRepGProp.BRepGProp_TFunction_SetValueType)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepGProp.delete_BRepGProp_TFunction

# Register BRepGProp_TFunction in _BRepGProp:
_BRepGProp.BRepGProp_TFunction_swigregister(BRepGProp_TFunction)

class BRepGProp_UFunction(OCC.Core.math.math_Function):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Constructor. Initializes the function with the face, the location point, the flag IsByPoint and the coefficients theCoeff that have different meaning depending on the value of IsByPoint. If IsByPoint is equal to Standard_True, the number of the coefficients is equal to 3 and they represent X, Y and Z coordinates (theCoeff[0], theCoeff[1] and theCoeff[2] correspondingly) of the shift, if the inertia is computed with respect to the point different then the location. If IsByPoint is equal to Standard_False, the number of the coefficients is 4 and they represent the combination of plane parameters and shift values.
        	:param theSurface:
        	:type theSurface: BRepGProp_Face
        	:param theVertex:
        	:type theVertex: gp_Pnt
        	:param IsByPoint:
        	:type IsByPoint: bool
        	:param theCoeffs:
        	:type theCoeffs: Standard_Address
        	:rtype: None
        """
        _BRepGProp.BRepGProp_UFunction_swiginit(self, _BRepGProp.new_BRepGProp_UFunction(*args))
    SetVParam = _swig_new_instance_method(_BRepGProp.BRepGProp_UFunction_SetVParam)
    SetValueType = _swig_new_instance_method(_BRepGProp.BRepGProp_UFunction_SetValueType)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepGProp.delete_BRepGProp_UFunction

# Register BRepGProp_UFunction in _BRepGProp:
_BRepGProp.BRepGProp_UFunction_swigregister(BRepGProp_UFunction)

class BRepGProp_Vinert(OCC.Core.GProp.GProp_GProps):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        :rtype: None* Computes the global properties of a region of 3D space delimited with the surface <S> and the point VLocation. S can be closed The method is quick and its precision is enough for many cases of analytical surfaces. Non-adaptive 2D Gauss integration with predefined numbers of Gauss points is used. Numbers of points depend on types of surfaces and curves. Errror of the computation is not calculated.
        	:param S:
        	:type S: BRepGProp_Face
        	:param VLocation:
        	:type VLocation: gp_Pnt
        	:rtype: None* Computes the global properties of a region of 3D space delimited with the surface <S> and the point VLocation. S can be closed Adaptive 2D Gauss integration is used. Parameter Eps sets maximal relative error of computed mass (volume) for face. Error is calculated as Abs((M(i+1)-M(i))/M(i+1)), M(i+1) and M(i) are values for two successive steps of adaptive integration.
        	:param S:
        	:type S: BRepGProp_Face
        	:param VLocation:
        	:type VLocation: gp_Pnt
        	:param Eps:
        	:type Eps: float
        	:rtype: None* Computes the global properties of the region of 3D space delimited with the surface <S> and the point VLocation. The method is quick and its precision is enough for many cases of analytical surfaces. Non-adaptive 2D Gauss integration with predefined numbers of Gauss points is used. Numbers of points depend on types of surfaces and curves. Error of the computation is not calculated.
        	:param S:
        	:type S: BRepGProp_Face
        	:param O:
        	:type O: gp_Pnt
        	:param VLocation:
        	:type VLocation: gp_Pnt
        	:rtype: None* Computes the global properties of the region of 3D space delimited with the surface <S> and the point VLocation. Adaptive 2D Gauss integration is used. Parameter Eps sets maximal relative error of computed mass (volume) for face. Error is calculated as Abs((M(i+1)-M(i))/M(i+1)), M(i+1) and M(i) are values for two successive steps of adaptive integration. WARNING: if Eps > 0.001 algorithm performs non-adaptive integration.
        	:param S:
        	:type S: BRepGProp_Face
        	:param O:
        	:type O: gp_Pnt
        	:param VLocation:
        	:type VLocation: gp_Pnt
        	:param Eps:
        	:type Eps: float
        	:rtype: None* Computes the global properties of the region of 3D space delimited with the surface <S> and the plane Pln. The method is quick and its precision is enough for many cases of analytical surfaces. Non-adaptive 2D Gauss integration with predefined numbers of Gauss points is used. Numbers of points depend on types of surfaces and curves. Error of the computation is not calculated.
        	:param S:
        	:type S: BRepGProp_Face
        	:param Pl:
        	:type Pl: gp_Pln
        	:param VLocation:
        	:type VLocation: gp_Pnt
        	:rtype: None* Computes the global properties of the region of 3D space delimited with the surface <S> and the plane Pln. Adaptive 2D Gauss integration is used. Parameter Eps sets maximal relative error of computed mass (volume) for face. Error is calculated as Abs((M(i+1)-M(i))/M(i+1)), M(i+1) and M(i) are values for two successive steps of adaptive integration. WARNING: if Eps > 0.001 algorithm performs non-adaptive integration.
        	:param S:
        	:type S: BRepGProp_Face
        	:param Pl:
        	:type Pl: gp_Pln
        	:param VLocation:
        	:type VLocation: gp_Pnt
        	:param Eps:
        	:type Eps: float
        	:rtype: None* Computes the global properties of a region of 3D space delimited with the surface <S> and the point VLocation. S can be closed The method is quick and its precision is enough for many cases of analytical surfaces. Non-adaptive 2D Gauss integration with predefined numbers of Gauss points is used. Numbers of points depend on types of surfaces and curves. Errror of the computation is not calculated.
        	:param S:
        	:type S: BRepGProp_Face
        	:param D:
        	:type D: BRepGProp_Domain
        	:param VLocation:
        	:type VLocation: gp_Pnt
        	:rtype: None* Computes the global properties of a region of 3D space delimited with the surface <S> and the point VLocation. S can be closed Adaptive 2D Gauss integration is used. Parameter Eps sets maximal relative error of computed mass (volume) for face. Error is calculated as Abs((M(i+1)-M(i))/M(i+1)), M(i+1) and M(i) are values for two successive steps of adaptive integration.
        	:param S:
        	:type S: BRepGProp_Face
        	:param D:
        	:type D: BRepGProp_Domain
        	:param VLocation:
        	:type VLocation: gp_Pnt
        	:param Eps:
        	:type Eps: float
        	:rtype: None* Computes the global properties of the region of 3D space delimited with the surface <S> and the point VLocation. The method is quick and its precision is enough for many cases of analytical surfaces. Non-adaptive 2D Gauss integration with predefined numbers of Gauss points is used. Numbers of points depend on types of surfaces and curves. Error of the computation is not calculated.
        	:param S:
        	:type S: BRepGProp_Face
        	:param D:
        	:type D: BRepGProp_Domain
        	:param O:
        	:type O: gp_Pnt
        	:param VLocation:
        	:type VLocation: gp_Pnt
        	:rtype: None* Computes the global properties of the region of 3D space delimited with the surface <S> and the point VLocation. Adaptive 2D Gauss integration is used. Parameter Eps sets maximal relative error of computed mass (volume) for face. Error is calculated as Abs((M(i+1)-M(i))/M(i+1)), M(i+1) and M(i) are values for two successive steps of adaptive integration. WARNING: if Eps > 0.001 algorithm performs non-adaptive integration.
        	:param S:
        	:type S: BRepGProp_Face
        	:param D:
        	:type D: BRepGProp_Domain
        	:param O:
        	:type O: gp_Pnt
        	:param VLocation:
        	:type VLocation: gp_Pnt
        	:param Eps:
        	:type Eps: float
        	:rtype: None* Computes the global properties of the region of 3D space delimited with the surface <S> and the plane Pln. The method is quick and its precision is enough for many cases of analytical surfaces. Non-adaptive 2D Gauss integration with predefined numbers of Gauss points is used. Numbers of points depend on types of surfaces and curves. Error of the computation is not calculated.
        	:param S:
        	:type S: BRepGProp_Face
        	:param D:
        	:type D: BRepGProp_Domain
        	:param Pl:
        	:type Pl: gp_Pln
        	:param VLocation:
        	:type VLocation: gp_Pnt
        	:rtype: None* Computes the global properties of the region of 3D space delimited with the surface <S> and the plane Pln. Adaptive 2D Gauss integration is used. Parameter Eps sets maximal relative error of computed mass (volume) for face. Error is calculated as Abs((M(i+1)-M(i))/M(i+1)), M(i+1) and M(i) are values for two successive steps of adaptive integration. WARNING: if Eps > 0.001 algorithm performs non-adaptive integration.
        	:param S:
        	:type S: BRepGProp_Face
        	:param D:
        	:type D: BRepGProp_Domain
        	:param Pl:
        	:type Pl: gp_Pln
        	:param VLocation:
        	:type VLocation: gp_Pnt
        	:param Eps:
        	:type Eps: float
        	:rtype: None
        """
        _BRepGProp.BRepGProp_Vinert_swiginit(self, _BRepGProp.new_BRepGProp_Vinert(*args))
    GetEpsilon = _swig_new_instance_method(_BRepGProp.BRepGProp_Vinert_GetEpsilon)
    Perform = _swig_new_instance_method(_BRepGProp.BRepGProp_Vinert_Perform)
    SetLocation = _swig_new_instance_method(_BRepGProp.BRepGProp_Vinert_SetLocation)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepGProp.delete_BRepGProp_Vinert

# Register BRepGProp_Vinert in _BRepGProp:
_BRepGProp.BRepGProp_Vinert_swigregister(BRepGProp_Vinert)

class BRepGProp_VinertGK(OCC.Core.GProp.GProp_GProps):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Empty constructor.
        	:rtype: None* Constructor. Computes the global properties of a region of 3D space delimited with the naturally restricted surface and the point VLocation.
        	:param theSurface:
        	:type theSurface: BRepGProp_Face
        	:param theLocation:
        	:type theLocation: gp_Pnt
        	:param theTolerance: default value is 0.001
        	:type theTolerance: float
        	:param theCGFlag: default value is Standard_False
        	:type theCGFlag: bool
        	:param theIFlag: default value is Standard_False
        	:type theIFlag: bool
        	:rtype: None* Constructor. Computes the global properties of a region of 3D space delimited with the naturally restricted surface and the point VLocation. The inertia is computed with respect to thePoint.
        	:param theSurface:
        	:type theSurface: BRepGProp_Face
        	:param thePoint:
        	:type thePoint: gp_Pnt
        	:param theLocation:
        	:type theLocation: gp_Pnt
        	:param theTolerance: default value is 0.001
        	:type theTolerance: float
        	:param theCGFlag: default value is Standard_False
        	:type theCGFlag: bool
        	:param theIFlag: default value is Standard_False
        	:type theIFlag: bool
        	:rtype: None* Constructor. Computes the global properties of a region of 3D space delimited with the surface bounded by the domain and the point VLocation.
        	:param theSurface:
        	:type theSurface: BRepGProp_Face
        	:param theDomain:
        	:type theDomain: BRepGProp_Domain
        	:param theLocation:
        	:type theLocation: gp_Pnt
        	:param theTolerance: default value is 0.001
        	:type theTolerance: float
        	:param theCGFlag: default value is Standard_False
        	:type theCGFlag: bool
        	:param theIFlag: default value is Standard_False
        	:type theIFlag: bool
        	:rtype: None* Constructor. Computes the global properties of a region of 3D space delimited with the surface bounded by the domain and the point VLocation. The inertia is computed with respect to thePoint.
        	:param theSurface:
        	:type theSurface: BRepGProp_Face
        	:param theDomain:
        	:type theDomain: BRepGProp_Domain
        	:param thePoint:
        	:type thePoint: gp_Pnt
        	:param theLocation:
        	:type theLocation: gp_Pnt
        	:param theTolerance: default value is 0.001
        	:type theTolerance: float
        	:param theCGFlag: default value is Standard_False
        	:type theCGFlag: bool
        	:param theIFlag: default value is Standard_False
        	:type theIFlag: bool
        	:rtype: None* Constructor. Computes the global properties of a region of 3D space delimited with the naturally restricted surface and the plane.
        	:param theSurface:
        	:type theSurface: BRepGProp_Face
        	:param thePlane:
        	:type thePlane: gp_Pln
        	:param theLocation:
        	:type theLocation: gp_Pnt
        	:param theTolerance: default value is 0.001
        	:type theTolerance: float
        	:param theCGFlag: default value is Standard_False
        	:type theCGFlag: bool
        	:param theIFlag: default value is Standard_False
        	:type theIFlag: bool
        	:rtype: None* Constructor. Computes the global properties of a region of 3D space delimited with the surface bounded by the domain and the plane.
        	:param theSurface:
        	:type theSurface: BRepGProp_Face
        	:param theDomain:
        	:type theDomain: BRepGProp_Domain
        	:param thePlane:
        	:type thePlane: gp_Pln
        	:param theLocation:
        	:type theLocation: gp_Pnt
        	:param theTolerance: default value is 0.001
        	:type theTolerance: float
        	:param theCGFlag: default value is Standard_False
        	:type theCGFlag: bool
        	:param theIFlag: default value is Standard_False
        	:type theIFlag: bool
        	:rtype: None
        """
        _BRepGProp.BRepGProp_VinertGK_swiginit(self, _BRepGProp.new_BRepGProp_VinertGK(*args))
    GetErrorReached = _swig_new_instance_method(_BRepGProp.BRepGProp_VinertGK_GetErrorReached)
    Perform = _swig_new_instance_method(_BRepGProp.BRepGProp_VinertGK_Perform)
    SetLocation = _swig_new_instance_method(_BRepGProp.BRepGProp_VinertGK_SetLocation)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepGProp.delete_BRepGProp_VinertGK

# Register BRepGProp_VinertGK in _BRepGProp:
_BRepGProp.BRepGProp_VinertGK_swigregister(BRepGProp_VinertGK)



