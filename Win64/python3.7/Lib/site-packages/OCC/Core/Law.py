# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
Law module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_law.html
"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _Law
else:
    import _Law

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _Law.SWIG_PyInstanceMethod_New
_swig_new_static_method = _Law.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Law.delete_SwigPyIterator
    value = _swig_new_instance_method(_Law.SwigPyIterator_value)
    incr = _swig_new_instance_method(_Law.SwigPyIterator_incr)
    decr = _swig_new_instance_method(_Law.SwigPyIterator_decr)
    distance = _swig_new_instance_method(_Law.SwigPyIterator_distance)
    equal = _swig_new_instance_method(_Law.SwigPyIterator_equal)
    copy = _swig_new_instance_method(_Law.SwigPyIterator_copy)
    next = _swig_new_instance_method(_Law.SwigPyIterator_next)
    __next__ = _swig_new_instance_method(_Law.SwigPyIterator___next__)
    previous = _swig_new_instance_method(_Law.SwigPyIterator_previous)
    advance = _swig_new_instance_method(_Law.SwigPyIterator_advance)
    __eq__ = _swig_new_instance_method(_Law.SwigPyIterator___eq__)
    __ne__ = _swig_new_instance_method(_Law.SwigPyIterator___ne__)
    __iadd__ = _swig_new_instance_method(_Law.SwigPyIterator___iadd__)
    __isub__ = _swig_new_instance_method(_Law.SwigPyIterator___isub__)
    __add__ = _swig_new_instance_method(_Law.SwigPyIterator___add__)
    __sub__ = _swig_new_instance_method(_Law.SwigPyIterator___sub__)
    def __iter__(self):
        return self

# Register SwigPyIterator in _Law:
_Law.SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.Adaptor3d
import OCC.Core.Geom
import OCC.Core.gp
import OCC.Core.GeomAbs
import OCC.Core.TColgp
import OCC.Core.TopAbs
import OCC.Core.Adaptor2d
import OCC.Core.Geom2d
import OCC.Core.math
import OCC.Core.Message
Handle_Law_BSpline_Create = _Law.Handle_Law_BSpline_Create
Handle_Law_BSpline_DownCast = _Law.Handle_Law_BSpline_DownCast
Handle_Law_BSpline_IsNull = _Law.Handle_Law_BSpline_IsNull
Handle_Law_Function_Create = _Law.Handle_Law_Function_Create
Handle_Law_Function_DownCast = _Law.Handle_Law_Function_DownCast
Handle_Law_Function_IsNull = _Law.Handle_Law_Function_IsNull
Handle_Law_BSpFunc_Create = _Law.Handle_Law_BSpFunc_Create
Handle_Law_BSpFunc_DownCast = _Law.Handle_Law_BSpFunc_DownCast
Handle_Law_BSpFunc_IsNull = _Law.Handle_Law_BSpFunc_IsNull
Handle_Law_Composite_Create = _Law.Handle_Law_Composite_Create
Handle_Law_Composite_DownCast = _Law.Handle_Law_Composite_DownCast
Handle_Law_Composite_IsNull = _Law.Handle_Law_Composite_IsNull
Handle_Law_Constant_Create = _Law.Handle_Law_Constant_Create
Handle_Law_Constant_DownCast = _Law.Handle_Law_Constant_DownCast
Handle_Law_Constant_IsNull = _Law.Handle_Law_Constant_IsNull
Handle_Law_Linear_Create = _Law.Handle_Law_Linear_Create
Handle_Law_Linear_DownCast = _Law.Handle_Law_Linear_DownCast
Handle_Law_Linear_IsNull = _Law.Handle_Law_Linear_IsNull
Handle_Law_Interpol_Create = _Law.Handle_Law_Interpol_Create
Handle_Law_Interpol_DownCast = _Law.Handle_Law_Interpol_DownCast
Handle_Law_Interpol_IsNull = _Law.Handle_Law_Interpol_IsNull
Handle_Law_S_Create = _Law.Handle_Law_S_Create
Handle_Law_S_DownCast = _Law.Handle_Law_S_DownCast
Handle_Law_S_IsNull = _Law.Handle_Law_S_IsNull
class Law_Laws(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    begin = _swig_new_instance_method(_Law.Law_Laws_begin)
    end = _swig_new_instance_method(_Law.Law_Laws_end)
    cbegin = _swig_new_instance_method(_Law.Law_Laws_cbegin)
    cend = _swig_new_instance_method(_Law.Law_Laws_cend)

    def __init__(self, *args):
        _Law.Law_Laws_swiginit(self, _Law.new_Law_Laws(*args))
    Size = _swig_new_instance_method(_Law.Law_Laws_Size)
    Assign = _swig_new_instance_method(_Law.Law_Laws_Assign)
    Set = _swig_new_instance_method(_Law.Law_Laws_Set)
    Clear = _swig_new_instance_method(_Law.Law_Laws_Clear)
    First = _swig_new_instance_method(_Law.Law_Laws_First)
    Last = _swig_new_instance_method(_Law.Law_Laws_Last)
    Append = _swig_new_instance_method(_Law.Law_Laws_Append)
    Prepend = _swig_new_instance_method(_Law.Law_Laws_Prepend)
    RemoveFirst = _swig_new_instance_method(_Law.Law_Laws_RemoveFirst)
    Remove = _swig_new_instance_method(_Law.Law_Laws_Remove)
    InsertBefore = _swig_new_instance_method(_Law.Law_Laws_InsertBefore)
    InsertAfter = _swig_new_instance_method(_Law.Law_Laws_InsertAfter)
    Reverse = _swig_new_instance_method(_Law.Law_Laws_Reverse)
    __swig_destroy__ = _Law.delete_Law_Laws

# Register Law_Laws in _Law:
_Law.Law_Laws_swigregister(Law_Laws)

class Law_ListIteratorOfLaws(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _Law.Law_ListIteratorOfLaws_swiginit(self, _Law.new_Law_ListIteratorOfLaws(*args))
    More = _swig_new_instance_method(_Law.Law_ListIteratorOfLaws_More)
    Next = _swig_new_instance_method(_Law.Law_ListIteratorOfLaws_Next)
    Value = _swig_new_instance_method(_Law.Law_ListIteratorOfLaws_Value)
    ChangeValue = _swig_new_instance_method(_Law.Law_ListIteratorOfLaws_ChangeValue)
    __swig_destroy__ = _Law.delete_Law_ListIteratorOfLaws

# Register Law_ListIteratorOfLaws in _Law:
_Law.Law_ListIteratorOfLaws_swigregister(Law_ListIteratorOfLaws)

class law(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    MixBnd = _swig_new_static_method(_Law.law_MixBnd)
    MixTgt = _swig_new_static_method(_Law.law_MixTgt)
    Reparametrize = _swig_new_static_method(_Law.law_Reparametrize)
    Scale = _swig_new_static_method(_Law.law_Scale)
    ScaleCub = _swig_new_static_method(_Law.law_ScaleCub)

    __repr__ = _dumps_object


    def __init__(self):
        _Law.law_swiginit(self, _Law.new_law())
    __swig_destroy__ = _Law.delete_law

# Register law in _Law:
_Law.law_swigregister(law)
law_MixBnd = _Law.law_MixBnd
law_MixTgt = _Law.law_MixTgt
law_Reparametrize = _Law.law_Reparametrize
law_Scale = _Law.law_Scale
law_ScaleCub = _Law.law_ScaleCub

class Law_BSpline(OCC.Core.Standard.Standard_Transient):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Continuity = _swig_new_instance_method(_Law.Law_BSpline_Continuity)
    Copy = _swig_new_instance_method(_Law.Law_BSpline_Copy)
    D0 = _swig_new_instance_method(_Law.Law_BSpline_D0)
    D1 = _swig_new_instance_method(_Law.Law_BSpline_D1)
    D2 = _swig_new_instance_method(_Law.Law_BSpline_D2)
    D3 = _swig_new_instance_method(_Law.Law_BSpline_D3)
    DN = _swig_new_instance_method(_Law.Law_BSpline_DN)
    Degree = _swig_new_instance_method(_Law.Law_BSpline_Degree)
    EndPoint = _swig_new_instance_method(_Law.Law_BSpline_EndPoint)
    FirstParameter = _swig_new_instance_method(_Law.Law_BSpline_FirstParameter)
    FirstUKnotIndex = _swig_new_instance_method(_Law.Law_BSpline_FirstUKnotIndex)
    IncreaseDegree = _swig_new_instance_method(_Law.Law_BSpline_IncreaseDegree)
    IncreaseMultiplicity = _swig_new_instance_method(_Law.Law_BSpline_IncreaseMultiplicity)
    IncrementMultiplicity = _swig_new_instance_method(_Law.Law_BSpline_IncrementMultiplicity)
    InsertKnot = _swig_new_instance_method(_Law.Law_BSpline_InsertKnot)
    InsertKnots = _swig_new_instance_method(_Law.Law_BSpline_InsertKnots)
    IsCN = _swig_new_instance_method(_Law.Law_BSpline_IsCN)
    IsClosed = _swig_new_instance_method(_Law.Law_BSpline_IsClosed)
    IsPeriodic = _swig_new_instance_method(_Law.Law_BSpline_IsPeriodic)
    IsRational = _swig_new_instance_method(_Law.Law_BSpline_IsRational)
    Knot = _swig_new_instance_method(_Law.Law_BSpline_Knot)
    KnotDistribution = _swig_new_instance_method(_Law.Law_BSpline_KnotDistribution)
    KnotSequence = _swig_new_instance_method(_Law.Law_BSpline_KnotSequence)
    Knots = _swig_new_instance_method(_Law.Law_BSpline_Knots)
    LastParameter = _swig_new_instance_method(_Law.Law_BSpline_LastParameter)
    LastUKnotIndex = _swig_new_instance_method(_Law.Law_BSpline_LastUKnotIndex)

    def __init__(self, *args):
        r"""
        * Creates a non-rational B_spline curve on the basis <Knots, Multiplicities> of degree <Degree>.
        	:param Poles:
        	:type Poles: TColStd_Array1OfReal
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Multiplicities:
        	:type Multiplicities: TColStd_Array1OfInteger
        	:param Degree:
        	:type Degree: int
        	:param Periodic: default value is Standard_False
        	:type Periodic: bool
        	:rtype: None* Creates a rational B_spline curve on the basis <Knots, Multiplicities> of degree <Degree>.
        	:param Poles:
        	:type Poles: TColStd_Array1OfReal
        	:param Weights:
        	:type Weights: TColStd_Array1OfReal
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Multiplicities:
        	:type Multiplicities: TColStd_Array1OfInteger
        	:param Degree:
        	:type Degree: int
        	:param Periodic: default value is Standard_False
        	:type Periodic: bool
        	:rtype: None
        """
        _Law.Law_BSpline_swiginit(self, _Law.new_Law_BSpline(*args))
    LocalD0 = _swig_new_instance_method(_Law.Law_BSpline_LocalD0)
    LocalD1 = _swig_new_instance_method(_Law.Law_BSpline_LocalD1)
    LocalD2 = _swig_new_instance_method(_Law.Law_BSpline_LocalD2)
    LocalD3 = _swig_new_instance_method(_Law.Law_BSpline_LocalD3)
    LocalDN = _swig_new_instance_method(_Law.Law_BSpline_LocalDN)
    LocalValue = _swig_new_instance_method(_Law.Law_BSpline_LocalValue)
    LocateU = _swig_new_instance_method(_Law.Law_BSpline_LocateU)
    MaxDegree = _swig_new_static_method(_Law.Law_BSpline_MaxDegree)
    MovePointAndTangent = _swig_new_instance_method(_Law.Law_BSpline_MovePointAndTangent)
    Multiplicities = _swig_new_instance_method(_Law.Law_BSpline_Multiplicities)
    Multiplicity = _swig_new_instance_method(_Law.Law_BSpline_Multiplicity)
    NbKnots = _swig_new_instance_method(_Law.Law_BSpline_NbKnots)
    NbPoles = _swig_new_instance_method(_Law.Law_BSpline_NbPoles)
    PeriodicNormalization = _swig_new_instance_method(_Law.Law_BSpline_PeriodicNormalization)
    Pole = _swig_new_instance_method(_Law.Law_BSpline_Pole)
    Poles = _swig_new_instance_method(_Law.Law_BSpline_Poles)
    RemoveKnot = _swig_new_instance_method(_Law.Law_BSpline_RemoveKnot)
    Resolution = _swig_new_instance_method(_Law.Law_BSpline_Resolution)
    Reverse = _swig_new_instance_method(_Law.Law_BSpline_Reverse)
    ReversedParameter = _swig_new_instance_method(_Law.Law_BSpline_ReversedParameter)
    Segment = _swig_new_instance_method(_Law.Law_BSpline_Segment)
    SetKnot = _swig_new_instance_method(_Law.Law_BSpline_SetKnot)
    SetKnots = _swig_new_instance_method(_Law.Law_BSpline_SetKnots)
    SetNotPeriodic = _swig_new_instance_method(_Law.Law_BSpline_SetNotPeriodic)
    SetOrigin = _swig_new_instance_method(_Law.Law_BSpline_SetOrigin)
    SetPeriodic = _swig_new_instance_method(_Law.Law_BSpline_SetPeriodic)
    SetPole = _swig_new_instance_method(_Law.Law_BSpline_SetPole)
    SetWeight = _swig_new_instance_method(_Law.Law_BSpline_SetWeight)
    StartPoint = _swig_new_instance_method(_Law.Law_BSpline_StartPoint)
    Value = _swig_new_instance_method(_Law.Law_BSpline_Value)
    Weight = _swig_new_instance_method(_Law.Law_BSpline_Weight)
    Weights = _swig_new_instance_method(_Law.Law_BSpline_Weights)


    @staticmethod
    def DownCast(t):
      return Handle_Law_BSpline_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Law.delete_Law_BSpline

# Register Law_BSpline in _Law:
_Law.Law_BSpline_swigregister(Law_BSpline)
Law_BSpline_MaxDegree = _Law.Law_BSpline_MaxDegree

class Law_BSplineKnotSplitting(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Locates the knot values which correspond to the segmentation of the curve into arcs with a continuity equal to ContinuityRange. //! Raised if ContinuityRange is not greater or equal zero.
        	:param BasisLaw:
        	:type BasisLaw: Law_BSpline
        	:param ContinuityRange:
        	:type ContinuityRange: int
        	:rtype: None
        """
        _Law.Law_BSplineKnotSplitting_swiginit(self, _Law.new_Law_BSplineKnotSplitting(*args))
    NbSplits = _swig_new_instance_method(_Law.Law_BSplineKnotSplitting_NbSplits)
    SplitValue = _swig_new_instance_method(_Law.Law_BSplineKnotSplitting_SplitValue)
    Splitting = _swig_new_instance_method(_Law.Law_BSplineKnotSplitting_Splitting)

    __repr__ = _dumps_object

    __swig_destroy__ = _Law.delete_Law_BSplineKnotSplitting

# Register Law_BSplineKnotSplitting in _Law:
_Law.Law_BSplineKnotSplitting_swigregister(Law_BSplineKnotSplitting)

class Law_Function(OCC.Core.Standard.Standard_Transient):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Bounds = _swig_new_instance_method(_Law.Law_Function_Bounds)
    Continuity = _swig_new_instance_method(_Law.Law_Function_Continuity)
    D1 = _swig_new_instance_method(_Law.Law_Function_D1)
    D2 = _swig_new_instance_method(_Law.Law_Function_D2)
    Intervals = _swig_new_instance_method(_Law.Law_Function_Intervals)
    NbIntervals = _swig_new_instance_method(_Law.Law_Function_NbIntervals)
    Trim = _swig_new_instance_method(_Law.Law_Function_Trim)
    Value = _swig_new_instance_method(_Law.Law_Function_Value)


    @staticmethod
    def DownCast(t):
      return Handle_Law_Function_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Law.delete_Law_Function

# Register Law_Function in _Law:
_Law.Law_Function_swigregister(Law_Function)

class Law_Interpolate(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Curve = _swig_new_instance_method(_Law.Law_Interpolate_Curve)
    IsDone = _swig_new_instance_method(_Law.Law_Interpolate_IsDone)

    def __init__(self, *args):
        r"""
        * Tolerance is to check if the points are not too close to one an other. It is also used to check if the tangent vector is not too small. There should be at least 2 points. If PeriodicFlag is True then the curve will be periodic be periodic
        	:param Points:
        	:type Points: TColStd_HArray1OfReal
        	:param PeriodicFlag:
        	:type PeriodicFlag: bool
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None* Tolerance is to check if the points are not too close to one an other. It is also used to check if the tangent vector is not too small. There should be at least 2 points. If PeriodicFlag is True then the curve will be periodic be periodic
        	:param Points:
        	:type Points: TColStd_HArray1OfReal
        	:param Parameters:
        	:type Parameters: TColStd_HArray1OfReal
        	:param PeriodicFlag:
        	:type PeriodicFlag: bool
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None
        """
        _Law.Law_Interpolate_swiginit(self, _Law.new_Law_Interpolate(*args))
    Load = _swig_new_instance_method(_Law.Law_Interpolate_Load)
    Perform = _swig_new_instance_method(_Law.Law_Interpolate_Perform)

    __repr__ = _dumps_object

    __swig_destroy__ = _Law.delete_Law_Interpolate

# Register Law_Interpolate in _Law:
_Law.Law_Interpolate_swigregister(Law_Interpolate)

class Law_BSpFunc(Law_Function):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Curve = _swig_new_instance_method(_Law.Law_BSpFunc_Curve)

    def __init__(self, *args):
        r"""
        :rtype: None:param C:
        	:type C: Law_BSpline
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:rtype: None
        """
        _Law.Law_BSpFunc_swiginit(self, _Law.new_Law_BSpFunc(*args))
    SetCurve = _swig_new_instance_method(_Law.Law_BSpFunc_SetCurve)


    @staticmethod
    def DownCast(t):
      return Handle_Law_BSpFunc_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Law.delete_Law_BSpFunc

# Register Law_BSpFunc in _Law:
_Law.Law_BSpFunc_swigregister(Law_BSpFunc)

class Law_Composite(Law_Function):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ChangeElementaryLaw = _swig_new_instance_method(_Law.Law_Composite_ChangeElementaryLaw)
    ChangeLaws = _swig_new_instance_method(_Law.Law_Composite_ChangeLaws)
    IsPeriodic = _swig_new_instance_method(_Law.Law_Composite_IsPeriodic)

    def __init__(self, *args):
        r"""
        * Construct an empty Law
        	:rtype: None* Construct an empty, trimed Law
        	:param First:
        	:type First: float
        	:param Last:
        	:type Last: float
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        _Law.Law_Composite_swiginit(self, _Law.new_Law_Composite(*args))
    SetPeriodic = _swig_new_instance_method(_Law.Law_Composite_SetPeriodic)


    @staticmethod
    def DownCast(t):
      return Handle_Law_Composite_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Law.delete_Law_Composite

# Register Law_Composite in _Law:
_Law.Law_Composite_swigregister(Law_Composite)

class Law_Constant(Law_Function):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r""":rtype: None"""
        _Law.Law_Constant_swiginit(self, _Law.new_Law_Constant(*args))
    Set = _swig_new_instance_method(_Law.Law_Constant_Set)


    @staticmethod
    def DownCast(t):
      return Handle_Law_Constant_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Law.delete_Law_Constant

# Register Law_Constant in _Law:
_Law.Law_Constant_swigregister(Law_Constant)

class Law_Linear(Law_Function):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Constructs an empty linear evolution law.
        	:rtype: None
        """
        _Law.Law_Linear_swiginit(self, _Law.new_Law_Linear(*args))
    Set = _swig_new_instance_method(_Law.Law_Linear_Set)


    @staticmethod
    def DownCast(t):
      return Handle_Law_Linear_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Law.delete_Law_Linear

# Register Law_Linear in _Law:
_Law.Law_Linear_swigregister(Law_Linear)

class Law_Interpol(Law_BSpFunc):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Constructs an empty interpolative evolution law. The function Set is used to define the law.
        	:rtype: None
        """
        _Law.Law_Interpol_swiginit(self, _Law.new_Law_Interpol(*args))
    Set = _swig_new_instance_method(_Law.Law_Interpol_Set)
    SetInRelative = _swig_new_instance_method(_Law.Law_Interpol_SetInRelative)


    @staticmethod
    def DownCast(t):
      return Handle_Law_Interpol_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Law.delete_Law_Interpol

# Register Law_Interpol in _Law:
_Law.Law_Interpol_swigregister(Law_Interpol)

class Law_S(Law_BSpFunc):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Constructs an empty 'S' evolution law.
        	:rtype: None
        """
        _Law.Law_S_swiginit(self, _Law.new_Law_S(*args))
    Set = _swig_new_instance_method(_Law.Law_S_Set)


    @staticmethod
    def DownCast(t):
      return Handle_Law_S_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Law.delete_Law_S

# Register Law_S in _Law:
_Law.Law_S_swigregister(Law_S)



