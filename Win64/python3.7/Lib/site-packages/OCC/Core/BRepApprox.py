# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
BRepApprox module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_brepapprox.html
"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _BRepApprox
else:
    import _BRepApprox

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _BRepApprox.SWIG_PyInstanceMethod_New
_swig_new_static_method = _BRepApprox.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BRepApprox.delete_SwigPyIterator
    value = _swig_new_instance_method(_BRepApprox.SwigPyIterator_value)
    incr = _swig_new_instance_method(_BRepApprox.SwigPyIterator_incr)
    decr = _swig_new_instance_method(_BRepApprox.SwigPyIterator_decr)
    distance = _swig_new_instance_method(_BRepApprox.SwigPyIterator_distance)
    equal = _swig_new_instance_method(_BRepApprox.SwigPyIterator_equal)
    copy = _swig_new_instance_method(_BRepApprox.SwigPyIterator_copy)
    next = _swig_new_instance_method(_BRepApprox.SwigPyIterator_next)
    __next__ = _swig_new_instance_method(_BRepApprox.SwigPyIterator___next__)
    previous = _swig_new_instance_method(_BRepApprox.SwigPyIterator_previous)
    advance = _swig_new_instance_method(_BRepApprox.SwigPyIterator_advance)
    __eq__ = _swig_new_instance_method(_BRepApprox.SwigPyIterator___eq__)
    __ne__ = _swig_new_instance_method(_BRepApprox.SwigPyIterator___ne__)
    __iadd__ = _swig_new_instance_method(_BRepApprox.SwigPyIterator___iadd__)
    __isub__ = _swig_new_instance_method(_BRepApprox.SwigPyIterator___isub__)
    __add__ = _swig_new_instance_method(_BRepApprox.SwigPyIterator___add__)
    __sub__ = _swig_new_instance_method(_BRepApprox.SwigPyIterator___sub__)
    def __iter__(self):
        return self

# Register SwigPyIterator in _BRepApprox:
_BRepApprox.SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.Approx
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.Adaptor3d
import OCC.Core.Geom
import OCC.Core.gp
import OCC.Core.GeomAbs
import OCC.Core.TColgp
import OCC.Core.TopAbs
import OCC.Core.Adaptor2d
import OCC.Core.Geom2d
import OCC.Core.math
import OCC.Core.Message
import OCC.Core.AppCont
import OCC.Core.AppParCurves
import OCC.Core.IntSurf
import OCC.Core.BRepAdaptor
import OCC.Core.TopoDS
import OCC.Core.TopLoc
import OCC.Core.GeomAdaptor
import OCC.Core.Geom2dAdaptor
import OCC.Core.IntImp
import OCC.Core.ApproxInt
Handle_BRepApprox_ApproxLine_Create = _BRepApprox.Handle_BRepApprox_ApproxLine_Create
Handle_BRepApprox_ApproxLine_DownCast = _BRepApprox.Handle_BRepApprox_ApproxLine_DownCast
Handle_BRepApprox_ApproxLine_IsNull = _BRepApprox.Handle_BRepApprox_ApproxLine_IsNull
class BRepApprox_Approx(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r""":rtype: None"""
        _BRepApprox.BRepApprox_Approx_swiginit(self, _BRepApprox.new_BRepApprox_Approx(*args))
    IsDone = _swig_new_instance_method(_BRepApprox.BRepApprox_Approx_IsDone)
    NbMultiCurves = _swig_new_instance_method(_BRepApprox.BRepApprox_Approx_NbMultiCurves)
    SetParameters = _swig_new_instance_method(_BRepApprox.BRepApprox_Approx_SetParameters)
    TolReached2d = _swig_new_instance_method(_BRepApprox.BRepApprox_Approx_TolReached2d)
    TolReached3d = _swig_new_instance_method(_BRepApprox.BRepApprox_Approx_TolReached3d)
    Value = _swig_new_instance_method(_BRepApprox.BRepApprox_Approx_Value)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_Approx

# Register BRepApprox_Approx in _BRepApprox:
_BRepApprox.BRepApprox_Approx_swigregister(BRepApprox_Approx)

class BRepApprox_ApproxLine(OCC.Core.Standard.Standard_Transient):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        :param CurveXYZ:
        	:type CurveXYZ: Geom_BSplineCurve
        	:param CurveUV1:
        	:type CurveUV1: Geom2d_BSplineCurve
        	:param CurveUV2:
        	:type CurveUV2: Geom2d_BSplineCurve
        	:rtype: None* theTang variable has been entered only for compatibility with the alias IntPatch_WLine. They are not used in this class.
        	:param lin:
        	:type lin: IntSurf_LineOn2S
        	:param theTang: default value is Standard_False
        	:type theTang: bool
        	:rtype: None
        """
        _BRepApprox.BRepApprox_ApproxLine_swiginit(self, _BRepApprox.new_BRepApprox_ApproxLine(*args))
    NbPnts = _swig_new_instance_method(_BRepApprox.BRepApprox_ApproxLine_NbPnts)
    Point = _swig_new_instance_method(_BRepApprox.BRepApprox_ApproxLine_Point)


    @staticmethod
    def DownCast(t):
      return Handle_BRepApprox_ApproxLine_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_ApproxLine

# Register BRepApprox_ApproxLine in _BRepApprox:
_BRepApprox.BRepApprox_ApproxLine_swigregister(BRepApprox_ApproxLine)

class BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox(OCC.Core.math.math_BFGS):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        :param F:
        	:type F: math_MultipleVarFunctionWithGradient
        	:param StartingPoint:
        	:type StartingPoint: math_Vector
        	:param Tolerance3d:
        	:type Tolerance3d: float
        	:param Tolerance2d:
        	:type Tolerance2d: float
        	:param Eps:
        	:type Eps: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:rtype: None
        """
        _BRepApprox.BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox

# Register BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox in _BRepApprox:
_BRepApprox.BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox_swigregister(BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox)

class BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox(OCC.Core.math.math_MultipleVarFunctionWithGradient):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * initializes the fields of the function. The approximating curve has <NbPol> control points.
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        """
        _BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox(*args))
    CurveValue = _swig_new_instance_method(_BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_CurveValue)
    DerivativeFunctionMatrix = _swig_new_instance_method(_BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_DerivativeFunctionMatrix)
    Error = _swig_new_instance_method(_BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_Error)
    FirstConstraint = _swig_new_instance_method(_BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_FirstConstraint)
    FunctionMatrix = _swig_new_instance_method(_BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_FunctionMatrix)
    Index = _swig_new_instance_method(_BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_Index)
    LastConstraint = _swig_new_instance_method(_BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_LastConstraint)
    MaxError2d = _swig_new_instance_method(_BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_MaxError2d)
    MaxError3d = _swig_new_instance_method(_BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_MaxError3d)
    NewParameters = _swig_new_instance_method(_BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_NewParameters)
    SetFirstLambda = _swig_new_instance_method(_BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_SetFirstLambda)
    SetLastLambda = _swig_new_instance_method(_BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_SetLastLambda)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox

# Register BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox in _BRepApprox:
_BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_swigregister(BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox)

class BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. NbPol is the number of control points wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the Bernstein matrix computed with the parameters, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None* Initializes the fields of the object.
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None* given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. Deg is the degree wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the BSpline functions matrix computed with <parameters>, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None* Initializes the fields of the object.
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        """
        _BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox(*args))
    BSplineValue = _swig_new_instance_method(_BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_BSplineValue)
    BezierValue = _swig_new_instance_method(_BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_BezierValue)
    DerivativeFunctionMatrix = _swig_new_instance_method(_BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_DerivativeFunctionMatrix)
    Distance = _swig_new_instance_method(_BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_Distance)
    Error = _swig_new_instance_method(_BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_Error)
    ErrorGradient = _swig_new_instance_method(_BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_ErrorGradient)
    FirstLambda = _swig_new_instance_method(_BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_FirstLambda)
    FunctionMatrix = _swig_new_instance_method(_BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_FunctionMatrix)
    IsDone = _swig_new_instance_method(_BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_IsDone)
    KIndex = _swig_new_instance_method(_BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_KIndex)
    LastLambda = _swig_new_instance_method(_BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_LastLambda)
    Perform = _swig_new_instance_method(_BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_Perform)
    Points = _swig_new_instance_method(_BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_Points)
    Poles = _swig_new_instance_method(_BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_Poles)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox

# Register BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox in _BRepApprox:
_BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_swigregister(BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox)

class BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox(OCC.Core.math.math_BFGS):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        :param F:
        	:type F: math_MultipleVarFunctionWithGradient
        	:param StartingPoint:
        	:type StartingPoint: math_Vector
        	:param Tolerance3d:
        	:type Tolerance3d: float
        	:param Tolerance2d:
        	:type Tolerance2d: float
        	:param Eps:
        	:type Eps: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:rtype: None
        """
        _BRepApprox.BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox

# Register BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox in _BRepApprox:
_BRepApprox.BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox_swigregister(BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox)

class BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox(OCC.Core.math.math_BFGS):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        :param F:
        	:type F: math_MultipleVarFunctionWithGradient
        	:param StartingPoint:
        	:type StartingPoint: math_Vector
        	:param Tolerance3d:
        	:type Tolerance3d: float
        	:param Tolerance2d:
        	:type Tolerance2d: float
        	:param Eps:
        	:type Eps: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:rtype: None
        """
        _BRepApprox.BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox

# Register BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox in _BRepApprox:
_BRepApprox.BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox_swigregister(BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox)

class BRepApprox_MyBSplGradientOfTheComputeLineOfApprox(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    AverageError = _swig_new_instance_method(_BRepApprox.BRepApprox_MyBSplGradientOfTheComputeLineOfApprox_AverageError)

    def __init__(self, *args):
        r"""
        * Tries to minimize the sum (square(||Qui - Bi*Pi||)) where Pui describe the approximating BSpline curves'Poles and Qi the MultiLine points with a parameter ui. In this algorithm, the parameters ui are the unknowns. The tolerance required on this sum is given by Tol. The desired degree of the resulting curve is Deg.
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param Deg:
        	:type Deg: int
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tol2d:
        	:type Tol2d: float
        	:param NbIterations: default value is 1
        	:type NbIterations: int
        	:rtype: None* Tries to minimize the sum (square(||Qui - Bi*Pi||)) where Pui describe the approximating BSpline curves'Poles and Qi the MultiLine points with a parameter ui. In this algorithm, the parameters ui are the unknowns. The tolerance required on this sum is given by Tol. The desired degree of the resulting curve is Deg.
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param Deg:
        	:type Deg: int
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tol2d:
        	:type Tol2d: float
        	:param NbIterations:
        	:type NbIterations: int
        	:param lambda1:
        	:type lambda1: float
        	:param lambda2:
        	:type lambda2: float
        	:rtype: None
        """
        _BRepApprox.BRepApprox_MyBSplGradientOfTheComputeLineOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_MyBSplGradientOfTheComputeLineOfApprox(*args))
    Error = _swig_new_instance_method(_BRepApprox.BRepApprox_MyBSplGradientOfTheComputeLineOfApprox_Error)
    IsDone = _swig_new_instance_method(_BRepApprox.BRepApprox_MyBSplGradientOfTheComputeLineOfApprox_IsDone)
    MaxError2d = _swig_new_instance_method(_BRepApprox.BRepApprox_MyBSplGradientOfTheComputeLineOfApprox_MaxError2d)
    MaxError3d = _swig_new_instance_method(_BRepApprox.BRepApprox_MyBSplGradientOfTheComputeLineOfApprox_MaxError3d)
    Value = _swig_new_instance_method(_BRepApprox.BRepApprox_MyBSplGradientOfTheComputeLineOfApprox_Value)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_MyBSplGradientOfTheComputeLineOfApprox

# Register BRepApprox_MyBSplGradientOfTheComputeLineOfApprox in _BRepApprox:
_BRepApprox.BRepApprox_MyBSplGradientOfTheComputeLineOfApprox_swigregister(BRepApprox_MyBSplGradientOfTheComputeLineOfApprox)

class BRepApprox_MyGradientOfTheComputeLineBezierOfApprox(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    AverageError = _swig_new_instance_method(_BRepApprox.BRepApprox_MyGradientOfTheComputeLineBezierOfApprox_AverageError)

    def __init__(self, *args):
        r"""
        * Tries to minimize the sum (square(||Qui - Bi*Pi||)) where Pui describe the approximating Bezier curves'Poles and Qi the MultiLine points with a parameter ui. In this algorithm, the parameters ui are the unknowns. The tolerance required on this sum is given by Tol. The desired degree of the resulting curve is Deg.
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tol2d:
        	:type Tol2d: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:rtype: None
        """
        _BRepApprox.BRepApprox_MyGradientOfTheComputeLineBezierOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_MyGradientOfTheComputeLineBezierOfApprox(*args))
    Error = _swig_new_instance_method(_BRepApprox.BRepApprox_MyGradientOfTheComputeLineBezierOfApprox_Error)
    IsDone = _swig_new_instance_method(_BRepApprox.BRepApprox_MyGradientOfTheComputeLineBezierOfApprox_IsDone)
    MaxError2d = _swig_new_instance_method(_BRepApprox.BRepApprox_MyGradientOfTheComputeLineBezierOfApprox_MaxError2d)
    MaxError3d = _swig_new_instance_method(_BRepApprox.BRepApprox_MyGradientOfTheComputeLineBezierOfApprox_MaxError3d)
    Value = _swig_new_instance_method(_BRepApprox.BRepApprox_MyGradientOfTheComputeLineBezierOfApprox_Value)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_MyGradientOfTheComputeLineBezierOfApprox

# Register BRepApprox_MyGradientOfTheComputeLineBezierOfApprox in _BRepApprox:
_BRepApprox.BRepApprox_MyGradientOfTheComputeLineBezierOfApprox_swigregister(BRepApprox_MyGradientOfTheComputeLineBezierOfApprox)

class BRepApprox_MyGradientbisOfTheComputeLineOfApprox(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    AverageError = _swig_new_instance_method(_BRepApprox.BRepApprox_MyGradientbisOfTheComputeLineOfApprox_AverageError)

    def __init__(self, *args):
        r"""
        * Tries to minimize the sum (square(||Qui - Bi*Pi||)) where Pui describe the approximating Bezier curves'Poles and Qi the MultiLine points with a parameter ui. In this algorithm, the parameters ui are the unknowns. The tolerance required on this sum is given by Tol. The desired degree of the resulting curve is Deg.
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:param Tol3d:
        	:type Tol3d: float
        	:param Tol2d:
        	:type Tol2d: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:rtype: None
        """
        _BRepApprox.BRepApprox_MyGradientbisOfTheComputeLineOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_MyGradientbisOfTheComputeLineOfApprox(*args))
    Error = _swig_new_instance_method(_BRepApprox.BRepApprox_MyGradientbisOfTheComputeLineOfApprox_Error)
    IsDone = _swig_new_instance_method(_BRepApprox.BRepApprox_MyGradientbisOfTheComputeLineOfApprox_IsDone)
    MaxError2d = _swig_new_instance_method(_BRepApprox.BRepApprox_MyGradientbisOfTheComputeLineOfApprox_MaxError2d)
    MaxError3d = _swig_new_instance_method(_BRepApprox.BRepApprox_MyGradientbisOfTheComputeLineOfApprox_MaxError3d)
    Value = _swig_new_instance_method(_BRepApprox.BRepApprox_MyGradientbisOfTheComputeLineOfApprox_Value)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_MyGradientbisOfTheComputeLineOfApprox

# Register BRepApprox_MyGradientbisOfTheComputeLineOfApprox in _BRepApprox:
_BRepApprox.BRepApprox_MyGradientbisOfTheComputeLineOfApprox_swigregister(BRepApprox_MyGradientbisOfTheComputeLineOfApprox)

class BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox(OCC.Core.math.math_MultipleVarFunctionWithGradient):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * initializes the fields of the function. The approximating curve has the desired degree Deg.
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:rtype: None
        """
        _BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox(*args))
    CurveValue = _swig_new_instance_method(_BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_CurveValue)
    Error = _swig_new_instance_method(_BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_Error)
    FirstConstraint = _swig_new_instance_method(_BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_FirstConstraint)
    LastConstraint = _swig_new_instance_method(_BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_LastConstraint)
    MaxError2d = _swig_new_instance_method(_BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_MaxError2d)
    MaxError3d = _swig_new_instance_method(_BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_MaxError3d)
    NewParameters = _swig_new_instance_method(_BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_NewParameters)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox

# Register BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox in _BRepApprox:
_BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_swigregister(BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox)

class BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox(OCC.Core.math.math_MultipleVarFunctionWithGradient):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * initializes the fields of the function. The approximating curve has the desired degree Deg.
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param TheConstraints:
        	:type TheConstraints: AppParCurves_HArray1OfConstraintCouple
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param Deg:
        	:type Deg: int
        	:rtype: None
        """
        _BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox(*args))
    CurveValue = _swig_new_instance_method(_BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_CurveValue)
    Error = _swig_new_instance_method(_BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_Error)
    FirstConstraint = _swig_new_instance_method(_BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_FirstConstraint)
    LastConstraint = _swig_new_instance_method(_BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_LastConstraint)
    MaxError2d = _swig_new_instance_method(_BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_MaxError2d)
    MaxError3d = _swig_new_instance_method(_BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_MaxError3d)
    NewParameters = _swig_new_instance_method(_BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_NewParameters)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox

# Register BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox in _BRepApprox:
_BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_swigregister(BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox)

class BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. NbPol is the number of control points wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the Bernstein matrix computed with the parameters, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None* Initializes the fields of the object.
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None* given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. Deg is the degree wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the BSpline functions matrix computed with <parameters>, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None* Initializes the fields of the object.
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        """
        _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox(*args))
    BSplineValue = _swig_new_instance_method(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_BSplineValue)
    BezierValue = _swig_new_instance_method(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_BezierValue)
    DerivativeFunctionMatrix = _swig_new_instance_method(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_DerivativeFunctionMatrix)
    Distance = _swig_new_instance_method(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_Distance)
    Error = _swig_new_instance_method(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_Error)
    ErrorGradient = _swig_new_instance_method(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_ErrorGradient)
    FirstLambda = _swig_new_instance_method(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_FirstLambda)
    FunctionMatrix = _swig_new_instance_method(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_FunctionMatrix)
    IsDone = _swig_new_instance_method(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_IsDone)
    KIndex = _swig_new_instance_method(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_KIndex)
    LastLambda = _swig_new_instance_method(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_LastLambda)
    Perform = _swig_new_instance_method(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_Perform)
    Points = _swig_new_instance_method(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_Points)
    Poles = _swig_new_instance_method(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_Poles)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox

# Register BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox in _BRepApprox:
_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_swigregister(BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox)

class BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. NbPol is the number of control points wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the Bernstein matrix computed with the parameters, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None* Initializes the fields of the object.
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None* given a MultiLine, this algorithm computes the least square resolution using the Householder-QR method. If the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. Deg is the degree wanted for the approximating curves. The system to solve is the following: A X = B. Where A is the BSpline functions matrix computed with <parameters>, B the points coordinates and X the poles solutions. The matrix A is the same for each coordinate x, y and z and is also the same for each MultiLine point because they are approximated in parallel(so with the same parameter, only the vector B changes).
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None* Initializes the fields of the object.
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param Knots:
        	:type Knots: TColStd_Array1OfReal
        	:param Mults:
        	:type Mults: TColStd_Array1OfInteger
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param FirstCons:
        	:type FirstCons: AppParCurves_Constraint
        	:param LastCons:
        	:type LastCons: AppParCurves_Constraint
        	:param NbPol:
        	:type NbPol: int
        	:rtype: None
        """
        _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox(*args))
    BSplineValue = _swig_new_instance_method(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_BSplineValue)
    BezierValue = _swig_new_instance_method(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_BezierValue)
    DerivativeFunctionMatrix = _swig_new_instance_method(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_DerivativeFunctionMatrix)
    Distance = _swig_new_instance_method(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_Distance)
    Error = _swig_new_instance_method(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_Error)
    ErrorGradient = _swig_new_instance_method(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_ErrorGradient)
    FirstLambda = _swig_new_instance_method(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_FirstLambda)
    FunctionMatrix = _swig_new_instance_method(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_FunctionMatrix)
    IsDone = _swig_new_instance_method(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_IsDone)
    KIndex = _swig_new_instance_method(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_KIndex)
    LastLambda = _swig_new_instance_method(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_LastLambda)
    Perform = _swig_new_instance_method(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_Perform)
    Points = _swig_new_instance_method(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_Points)
    Poles = _swig_new_instance_method(_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_Poles)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox

# Register BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox in _BRepApprox:
_BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_swigregister(BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox)

class BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Given a MultiLine SSP with constraints points, this algorithm finds the best curve solution to approximate it. The poles from SCurv issued for example from the least squares are used as a guess solution for the uzawa algorithm. The tolerance used in the Uzawa algorithms is Tolerance. A is the Bernstein matrix associated to the MultiLine and DA is the derivative bernstein matrix.(They can come from an approximation with ParLeastSquare.) The MultiCurve is modified. New MultiPoles are given.
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param SCurv:
        	:type SCurv: AppParCurves_MultiCurve
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param Constraints:
        	:type Constraints: AppParCurves_HArray1OfConstraintCouple
        	:param Bern:
        	:type Bern: math_Matrix
        	:param DerivativeBern:
        	:type DerivativeBern: math_Matrix
        	:param Tolerance: default value is 1.0e-10
        	:type Tolerance: float
        	:rtype: None
        """
        _BRepApprox.BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox(*args))
    ConstraintDerivative = _swig_new_instance_method(_BRepApprox.BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox_ConstraintDerivative)
    ConstraintMatrix = _swig_new_instance_method(_BRepApprox.BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox_ConstraintMatrix)
    Duale = _swig_new_instance_method(_BRepApprox.BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox_Duale)
    InverseMatrix = _swig_new_instance_method(_BRepApprox.BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox_InverseMatrix)
    IsDone = _swig_new_instance_method(_BRepApprox.BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox_IsDone)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox

# Register BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox in _BRepApprox:
_BRepApprox.BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox_swigregister(BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox)

class BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Given a MultiLine SSP with constraints points, this algorithm finds the best curve solution to approximate it. The poles from SCurv issued for example from the least squares are used as a guess solution for the uzawa algorithm. The tolerance used in the Uzawa algorithms is Tolerance. A is the Bernstein matrix associated to the MultiLine and DA is the derivative bernstein matrix.(They can come from an approximation with ParLeastSquare.) The MultiCurve is modified. New MultiPoles are given.
        	:param SSP:
        	:type SSP: BRepApprox_TheMultiLineOfApprox
        	:param SCurv:
        	:type SCurv: AppParCurves_MultiCurve
        	:param FirstPoint:
        	:type FirstPoint: int
        	:param LastPoint:
        	:type LastPoint: int
        	:param Constraints:
        	:type Constraints: AppParCurves_HArray1OfConstraintCouple
        	:param Bern:
        	:type Bern: math_Matrix
        	:param DerivativeBern:
        	:type DerivativeBern: math_Matrix
        	:param Tolerance: default value is 1.0e-10
        	:type Tolerance: float
        	:rtype: None
        """
        _BRepApprox.BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox(*args))
    ConstraintDerivative = _swig_new_instance_method(_BRepApprox.BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox_ConstraintDerivative)
    ConstraintMatrix = _swig_new_instance_method(_BRepApprox.BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox_ConstraintMatrix)
    Duale = _swig_new_instance_method(_BRepApprox.BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox_Duale)
    InverseMatrix = _swig_new_instance_method(_BRepApprox.BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox_InverseMatrix)
    IsDone = _swig_new_instance_method(_BRepApprox.BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox_IsDone)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox

# Register BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox in _BRepApprox:
_BRepApprox.BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox_swigregister(BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox)

class BRepApprox_TheComputeLineBezierOfApprox(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * The MultiLine <Line> will be approximated until tolerances will be reached. The approximation will be done from degreemin to degreemax with a cutting if the corresponding boolean is True. If <Squares> is True, the computation will be done with no iteration at all.
        	:param Line:
        	:type Line: BRepApprox_TheMultiLineOfApprox
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-3
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-6
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param parametrization: default value is Approx_ChordLength
        	:type parametrization: Approx_ParametrizationType
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None* The MultiLine <Line> will be approximated until tolerances will be reached. The approximation will be done from degreemin to degreemax with a cutting if the corresponding boolean is True. If <Squares> is True, the computation will be done with no iteration at all.
        	:param Line:
        	:type Line: BRepApprox_TheMultiLineOfApprox
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None* Initializes the fields of the algorithm.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None* Initializes the fields of the algorithm.
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param parametrization: default value is Approx_ChordLength
        	:type parametrization: Approx_ParametrizationType
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        """
        _BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_TheComputeLineBezierOfApprox(*args))
    ChangeValue = _swig_new_instance_method(_BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_ChangeValue)
    Error = _swig_new_instance_method(_BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_Error)
    Init = _swig_new_instance_method(_BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_Init)
    IsAllApproximated = _swig_new_instance_method(_BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_IsAllApproximated)
    IsToleranceReached = _swig_new_instance_method(_BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_IsToleranceReached)
    NbMultiCurves = _swig_new_instance_method(_BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_NbMultiCurves)
    Parameters = _swig_new_instance_method(_BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_Parameters)
    Parametrization = _swig_new_instance_method(_BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_Parametrization)
    Perform = _swig_new_instance_method(_BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_Perform)
    SetConstraints = _swig_new_instance_method(_BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_SetConstraints)
    SetDegrees = _swig_new_instance_method(_BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_SetDegrees)
    SetTolerances = _swig_new_instance_method(_BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_SetTolerances)
    SplineValue = _swig_new_instance_method(_BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_SplineValue)
    Value = _swig_new_instance_method(_BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_Value)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_TheComputeLineBezierOfApprox

# Register BRepApprox_TheComputeLineBezierOfApprox in _BRepApprox:
_BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_swigregister(BRepApprox_TheComputeLineBezierOfApprox)

class BRepApprox_TheComputeLineOfApprox(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * The MultiLine <Line> will be approximated until tolerances will be reached. The approximation will be done from degreemin to degreemax with a cutting if the corresponding boolean is True. If <Squares> is True, the computation will be done with no iteration at all. //! The multiplicities of the internal knots is set by default.
        	:param Line:
        	:type Line: BRepApprox_TheMultiLineOfApprox
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-3
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-6
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param parametrization: default value is Approx_ChordLength
        	:type parametrization: Approx_ParametrizationType
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None* The MultiLine <Line> will be approximated until tolerances will be reached. The approximation will be done from degreemin to degreemax with a cutting if the corresponding boolean is True. If <Squares> is True, the computation will be done with no iteration at all.
        	:param Line:
        	:type Line: BRepApprox_TheMultiLineOfApprox
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None* Initializes the fields of the algorithm.
        	:param Parameters:
        	:type Parameters: math_Vector
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None* Initializes the fields of the algorithm.
        	:param degreemin: default value is 4
        	:type degreemin: int
        	:param degreemax: default value is 8
        	:type degreemax: int
        	:param Tolerance3d: default value is 1.0e-03
        	:type Tolerance3d: float
        	:param Tolerance2d: default value is 1.0e-06
        	:type Tolerance2d: float
        	:param NbIterations: default value is 5
        	:type NbIterations: int
        	:param cutting: default value is Standard_True
        	:type cutting: bool
        	:param parametrization: default value is Approx_ChordLength
        	:type parametrization: Approx_ParametrizationType
        	:param Squares: default value is Standard_False
        	:type Squares: bool
        	:rtype: None
        """
        _BRepApprox.BRepApprox_TheComputeLineOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_TheComputeLineOfApprox(*args))
    ChangeValue = _swig_new_instance_method(_BRepApprox.BRepApprox_TheComputeLineOfApprox_ChangeValue)
    Error = _swig_new_instance_method(_BRepApprox.BRepApprox_TheComputeLineOfApprox_Error)
    Init = _swig_new_instance_method(_BRepApprox.BRepApprox_TheComputeLineOfApprox_Init)
    Interpol = _swig_new_instance_method(_BRepApprox.BRepApprox_TheComputeLineOfApprox_Interpol)
    IsAllApproximated = _swig_new_instance_method(_BRepApprox.BRepApprox_TheComputeLineOfApprox_IsAllApproximated)
    IsToleranceReached = _swig_new_instance_method(_BRepApprox.BRepApprox_TheComputeLineOfApprox_IsToleranceReached)
    Parameters = _swig_new_instance_method(_BRepApprox.BRepApprox_TheComputeLineOfApprox_Parameters)
    Perform = _swig_new_instance_method(_BRepApprox.BRepApprox_TheComputeLineOfApprox_Perform)
    SetConstraints = _swig_new_instance_method(_BRepApprox.BRepApprox_TheComputeLineOfApprox_SetConstraints)
    SetContinuity = _swig_new_instance_method(_BRepApprox.BRepApprox_TheComputeLineOfApprox_SetContinuity)
    SetDegrees = _swig_new_instance_method(_BRepApprox.BRepApprox_TheComputeLineOfApprox_SetDegrees)
    SetKnots = _swig_new_instance_method(_BRepApprox.BRepApprox_TheComputeLineOfApprox_SetKnots)
    SetKnotsAndMultiplicities = _swig_new_instance_method(_BRepApprox.BRepApprox_TheComputeLineOfApprox_SetKnotsAndMultiplicities)
    SetParameters = _swig_new_instance_method(_BRepApprox.BRepApprox_TheComputeLineOfApprox_SetParameters)
    SetPeriodic = _swig_new_instance_method(_BRepApprox.BRepApprox_TheComputeLineOfApprox_SetPeriodic)
    SetTolerances = _swig_new_instance_method(_BRepApprox.BRepApprox_TheComputeLineOfApprox_SetTolerances)
    Value = _swig_new_instance_method(_BRepApprox.BRepApprox_TheComputeLineOfApprox_Value)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_TheComputeLineOfApprox

# Register BRepApprox_TheComputeLineOfApprox in _BRepApprox:
_BRepApprox.BRepApprox_TheComputeLineOfApprox_swigregister(BRepApprox_TheComputeLineOfApprox)

class BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox(OCC.Core.math.math_FunctionSetWithDerivatives):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    AuxillarSurface1 = _swig_new_instance_method(_BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_AuxillarSurface1)
    AuxillarSurface2 = _swig_new_instance_method(_BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_AuxillarSurface2)

    def __init__(self, *args):
        r"""
        :param S1:
        	:type S1: BRepAdaptor_Surface
        	:param S2:
        	:type S2: BRepAdaptor_Surface
        	:rtype: None
        """
        _BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox(*args))
    ComputeParameters = _swig_new_instance_method(_BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_ComputeParameters)
    Direction = _swig_new_instance_method(_BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_Direction)
    DirectionOnS1 = _swig_new_instance_method(_BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_DirectionOnS1)
    DirectionOnS2 = _swig_new_instance_method(_BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_DirectionOnS2)
    IsTangent = _swig_new_instance_method(_BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_IsTangent)
    Point = _swig_new_instance_method(_BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_Point)
    Root = _swig_new_instance_method(_BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_Root)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox

# Register BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox in _BRepApprox:
_BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_swigregister(BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox)

class BRepApprox_TheImpPrmSvSurfacesOfApprox(OCC.Core.ApproxInt.ApproxInt_SvSurfaces):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        :param Surf1:
        	:type Surf1: BRepAdaptor_Surface
        	:param Surf2:
        	:type Surf2: IntSurf_Quadric
        	:rtype: None:param Surf1:
        	:type Surf1: IntSurf_Quadric
        	:param Surf2:
        	:type Surf2: BRepAdaptor_Surface
        	:rtype: None
        """
        _BRepApprox.BRepApprox_TheImpPrmSvSurfacesOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_TheImpPrmSvSurfacesOfApprox(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_TheImpPrmSvSurfacesOfApprox

# Register BRepApprox_TheImpPrmSvSurfacesOfApprox in _BRepApprox:
_BRepApprox.BRepApprox_TheImpPrmSvSurfacesOfApprox_swigregister(BRepApprox_TheImpPrmSvSurfacesOfApprox)

class BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * compute the solution point with the close point
        	:param Param:
        	:type Param: TColStd_Array1OfReal
        	:param S1:
        	:type S1: BRepAdaptor_Surface
        	:param S2:
        	:type S2: BRepAdaptor_Surface
        	:param TolTangency:
        	:type TolTangency: float
        	:rtype: None* initialize the parameters to compute the solution point it 's possible to write to optimize: IntImp_Int2S inter(S1,S2,Func,TolTangency); math_FunctionSetRoot rsnld(inter.Function()); while ...{ Param(1)=... Param(2)=... param(3)=... inter.Perform(Param,rsnld); }
        	:param S1:
        	:type S1: BRepAdaptor_Surface
        	:param S2:
        	:type S2: BRepAdaptor_Surface
        	:param TolTangency:
        	:type TolTangency: float
        	:rtype: None
        """
        _BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox(*args))
    ChangePoint = _swig_new_instance_method(_BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_ChangePoint)
    Direction = _swig_new_instance_method(_BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_Direction)
    DirectionOnS1 = _swig_new_instance_method(_BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_DirectionOnS1)
    DirectionOnS2 = _swig_new_instance_method(_BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_DirectionOnS2)
    Function = _swig_new_instance_method(_BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_Function)
    IsDone = _swig_new_instance_method(_BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_IsDone)
    IsEmpty = _swig_new_instance_method(_BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_IsEmpty)
    IsTangent = _swig_new_instance_method(_BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_IsTangent)
    Perform = _swig_new_instance_method(_BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_Perform)
    Point = _swig_new_instance_method(_BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_Point)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox

# Register BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox in _BRepApprox:
_BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_swigregister(BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox)

class BRepApprox_TheMultiLineOfApprox(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        :rtype: None* The class SvSurfaces is used when the approximation algorithm needs some extra points on the line <line>. A New line is then created which shares the same surfaces and functions. SvSurfaces is a deferred class which allows several implementations of this algorithm with different surfaces (bi-parametric ones, or implicit and biparametric ones)
        	:param line:
        	:type line: BRepApprox_ApproxLine
        	:param PtrSvSurfaces:
        	:type PtrSvSurfaces: Standard_Address
        	:param NbP3d:
        	:type NbP3d: int
        	:param NbP2d:
        	:type NbP2d: int
        	:param ApproxU1V1:
        	:type ApproxU1V1: bool
        	:param ApproxU2V2:
        	:type ApproxU2V2: bool
        	:param xo:
        	:type xo: float
        	:param yo:
        	:type yo: float
        	:param zo:
        	:type zo: float
        	:param u1o:
        	:type u1o: float
        	:param v1o:
        	:type v1o: float
        	:param u2o:
        	:type u2o: float
        	:param v2o:
        	:type v2o: float
        	:param P2DOnFirst:
        	:type P2DOnFirst: bool
        	:param IndMin: default value is 0
        	:type IndMin: int
        	:param IndMax: default value is 0
        	:type IndMax: int
        	:rtype: None* No Extra points will be added on the current line
        	:param line:
        	:type line: BRepApprox_ApproxLine
        	:param NbP3d:
        	:type NbP3d: int
        	:param NbP2d:
        	:type NbP2d: int
        	:param ApproxU1V1:
        	:type ApproxU1V1: bool
        	:param ApproxU2V2:
        	:type ApproxU2V2: bool
        	:param xo:
        	:type xo: float
        	:param yo:
        	:type yo: float
        	:param zo:
        	:type zo: float
        	:param u1o:
        	:type u1o: float
        	:param v1o:
        	:type v1o: float
        	:param u2o:
        	:type u2o: float
        	:param v2o:
        	:type v2o: float
        	:param P2DOnFirst:
        	:type P2DOnFirst: bool
        	:param IndMin: default value is 0
        	:type IndMin: int
        	:param IndMax: default value is 0
        	:type IndMax: int
        	:rtype: None
        """
        _BRepApprox.BRepApprox_TheMultiLineOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_TheMultiLineOfApprox(*args))
    Dump = _swig_new_instance_method(_BRepApprox.BRepApprox_TheMultiLineOfApprox_Dump)
    FirstPoint = _swig_new_instance_method(_BRepApprox.BRepApprox_TheMultiLineOfApprox_FirstPoint)
    LastPoint = _swig_new_instance_method(_BRepApprox.BRepApprox_TheMultiLineOfApprox_LastPoint)
    MakeMLBetween = _swig_new_instance_method(_BRepApprox.BRepApprox_TheMultiLineOfApprox_MakeMLBetween)
    MakeMLOneMorePoint = _swig_new_instance_method(_BRepApprox.BRepApprox_TheMultiLineOfApprox_MakeMLOneMorePoint)
    NbP2d = _swig_new_instance_method(_BRepApprox.BRepApprox_TheMultiLineOfApprox_NbP2d)
    NbP3d = _swig_new_instance_method(_BRepApprox.BRepApprox_TheMultiLineOfApprox_NbP3d)
    Tangency = _swig_new_instance_method(_BRepApprox.BRepApprox_TheMultiLineOfApprox_Tangency)
    Value = _swig_new_instance_method(_BRepApprox.BRepApprox_TheMultiLineOfApprox_Value)
    WhatStatus = _swig_new_instance_method(_BRepApprox.BRepApprox_TheMultiLineOfApprox_WhatStatus)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_TheMultiLineOfApprox

# Register BRepApprox_TheMultiLineOfApprox in _BRepApprox:
_BRepApprox.BRepApprox_TheMultiLineOfApprox_swigregister(BRepApprox_TheMultiLineOfApprox)

class BRepApprox_TheMultiLineToolOfApprox(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Curvature = _swig_new_static_method(_BRepApprox.BRepApprox_TheMultiLineToolOfApprox_Curvature)
    Dump = _swig_new_static_method(_BRepApprox.BRepApprox_TheMultiLineToolOfApprox_Dump)
    FirstPoint = _swig_new_static_method(_BRepApprox.BRepApprox_TheMultiLineToolOfApprox_FirstPoint)
    LastPoint = _swig_new_static_method(_BRepApprox.BRepApprox_TheMultiLineToolOfApprox_LastPoint)
    MakeMLBetween = _swig_new_static_method(_BRepApprox.BRepApprox_TheMultiLineToolOfApprox_MakeMLBetween)
    MakeMLOneMorePoint = _swig_new_static_method(_BRepApprox.BRepApprox_TheMultiLineToolOfApprox_MakeMLOneMorePoint)
    NbP2d = _swig_new_static_method(_BRepApprox.BRepApprox_TheMultiLineToolOfApprox_NbP2d)
    NbP3d = _swig_new_static_method(_BRepApprox.BRepApprox_TheMultiLineToolOfApprox_NbP3d)
    Tangency = _swig_new_static_method(_BRepApprox.BRepApprox_TheMultiLineToolOfApprox_Tangency)
    Value = _swig_new_static_method(_BRepApprox.BRepApprox_TheMultiLineToolOfApprox_Value)
    WhatStatus = _swig_new_static_method(_BRepApprox.BRepApprox_TheMultiLineToolOfApprox_WhatStatus)

    __repr__ = _dumps_object


    def __init__(self):
        _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_TheMultiLineToolOfApprox())
    __swig_destroy__ = _BRepApprox.delete_BRepApprox_TheMultiLineToolOfApprox

# Register BRepApprox_TheMultiLineToolOfApprox in _BRepApprox:
_BRepApprox.BRepApprox_TheMultiLineToolOfApprox_swigregister(BRepApprox_TheMultiLineToolOfApprox)
BRepApprox_TheMultiLineToolOfApprox_Curvature = _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_Curvature
BRepApprox_TheMultiLineToolOfApprox_Dump = _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_Dump
BRepApprox_TheMultiLineToolOfApprox_FirstPoint = _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_FirstPoint
BRepApprox_TheMultiLineToolOfApprox_LastPoint = _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_LastPoint
BRepApprox_TheMultiLineToolOfApprox_MakeMLBetween = _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_MakeMLBetween
BRepApprox_TheMultiLineToolOfApprox_MakeMLOneMorePoint = _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_MakeMLOneMorePoint
BRepApprox_TheMultiLineToolOfApprox_NbP2d = _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_NbP2d
BRepApprox_TheMultiLineToolOfApprox_NbP3d = _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_NbP3d
BRepApprox_TheMultiLineToolOfApprox_Tangency = _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_Tangency
BRepApprox_TheMultiLineToolOfApprox_Value = _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_Value
BRepApprox_TheMultiLineToolOfApprox_WhatStatus = _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_WhatStatus

class BRepApprox_ThePrmPrmSvSurfacesOfApprox(OCC.Core.ApproxInt.ApproxInt_SvSurfaces):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        :param Surf1:
        	:type Surf1: BRepAdaptor_Surface
        	:param Surf2:
        	:type Surf2: BRepAdaptor_Surface
        	:rtype: None
        """
        _BRepApprox.BRepApprox_ThePrmPrmSvSurfacesOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_ThePrmPrmSvSurfacesOfApprox(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_ThePrmPrmSvSurfacesOfApprox

# Register BRepApprox_ThePrmPrmSvSurfacesOfApprox in _BRepApprox:
_BRepApprox.BRepApprox_ThePrmPrmSvSurfacesOfApprox_swigregister(BRepApprox_ThePrmPrmSvSurfacesOfApprox)

class BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox(OCC.Core.math.math_FunctionSetWithDerivatives):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        :rtype: None:param PS:
        	:type PS: BRepAdaptor_Surface
        	:param IS:
        	:type IS: IntSurf_Quadric
        	:rtype: None:param IS:
        	:type IS: IntSurf_Quadric
        	:rtype: None
        """
        _BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_swiginit(self, _BRepApprox.new_BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox(*args))
    Direction2d = _swig_new_instance_method(_BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_Direction2d)
    Direction3d = _swig_new_instance_method(_BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_Direction3d)
    ISurface = _swig_new_instance_method(_BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_ISurface)
    IsTangent = _swig_new_instance_method(_BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_IsTangent)
    PSurface = _swig_new_instance_method(_BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_PSurface)
    Point = _swig_new_instance_method(_BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_Point)
    Root = _swig_new_instance_method(_BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_Root)
    Set = _swig_new_instance_method(_BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_Set)
    SetImplicitSurface = _swig_new_instance_method(_BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_SetImplicitSurface)
    Tolerance = _swig_new_instance_method(_BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_Tolerance)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox

# Register BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox in _BRepApprox:
_BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_swigregister(BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox)



