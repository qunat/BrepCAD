# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
Geom2dConvert module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_geom2dconvert.html
"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _Geom2dConvert
else:
    import _Geom2dConvert

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _Geom2dConvert.SWIG_PyInstanceMethod_New
_swig_new_static_method = _Geom2dConvert.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Geom2dConvert.delete_SwigPyIterator
    value = _swig_new_instance_method(_Geom2dConvert.SwigPyIterator_value)
    incr = _swig_new_instance_method(_Geom2dConvert.SwigPyIterator_incr)
    decr = _swig_new_instance_method(_Geom2dConvert.SwigPyIterator_decr)
    distance = _swig_new_instance_method(_Geom2dConvert.SwigPyIterator_distance)
    equal = _swig_new_instance_method(_Geom2dConvert.SwigPyIterator_equal)
    copy = _swig_new_instance_method(_Geom2dConvert.SwigPyIterator_copy)
    next = _swig_new_instance_method(_Geom2dConvert.SwigPyIterator_next)
    __next__ = _swig_new_instance_method(_Geom2dConvert.SwigPyIterator___next__)
    previous = _swig_new_instance_method(_Geom2dConvert.SwigPyIterator_previous)
    advance = _swig_new_instance_method(_Geom2dConvert.SwigPyIterator_advance)
    __eq__ = _swig_new_instance_method(_Geom2dConvert.SwigPyIterator___eq__)
    __ne__ = _swig_new_instance_method(_Geom2dConvert.SwigPyIterator___ne__)
    __iadd__ = _swig_new_instance_method(_Geom2dConvert.SwigPyIterator___iadd__)
    __isub__ = _swig_new_instance_method(_Geom2dConvert.SwigPyIterator___isub__)
    __add__ = _swig_new_instance_method(_Geom2dConvert.SwigPyIterator___add__)
    __sub__ = _swig_new_instance_method(_Geom2dConvert.SwigPyIterator___sub__)
    def __iter__(self):
        return self

# Register SwigPyIterator in _Geom2dConvert:
_Geom2dConvert.SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.Geom2d
import OCC.Core.gp
import OCC.Core.GeomAbs
import OCC.Core.TColgp
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.TColGeom2d
import OCC.Core.Convert
import OCC.Core.Adaptor2d
class geom2dconvert(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    C0BSplineToArrayOfC1BSplineCurve = _swig_new_static_method(_Geom2dConvert.geom2dconvert_C0BSplineToArrayOfC1BSplineCurve)
    C0BSplineToC1BSplineCurve = _swig_new_static_method(_Geom2dConvert.geom2dconvert_C0BSplineToC1BSplineCurve)
    ConcatC1 = _swig_new_static_method(_Geom2dConvert.geom2dconvert_ConcatC1)
    ConcatG1 = _swig_new_static_method(_Geom2dConvert.geom2dconvert_ConcatG1)
    CurveToBSplineCurve = _swig_new_static_method(_Geom2dConvert.geom2dconvert_CurveToBSplineCurve)
    SplitBSplineCurve = _swig_new_static_method(_Geom2dConvert.geom2dconvert_SplitBSplineCurve)

    __repr__ = _dumps_object


    def __init__(self):
        _Geom2dConvert.geom2dconvert_swiginit(self, _Geom2dConvert.new_geom2dconvert())
    __swig_destroy__ = _Geom2dConvert.delete_geom2dconvert

# Register geom2dconvert in _Geom2dConvert:
_Geom2dConvert.geom2dconvert_swigregister(geom2dconvert)
geom2dconvert_C0BSplineToArrayOfC1BSplineCurve = _Geom2dConvert.geom2dconvert_C0BSplineToArrayOfC1BSplineCurve
geom2dconvert_C0BSplineToC1BSplineCurve = _Geom2dConvert.geom2dconvert_C0BSplineToC1BSplineCurve
geom2dconvert_ConcatC1 = _Geom2dConvert.geom2dconvert_ConcatC1
geom2dconvert_ConcatG1 = _Geom2dConvert.geom2dconvert_ConcatG1
geom2dconvert_CurveToBSplineCurve = _Geom2dConvert.geom2dconvert_CurveToBSplineCurve
geom2dconvert_SplitBSplineCurve = _Geom2dConvert.geom2dconvert_SplitBSplineCurve

class Geom2dConvert_ApproxCurve(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Curve = _swig_new_instance_method(_Geom2dConvert.Geom2dConvert_ApproxCurve_Curve)
    DumpToString = _swig_new_instance_method(_Geom2dConvert.Geom2dConvert_ApproxCurve_DumpToString)

    def __init__(self, *args):
        r"""
        * Constructs an approximation framework defined by - the 2D conic Curve - the tolerance value Tol2d - the degree of continuity Order - the maximum number of segments allowed MaxSegments - the highest degree MaxDegree which the polynomial defining the BSpline is allowed to have.
        	:param Curve:
        	:type Curve: Geom2d_Curve
        	:param Tol2d:
        	:type Tol2d: float
        	:param Order:
        	:type Order: GeomAbs_Shape
        	:param MaxSegments:
        	:type MaxSegments: int
        	:param MaxDegree:
        	:type MaxDegree: int
        	:rtype: None* Constructs an approximation framework defined by - the 2D conic Curve - the tolerance value Tol2d - the degree of continuity Order - the maximum number of segments allowed MaxSegments - the highest degree MaxDegree which the polynomial defining the BSpline is allowed to have.
        	:param Curve:
        	:type Curve: Adaptor2d_HCurve2d
        	:param Tol2d:
        	:type Tol2d: float
        	:param Order:
        	:type Order: GeomAbs_Shape
        	:param MaxSegments:
        	:type MaxSegments: int
        	:param MaxDegree:
        	:type MaxDegree: int
        	:rtype: None
        """
        _Geom2dConvert.Geom2dConvert_ApproxCurve_swiginit(self, _Geom2dConvert.new_Geom2dConvert_ApproxCurve(*args))
    HasResult = _swig_new_instance_method(_Geom2dConvert.Geom2dConvert_ApproxCurve_HasResult)
    IsDone = _swig_new_instance_method(_Geom2dConvert.Geom2dConvert_ApproxCurve_IsDone)
    MaxError = _swig_new_instance_method(_Geom2dConvert.Geom2dConvert_ApproxCurve_MaxError)

    __repr__ = _dumps_object

    __swig_destroy__ = _Geom2dConvert.delete_Geom2dConvert_ApproxCurve

# Register Geom2dConvert_ApproxCurve in _Geom2dConvert:
_Geom2dConvert.Geom2dConvert_ApproxCurve_swigregister(Geom2dConvert_ApproxCurve)

class Geom2dConvert_BSplineCurveKnotSplitting(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Determines points at which the BSpline curve BasisCurve should be split in order to obtain arcs with a degree of continuity equal to ContinuityRange. These points are knot values of BasisCurve. They are identified by indices in the knots table of BasisCurve. Use the available interrogation functions to access computed values, followed by the global function SplitBSplineCurve (provided by the package Geom2dConvert) to split the curve. Exceptions Standard_RangeError if ContinuityRange is less than zero.
        	:param BasisCurve:
        	:type BasisCurve: Geom2d_BSplineCurve
        	:param ContinuityRange:
        	:type ContinuityRange: int
        	:rtype: None
        """
        _Geom2dConvert.Geom2dConvert_BSplineCurveKnotSplitting_swiginit(self, _Geom2dConvert.new_Geom2dConvert_BSplineCurveKnotSplitting(*args))
    NbSplits = _swig_new_instance_method(_Geom2dConvert.Geom2dConvert_BSplineCurveKnotSplitting_NbSplits)
    SplitValue = _swig_new_instance_method(_Geom2dConvert.Geom2dConvert_BSplineCurveKnotSplitting_SplitValue)
    Splitting = _swig_new_instance_method(_Geom2dConvert.Geom2dConvert_BSplineCurveKnotSplitting_Splitting)

    __repr__ = _dumps_object

    __swig_destroy__ = _Geom2dConvert.delete_Geom2dConvert_BSplineCurveKnotSplitting

# Register Geom2dConvert_BSplineCurveKnotSplitting in _Geom2dConvert:
_Geom2dConvert.Geom2dConvert_BSplineCurveKnotSplitting_swigregister(Geom2dConvert_BSplineCurveKnotSplitting)

class Geom2dConvert_BSplineCurveToBezierCurve(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Arc = _swig_new_instance_method(_Geom2dConvert.Geom2dConvert_BSplineCurveToBezierCurve_Arc)
    Arcs = _swig_new_instance_method(_Geom2dConvert.Geom2dConvert_BSplineCurveToBezierCurve_Arcs)

    def __init__(self, *args):
        r"""
        * Computes all the data needed to convert - the BSpline curve BasisCurve, into a series of adjacent Bezier arcs. The result consists of a series of BasisCurve arcs limited by points corresponding to knot values of the curve. Use the available interrogation functions to ascertain the number of computed Bezier arcs, and then to construct each individual Bezier curve (or all Bezier curves). Note: ParametricTolerance is not used.
        	:param BasisCurve:
        	:type BasisCurve: Geom2d_BSplineCurve
        	:rtype: None* Computes all the data needed to convert the portion of the BSpline curve BasisCurve limited by the two parameter values U1 and U2 for Example if there is a Knot Uk and Uk < U < Uk + ParametricTolerance/2 the last curve corresponds to the span [Uk-1, Uk] and not to [Uk, Uk+1] The result consists of a series of BasisCurve arcs limited by points corresponding to knot values of the curve. Use the available interrogation functions to ascertain the number of computed Bezier arcs, and then to construct each individual Bezier curve (or all Bezier curves). Note: ParametricTolerance is not used. Raises DomainError if U1 or U2 are out of the parametric bounds of the basis curve [FirstParameter, LastParameter]. The Tolerance criterion is ParametricTolerance. Raised if Abs (U2 - U1) <= ParametricTolerance.
        	:param BasisCurve:
        	:type BasisCurve: Geom2d_BSplineCurve
        	:param U1:
        	:type U1: float
        	:param U2:
        	:type U2: float
        	:param ParametricTolerance:
        	:type ParametricTolerance: float
        	:rtype: None
        """
        _Geom2dConvert.Geom2dConvert_BSplineCurveToBezierCurve_swiginit(self, _Geom2dConvert.new_Geom2dConvert_BSplineCurveToBezierCurve(*args))
    Knots = _swig_new_instance_method(_Geom2dConvert.Geom2dConvert_BSplineCurveToBezierCurve_Knots)
    NbArcs = _swig_new_instance_method(_Geom2dConvert.Geom2dConvert_BSplineCurveToBezierCurve_NbArcs)

    __repr__ = _dumps_object

    __swig_destroy__ = _Geom2dConvert.delete_Geom2dConvert_BSplineCurveToBezierCurve

# Register Geom2dConvert_BSplineCurveToBezierCurve in _Geom2dConvert:
_Geom2dConvert.Geom2dConvert_BSplineCurveToBezierCurve_swigregister(Geom2dConvert_BSplineCurveToBezierCurve)

class Geom2dConvert_CompCurveToBSplineCurve(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Add = _swig_new_instance_method(_Geom2dConvert.Geom2dConvert_CompCurveToBSplineCurve_Add)
    BSplineCurve = _swig_new_instance_method(_Geom2dConvert.Geom2dConvert_CompCurveToBSplineCurve_BSplineCurve)
    Clear = _swig_new_instance_method(_Geom2dConvert.Geom2dConvert_CompCurveToBSplineCurve_Clear)

    def __init__(self, *args):
        r"""
        * Initialize the algorithme - Parameterisation is used to convert
        	:param Parameterisation: default value is Convert_TgtThetaOver2
        	:type Parameterisation: Convert_ParameterisationType
        	:rtype: None* Initialize the algorithme with one curve - Parameterisation is used to convert
        	:param BasisCurve:
        	:type BasisCurve: Geom2d_BoundedCurve
        	:param Parameterisation: default value is Convert_TgtThetaOver2
        	:type Parameterisation: Convert_ParameterisationType
        	:rtype: None
        """
        _Geom2dConvert.Geom2dConvert_CompCurveToBSplineCurve_swiginit(self, _Geom2dConvert.new_Geom2dConvert_CompCurveToBSplineCurve(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _Geom2dConvert.delete_Geom2dConvert_CompCurveToBSplineCurve

# Register Geom2dConvert_CompCurveToBSplineCurve in _Geom2dConvert:
_Geom2dConvert.Geom2dConvert_CompCurveToBSplineCurve_swigregister(Geom2dConvert_CompCurveToBSplineCurve)



