# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
BRepPrimAPI module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_brepprimapi.html
"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _BRepPrimAPI
else:
    import _BRepPrimAPI

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _BRepPrimAPI.SWIG_PyInstanceMethod_New
_swig_new_static_method = _BRepPrimAPI.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BRepPrimAPI.delete_SwigPyIterator
    value = _swig_new_instance_method(_BRepPrimAPI.SwigPyIterator_value)
    incr = _swig_new_instance_method(_BRepPrimAPI.SwigPyIterator_incr)
    decr = _swig_new_instance_method(_BRepPrimAPI.SwigPyIterator_decr)
    distance = _swig_new_instance_method(_BRepPrimAPI.SwigPyIterator_distance)
    equal = _swig_new_instance_method(_BRepPrimAPI.SwigPyIterator_equal)
    copy = _swig_new_instance_method(_BRepPrimAPI.SwigPyIterator_copy)
    next = _swig_new_instance_method(_BRepPrimAPI.SwigPyIterator_next)
    __next__ = _swig_new_instance_method(_BRepPrimAPI.SwigPyIterator___next__)
    previous = _swig_new_instance_method(_BRepPrimAPI.SwigPyIterator_previous)
    advance = _swig_new_instance_method(_BRepPrimAPI.SwigPyIterator_advance)
    __eq__ = _swig_new_instance_method(_BRepPrimAPI.SwigPyIterator___eq__)
    __ne__ = _swig_new_instance_method(_BRepPrimAPI.SwigPyIterator___ne__)
    __iadd__ = _swig_new_instance_method(_BRepPrimAPI.SwigPyIterator___iadd__)
    __isub__ = _swig_new_instance_method(_BRepPrimAPI.SwigPyIterator___isub__)
    __add__ = _swig_new_instance_method(_BRepPrimAPI.SwigPyIterator___add__)
    __sub__ = _swig_new_instance_method(_BRepPrimAPI.SwigPyIterator___sub__)
    def __iter__(self):
        return self

# Register SwigPyIterator in _BRepPrimAPI:
_BRepPrimAPI.SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.BRepBuilderAPI
import OCC.Core.Geom
import OCC.Core.gp
import OCC.Core.GeomAbs
import OCC.Core.TColgp
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.TopoDS
import OCC.Core.Message
import OCC.Core.TopAbs
import OCC.Core.TopLoc
import OCC.Core.TopTools
import OCC.Core.BRepTools
import OCC.Core.Bnd
import OCC.Core.BVH
import OCC.Core.Geom2d
import OCC.Core.BRep
import OCC.Core.Poly
import OCC.Core.TShort
import OCC.Core.BRepPrim
import OCC.Core.BRepSweep
import OCC.Core.Sweep
class BRepPrimAPI_MakeBox(OCC.Core.BRepBuilderAPI.BRepBuilderAPI_MakeShape):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Make a box with a corner at 0,0,0 and the other dx,dy,dz
        	:param dx:
        	:type dx: float
        	:param dy:
        	:type dy: float
        	:param dz:
        	:type dz: float
        	:rtype: None* Make a box with a corner at P and size dx, dy, dz.
        	:param P:
        	:type P: gp_Pnt
        	:param dx:
        	:type dx: float
        	:param dy:
        	:type dy: float
        	:param dz:
        	:type dz: float
        	:rtype: None* Make a box with corners P1,P2.
        	:param P1:
        	:type P1: gp_Pnt
        	:param P2:
        	:type P2: gp_Pnt
        	:rtype: None* Ax2 is the left corner and the axis. Constructs a box such that its sides are parallel to the axes of - the global coordinate system, or - the local coordinate system Axis. and - with a corner at (0, 0, 0) and of size (dx, dy, dz), or - with a corner at point P and of size (dx, dy, dz), or - with corners at points P1 and P2. Exceptions Standard_DomainError if: dx, dy, dz are less than or equal to Precision::Confusion(), or - the vector joining the points P1 and P2 has a component projected onto the global coordinate system less than or equal to Precision::Confusion(). In these cases, the box would be flat.
        	:param Axes:
        	:type Axes: gp_Ax2
        	:param dx:
        	:type dx: float
        	:param dy:
        	:type dy: float
        	:param dz:
        	:type dz: float
        	:rtype: None
        """
        _BRepPrimAPI.BRepPrimAPI_MakeBox_swiginit(self, _BRepPrimAPI.new_BRepPrimAPI_MakeBox(*args))
    BackFace = _swig_new_instance_method(_BRepPrimAPI.BRepPrimAPI_MakeBox_BackFace)
    BottomFace = _swig_new_instance_method(_BRepPrimAPI.BRepPrimAPI_MakeBox_BottomFace)
    FrontFace = _swig_new_instance_method(_BRepPrimAPI.BRepPrimAPI_MakeBox_FrontFace)
    LeftFace = _swig_new_instance_method(_BRepPrimAPI.BRepPrimAPI_MakeBox_LeftFace)
    RightFace = _swig_new_instance_method(_BRepPrimAPI.BRepPrimAPI_MakeBox_RightFace)
    Shell = _swig_new_instance_method(_BRepPrimAPI.BRepPrimAPI_MakeBox_Shell)
    Solid = _swig_new_instance_method(_BRepPrimAPI.BRepPrimAPI_MakeBox_Solid)
    TopFace = _swig_new_instance_method(_BRepPrimAPI.BRepPrimAPI_MakeBox_TopFace)
    Wedge = _swig_new_instance_method(_BRepPrimAPI.BRepPrimAPI_MakeBox_Wedge)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepPrimAPI.delete_BRepPrimAPI_MakeBox

# Register BRepPrimAPI_MakeBox in _BRepPrimAPI:
_BRepPrimAPI.BRepPrimAPI_MakeBox_swigregister(BRepPrimAPI_MakeBox)

class BRepPrimAPI_MakeHalfSpace(OCC.Core.BRepBuilderAPI.BRepBuilderAPI_MakeShape):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Make a HalfSpace defined with a Face and a Point.
        	:param Face:
        	:type Face: TopoDS_Face
        	:param RefPnt:
        	:type RefPnt: gp_Pnt
        	:rtype: None* Make a HalfSpace defined with a Shell and a Point.
        	:param Shell:
        	:type Shell: TopoDS_Shell
        	:param RefPnt:
        	:type RefPnt: gp_Pnt
        	:rtype: None
        """
        _BRepPrimAPI.BRepPrimAPI_MakeHalfSpace_swiginit(self, _BRepPrimAPI.new_BRepPrimAPI_MakeHalfSpace(*args))
    Solid = _swig_new_instance_method(_BRepPrimAPI.BRepPrimAPI_MakeHalfSpace_Solid)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepPrimAPI.delete_BRepPrimAPI_MakeHalfSpace

# Register BRepPrimAPI_MakeHalfSpace in _BRepPrimAPI:
_BRepPrimAPI.BRepPrimAPI_MakeHalfSpace_swigregister(BRepPrimAPI_MakeHalfSpace)

class BRepPrimAPI_MakeOneAxis(OCC.Core.BRepBuilderAPI.BRepBuilderAPI_MakeShape):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Face = _swig_new_instance_method(_BRepPrimAPI.BRepPrimAPI_MakeOneAxis_Face)
    OneAxis = _swig_new_instance_method(_BRepPrimAPI.BRepPrimAPI_MakeOneAxis_OneAxis)
    Shell = _swig_new_instance_method(_BRepPrimAPI.BRepPrimAPI_MakeOneAxis_Shell)
    Solid = _swig_new_instance_method(_BRepPrimAPI.BRepPrimAPI_MakeOneAxis_Solid)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepPrimAPI.delete_BRepPrimAPI_MakeOneAxis

# Register BRepPrimAPI_MakeOneAxis in _BRepPrimAPI:
_BRepPrimAPI.BRepPrimAPI_MakeOneAxis_swigregister(BRepPrimAPI_MakeOneAxis)

class BRepPrimAPI_MakeSweep(OCC.Core.BRepBuilderAPI.BRepBuilderAPI_MakeShape):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    FirstShape = _swig_new_instance_method(_BRepPrimAPI.BRepPrimAPI_MakeSweep_FirstShape)
    LastShape = _swig_new_instance_method(_BRepPrimAPI.BRepPrimAPI_MakeSweep_LastShape)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepPrimAPI.delete_BRepPrimAPI_MakeSweep

# Register BRepPrimAPI_MakeSweep in _BRepPrimAPI:
_BRepPrimAPI.BRepPrimAPI_MakeSweep_swigregister(BRepPrimAPI_MakeSweep)

class BRepPrimAPI_MakeWedge(OCC.Core.BRepBuilderAPI.BRepBuilderAPI_MakeShape):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Make a STEP right angular wedge. (ltx >= 0)
        	:param dx:
        	:type dx: float
        	:param dy:
        	:type dy: float
        	:param dz:
        	:type dz: float
        	:param ltx:
        	:type ltx: float
        	:rtype: None* Make a STEP right angular wedge. (ltx >= 0)
        	:param Axes:
        	:type Axes: gp_Ax2
        	:param dx:
        	:type dx: float
        	:param dy:
        	:type dy: float
        	:param dz:
        	:type dz: float
        	:param ltx:
        	:type ltx: float
        	:rtype: None* Make a wedge. The face at dy is xmin,zmin xmax,zmax
        	:param dx:
        	:type dx: float
        	:param dy:
        	:type dy: float
        	:param dz:
        	:type dz: float
        	:param xmin:
        	:type xmin: float
        	:param zmin:
        	:type zmin: float
        	:param xmax:
        	:type xmax: float
        	:param zmax:
        	:type zmax: float
        	:rtype: None* Make a wedge. The face at dy is xmin,zmin xmax,zmax
        	:param Axes:
        	:type Axes: gp_Ax2
        	:param dx:
        	:type dx: float
        	:param dy:
        	:type dy: float
        	:param dz:
        	:type dz: float
        	:param xmin:
        	:type xmin: float
        	:param zmin:
        	:type zmin: float
        	:param xmax:
        	:type xmax: float
        	:param zmax:
        	:type zmax: float
        	:rtype: None
        """
        _BRepPrimAPI.BRepPrimAPI_MakeWedge_swiginit(self, _BRepPrimAPI.new_BRepPrimAPI_MakeWedge(*args))
    Shell = _swig_new_instance_method(_BRepPrimAPI.BRepPrimAPI_MakeWedge_Shell)
    Solid = _swig_new_instance_method(_BRepPrimAPI.BRepPrimAPI_MakeWedge_Solid)
    Wedge = _swig_new_instance_method(_BRepPrimAPI.BRepPrimAPI_MakeWedge_Wedge)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepPrimAPI.delete_BRepPrimAPI_MakeWedge

# Register BRepPrimAPI_MakeWedge in _BRepPrimAPI:
_BRepPrimAPI.BRepPrimAPI_MakeWedge_swigregister(BRepPrimAPI_MakeWedge)

class BRepPrimAPI_MakeCone(BRepPrimAPI_MakeOneAxis):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Make a cone of height H radius R1 in the plane z = 0, R2 in the plane Z = H. R1 and R2 may be null.
        	:param R1:
        	:type R1: float
        	:param R2:
        	:type R2: float
        	:param H:
        	:type H: float
        	:rtype: None* Make a cone of height H radius R1 in the plane z = 0, R2 in the plane Z = H. R1 and R2 may be null. Take a section of <angle>
        	:param R1:
        	:type R1: float
        	:param R2:
        	:type R2: float
        	:param H:
        	:type H: float
        	:param angle:
        	:type angle: float
        	:rtype: None* Make a cone of height H radius R1 in the plane z = 0, R2 in the plane Z = H. R1 and R2 may be null.
        	:param Axes:
        	:type Axes: gp_Ax2
        	:param R1:
        	:type R1: float
        	:param R2:
        	:type R2: float
        	:param H:
        	:type H: float
        	:rtype: None* Make a cone of height H radius R1 in the plane z = 0, R2 in the plane Z = H. R1 and R2 may be null. Take a section of <angle> Constructs a cone, or a portion of a cone, of height H, and radius R1 in the plane z = 0 and R2 in the plane z = H. The result is a sharp cone if R1 or R2 is equal to 0. The cone is constructed about the 'Z Axis' of either: - the global coordinate system, or - the local coordinate system Axes. It is limited in these coordinate systems as follows: - in the v parametric direction (the Z coordinate), by the two parameter values 0 and H, - and in the u parametric direction (defined by the angle of rotation around the Z axis), in the case of a portion of a cone, by the two parameter values 0 and angle. Angle is given in radians. The resulting shape is composed of: - a lateral conical face - two planar faces in the planes z = 0 and z = H, or only one planar face in one of these two planes if a radius value is null (in the case of a complete cone, these faces are circles), and - and in the case of a portion of a cone, two planar faces to close the shape. (either two parallelograms or two triangles, in the planes u = 0 and u = angle). Exceptions Standard_DomainError if: - H is less than or equal to Precision::Confusion(), or - the half-angle at the apex of the cone, defined by R1, R2 and H, is less than Precision::Confusion()/H, or greater than (Pi/2)-Precision::Confusion()/H.f
        	:param Axes:
        	:type Axes: gp_Ax2
        	:param R1:
        	:type R1: float
        	:param R2:
        	:type R2: float
        	:param H:
        	:type H: float
        	:param angle:
        	:type angle: float
        	:rtype: None
        """
        _BRepPrimAPI.BRepPrimAPI_MakeCone_swiginit(self, _BRepPrimAPI.new_BRepPrimAPI_MakeCone(*args))
    Cone = _swig_new_instance_method(_BRepPrimAPI.BRepPrimAPI_MakeCone_Cone)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepPrimAPI.delete_BRepPrimAPI_MakeCone

# Register BRepPrimAPI_MakeCone in _BRepPrimAPI:
_BRepPrimAPI.BRepPrimAPI_MakeCone_swigregister(BRepPrimAPI_MakeCone)

class BRepPrimAPI_MakeCylinder(BRepPrimAPI_MakeOneAxis):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Make a cylinder of radius R and length H.
        	:param R:
        	:type R: float
        	:param H:
        	:type H: float
        	:rtype: None* Make a cylinder of radius R and length H with angle H.
        	:param R:
        	:type R: float
        	:param H:
        	:type H: float
        	:param Angle:
        	:type Angle: float
        	:rtype: None* Make a cylinder of radius R and length H.
        	:param Axes:
        	:type Axes: gp_Ax2
        	:param R:
        	:type R: float
        	:param H:
        	:type H: float
        	:rtype: None* Make a cylinder of radius R and length H with angle H. Constructs - a cylinder of radius R and height H, or - a portion of cylinder of radius R and height H, and of the angle Angle defining the missing portion of the cylinder. The cylinder is constructed about the 'Z Axis' of either: - the global coordinate system, or - the local coordinate system Axes. It is limited in this coordinate system as follows: - in the v parametric direction (the Z axis), by the two parameter values 0 and H, - and in the u parametric direction (the rotation angle around the Z Axis), in the case of a portion of a cylinder, by the two parameter values 0 and Angle. Angle is given in radians. The resulting shape is composed of: - a lateral cylindrical face, - two planar faces in the planes z = 0 and z = H (in the case of a complete cylinder, these faces are circles), and - in case of a portion of a cylinder, two additional planar faces to close the shape.(two rectangles in the planes u = 0 and u = Angle). Exceptions Standard_DomainError if: - R is less than or equal to Precision::Confusion(), or - H is less than or equal to Precision::Confusion().
        	:param Axes:
        	:type Axes: gp_Ax2
        	:param R:
        	:type R: float
        	:param H:
        	:type H: float
        	:param Angle:
        	:type Angle: float
        	:rtype: None
        """
        _BRepPrimAPI.BRepPrimAPI_MakeCylinder_swiginit(self, _BRepPrimAPI.new_BRepPrimAPI_MakeCylinder(*args))
    Cylinder = _swig_new_instance_method(_BRepPrimAPI.BRepPrimAPI_MakeCylinder_Cylinder)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepPrimAPI.delete_BRepPrimAPI_MakeCylinder

# Register BRepPrimAPI_MakeCylinder in _BRepPrimAPI:
_BRepPrimAPI.BRepPrimAPI_MakeCylinder_swigregister(BRepPrimAPI_MakeCylinder)

class BRepPrimAPI_MakePrism(BRepPrimAPI_MakeSweep):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Builds the prism of base S and vector V. If C is true, S is copied. If Canonize is true then generated surfaces are attempted to be canonized in simple types
        	:param S:
        	:type S: TopoDS_Shape
        	:param V:
        	:type V: gp_Vec
        	:param Copy: default value is Standard_False
        	:type Copy: bool
        	:param Canonize: default value is Standard_True
        	:type Canonize: bool
        	:rtype: None* Builds a semi-infinite or an infinite prism of base S. If Inf is true the prism is infinite, if Inf is false the prism is semi-infinite (in the direction D). If C is true S is copied (for semi-infinite prisms). If Canonize is true then generated surfaces are attempted to be canonized in simple types
        	:param S:
        	:type S: TopoDS_Shape
        	:param D:
        	:type D: gp_Dir
        	:param Inf: default value is Standard_True
        	:type Inf: bool
        	:param Copy: default value is Standard_False
        	:type Copy: bool
        	:param Canonize: default value is Standard_True
        	:type Canonize: bool
        	:rtype: None
        """
        _BRepPrimAPI.BRepPrimAPI_MakePrism_swiginit(self, _BRepPrimAPI.new_BRepPrimAPI_MakePrism(*args))
    FirstShape = _swig_new_instance_method(_BRepPrimAPI.BRepPrimAPI_MakePrism_FirstShape)
    LastShape = _swig_new_instance_method(_BRepPrimAPI.BRepPrimAPI_MakePrism_LastShape)
    Prism = _swig_new_instance_method(_BRepPrimAPI.BRepPrimAPI_MakePrism_Prism)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepPrimAPI.delete_BRepPrimAPI_MakePrism

# Register BRepPrimAPI_MakePrism in _BRepPrimAPI:
_BRepPrimAPI.BRepPrimAPI_MakePrism_swigregister(BRepPrimAPI_MakePrism)

class BRepPrimAPI_MakeRevol(BRepPrimAPI_MakeSweep):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Builds the Revol of base S, axis A and angle D. If C is true, S is copied.
        	:param S:
        	:type S: TopoDS_Shape
        	:param A:
        	:type A: gp_Ax1
        	:param D:
        	:type D: float
        	:param Copy: default value is Standard_False
        	:type Copy: bool
        	:rtype: None* Builds the Revol of base S, axis A and angle 2*Pi. If C is true, S is copied.
        	:param S:
        	:type S: TopoDS_Shape
        	:param A:
        	:type A: gp_Ax1
        	:param Copy: default value is Standard_False
        	:type Copy: bool
        	:rtype: None
        """
        _BRepPrimAPI.BRepPrimAPI_MakeRevol_swiginit(self, _BRepPrimAPI.new_BRepPrimAPI_MakeRevol(*args))
    Degenerated = _swig_new_instance_method(_BRepPrimAPI.BRepPrimAPI_MakeRevol_Degenerated)
    FirstShape = _swig_new_instance_method(_BRepPrimAPI.BRepPrimAPI_MakeRevol_FirstShape)
    HasDegenerated = _swig_new_instance_method(_BRepPrimAPI.BRepPrimAPI_MakeRevol_HasDegenerated)
    LastShape = _swig_new_instance_method(_BRepPrimAPI.BRepPrimAPI_MakeRevol_LastShape)
    Revol = _swig_new_instance_method(_BRepPrimAPI.BRepPrimAPI_MakeRevol_Revol)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepPrimAPI.delete_BRepPrimAPI_MakeRevol

# Register BRepPrimAPI_MakeRevol in _BRepPrimAPI:
_BRepPrimAPI.BRepPrimAPI_MakeRevol_swigregister(BRepPrimAPI_MakeRevol)

class BRepPrimAPI_MakeRevolution(BRepPrimAPI_MakeOneAxis):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Make a revolution body by rotating a curve around Z.
        	:param Meridian:
        	:type Meridian: Geom_Curve
        	:rtype: None* Make a revolution body by rotating a curve around Z.
        	:param Meridian:
        	:type Meridian: Geom_Curve
        	:param angle:
        	:type angle: float
        	:rtype: None* Make a revolution body by rotating a curve around Z.
        	:param Meridian:
        	:type Meridian: Geom_Curve
        	:param VMin:
        	:type VMin: float
        	:param VMax:
        	:type VMax: float
        	:rtype: None* Make a revolution body by rotating a curve around Z.
        	:param Meridian:
        	:type Meridian: Geom_Curve
        	:param VMin:
        	:type VMin: float
        	:param VMax:
        	:type VMax: float
        	:param angle:
        	:type angle: float
        	:rtype: None* Make a revolution body by rotating a curve around Z.
        	:param Axes:
        	:type Axes: gp_Ax2
        	:param Meridian:
        	:type Meridian: Geom_Curve
        	:rtype: None* Make a revolution body by rotating a curve around Z.
        	:param Axes:
        	:type Axes: gp_Ax2
        	:param Meridian:
        	:type Meridian: Geom_Curve
        	:param angle:
        	:type angle: float
        	:rtype: None* Make a revolution body by rotating a curve around Z.
        	:param Axes:
        	:type Axes: gp_Ax2
        	:param Meridian:
        	:type Meridian: Geom_Curve
        	:param VMin:
        	:type VMin: float
        	:param VMax:
        	:type VMax: float
        	:rtype: None* Make a revolution body by rotating a curve around Z. For all algorithms the resulting shape is composed of - a lateral revolved face, - two planar faces in planes parallel to the plane z = 0, and passing by the extremities of the revolved portion of Meridian, if these points are not on the Z axis (in case of a complete revolved shape, these faces are circles), - and in the case of a portion of a revolved shape, two planar faces to close the shape (in the planes u = 0 and u = angle).
        	:param Axes:
        	:type Axes: gp_Ax2
        	:param Meridian:
        	:type Meridian: Geom_Curve
        	:param VMin:
        	:type VMin: float
        	:param VMax:
        	:type VMax: float
        	:param angle:
        	:type angle: float
        	:rtype: None
        """
        _BRepPrimAPI.BRepPrimAPI_MakeRevolution_swiginit(self, _BRepPrimAPI.new_BRepPrimAPI_MakeRevolution(*args))
    Revolution = _swig_new_instance_method(_BRepPrimAPI.BRepPrimAPI_MakeRevolution_Revolution)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepPrimAPI.delete_BRepPrimAPI_MakeRevolution

# Register BRepPrimAPI_MakeRevolution in _BRepPrimAPI:
_BRepPrimAPI.BRepPrimAPI_MakeRevolution_swigregister(BRepPrimAPI_MakeRevolution)

class BRepPrimAPI_MakeSphere(BRepPrimAPI_MakeOneAxis):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Make a sphere of radius R.
        	:param R:
        	:type R: float
        	:rtype: None* Make a sphere of radius R.
        	:param R:
        	:type R: float
        	:param angle:
        	:type angle: float
        	:rtype: None* Make a sphere of radius R.
        	:param R:
        	:type R: float
        	:param angle1:
        	:type angle1: float
        	:param angle2:
        	:type angle2: float
        	:rtype: None* Make a sphere of radius R.
        	:param R:
        	:type R: float
        	:param angle1:
        	:type angle1: float
        	:param angle2:
        	:type angle2: float
        	:param angle3:
        	:type angle3: float
        	:rtype: None* Make a sphere of radius R.
        	:param Center:
        	:type Center: gp_Pnt
        	:param R:
        	:type R: float
        	:rtype: None* Make a sphere of radius R.
        	:param Center:
        	:type Center: gp_Pnt
        	:param R:
        	:type R: float
        	:param angle:
        	:type angle: float
        	:rtype: None* Make a sphere of radius R.
        	:param Center:
        	:type Center: gp_Pnt
        	:param R:
        	:type R: float
        	:param angle1:
        	:type angle1: float
        	:param angle2:
        	:type angle2: float
        	:rtype: None* Make a sphere of radius R.
        	:param Center:
        	:type Center: gp_Pnt
        	:param R:
        	:type R: float
        	:param angle1:
        	:type angle1: float
        	:param angle2:
        	:type angle2: float
        	:param angle3:
        	:type angle3: float
        	:rtype: None* Make a sphere of radius R.
        	:param Axis:
        	:type Axis: gp_Ax2
        	:param R:
        	:type R: float
        	:rtype: None* Make a sphere of radius R.
        	:param Axis:
        	:type Axis: gp_Ax2
        	:param R:
        	:type R: float
        	:param angle:
        	:type angle: float
        	:rtype: None* Make a sphere of radius R.
        	:param Axis:
        	:type Axis: gp_Ax2
        	:param R:
        	:type R: float
        	:param angle1:
        	:type angle1: float
        	:param angle2:
        	:type angle2: float
        	:rtype: None* Make a sphere of radius R. For all algorithms The resulting shape is composed of - a lateral spherical face, - two planar faces parallel to the plane z = 0 if the sphere is truncated in the v parametric direction, or only one planar face if angle1 is equal to -p/2 or if angle2 is equal to p/2 (these faces are circles in case of a complete truncated sphere), - and in case of a portion of sphere, two planar faces to shut the shape.(in the planes u = 0 and u = angle).
        	:param Axis:
        	:type Axis: gp_Ax2
        	:param R:
        	:type R: float
        	:param angle1:
        	:type angle1: float
        	:param angle2:
        	:type angle2: float
        	:param angle3:
        	:type angle3: float
        	:rtype: None
        """
        _BRepPrimAPI.BRepPrimAPI_MakeSphere_swiginit(self, _BRepPrimAPI.new_BRepPrimAPI_MakeSphere(*args))
    Sphere = _swig_new_instance_method(_BRepPrimAPI.BRepPrimAPI_MakeSphere_Sphere)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepPrimAPI.delete_BRepPrimAPI_MakeSphere

# Register BRepPrimAPI_MakeSphere in _BRepPrimAPI:
_BRepPrimAPI.BRepPrimAPI_MakeSphere_swigregister(BRepPrimAPI_MakeSphere)

class BRepPrimAPI_MakeTorus(BRepPrimAPI_MakeOneAxis):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Make a torus of radii R1 R2.
        	:param R1:
        	:type R1: float
        	:param R2:
        	:type R2: float
        	:rtype: None* Make a section of a torus of radii R1 R2.
        	:param R1:
        	:type R1: float
        	:param R2:
        	:type R2: float
        	:param angle:
        	:type angle: float
        	:rtype: None* Make a torus of radii R2, R2 with angles on the small circle.
        	:param R1:
        	:type R1: float
        	:param R2:
        	:type R2: float
        	:param angle1:
        	:type angle1: float
        	:param angle2:
        	:type angle2: float
        	:rtype: None* Make a torus of radii R2, R2 with angles on the small circle.
        	:param R1:
        	:type R1: float
        	:param R2:
        	:type R2: float
        	:param angle1:
        	:type angle1: float
        	:param angle2:
        	:type angle2: float
        	:param angle:
        	:type angle: float
        	:rtype: None* Make a torus of radii R1 R2.
        	:param Axes:
        	:type Axes: gp_Ax2
        	:param R1:
        	:type R1: float
        	:param R2:
        	:type R2: float
        	:rtype: None* Make a section of a torus of radii R1 R2.
        	:param Axes:
        	:type Axes: gp_Ax2
        	:param R1:
        	:type R1: float
        	:param R2:
        	:type R2: float
        	:param angle:
        	:type angle: float
        	:rtype: None* Make a torus of radii R1 R2.
        	:param Axes:
        	:type Axes: gp_Ax2
        	:param R1:
        	:type R1: float
        	:param R2:
        	:type R2: float
        	:param angle1:
        	:type angle1: float
        	:param angle2:
        	:type angle2: float
        	:rtype: None* Make a section of a torus of radii R1 R2. For all algorithms The resulting shape is composed of - a lateral toroidal face, - two conical faces (defined by the equation v = angle1 and v = angle2) if the sphere is truncated in the v parametric direction (they may be cylindrical faces in some particular conditions), and in case of a portion of torus, two planar faces to close the shape.(in the planes u = 0 and u = angle). Notes: - The u parameter corresponds to a rotation angle around the Z axis. - The circle whose radius is equal to the minor radius, located in the plane defined by the X axis and the Z axis, centered on the X axis, on its positive side, and positioned at a distance from the origin equal to the major radius, is the reference circle of the torus. The rotation around an axis parallel to the Y axis and passing through the center of the reference circle gives the v parameter on the reference circle. The X axis gives the origin of the v parameter. Near 0, as v increases, the Z coordinate decreases.
        	:param Axes:
        	:type Axes: gp_Ax2
        	:param R1:
        	:type R1: float
        	:param R2:
        	:type R2: float
        	:param angle1:
        	:type angle1: float
        	:param angle2:
        	:type angle2: float
        	:param angle:
        	:type angle: float
        	:rtype: None
        """
        _BRepPrimAPI.BRepPrimAPI_MakeTorus_swiginit(self, _BRepPrimAPI.new_BRepPrimAPI_MakeTorus(*args))
    Torus = _swig_new_instance_method(_BRepPrimAPI.BRepPrimAPI_MakeTorus_Torus)

    __repr__ = _dumps_object

    __swig_destroy__ = _BRepPrimAPI.delete_BRepPrimAPI_MakeTorus

# Register BRepPrimAPI_MakeTorus in _BRepPrimAPI:
_BRepPrimAPI.BRepPrimAPI_MakeTorus_swigregister(BRepPrimAPI_MakeTorus)



