# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
GeomAPI module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_geomapi.html
"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _GeomAPI
else:
    import _GeomAPI

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _GeomAPI.SWIG_PyInstanceMethod_New
_swig_new_static_method = _GeomAPI.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _GeomAPI.delete_SwigPyIterator
    value = _swig_new_instance_method(_GeomAPI.SwigPyIterator_value)
    incr = _swig_new_instance_method(_GeomAPI.SwigPyIterator_incr)
    decr = _swig_new_instance_method(_GeomAPI.SwigPyIterator_decr)
    distance = _swig_new_instance_method(_GeomAPI.SwigPyIterator_distance)
    equal = _swig_new_instance_method(_GeomAPI.SwigPyIterator_equal)
    copy = _swig_new_instance_method(_GeomAPI.SwigPyIterator_copy)
    next = _swig_new_instance_method(_GeomAPI.SwigPyIterator_next)
    __next__ = _swig_new_instance_method(_GeomAPI.SwigPyIterator___next__)
    previous = _swig_new_instance_method(_GeomAPI.SwigPyIterator_previous)
    advance = _swig_new_instance_method(_GeomAPI.SwigPyIterator_advance)
    __eq__ = _swig_new_instance_method(_GeomAPI.SwigPyIterator___eq__)
    __ne__ = _swig_new_instance_method(_GeomAPI.SwigPyIterator___ne__)
    __iadd__ = _swig_new_instance_method(_GeomAPI.SwigPyIterator___iadd__)
    __isub__ = _swig_new_instance_method(_GeomAPI.SwigPyIterator___isub__)
    __add__ = _swig_new_instance_method(_GeomAPI.SwigPyIterator___add__)
    __sub__ = _swig_new_instance_method(_GeomAPI.SwigPyIterator___sub__)
    def __iter__(self):
        return self

# Register SwigPyIterator in _GeomAPI:
_GeomAPI.SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.Geom
import OCC.Core.gp
import OCC.Core.GeomAbs
import OCC.Core.TColgp
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.Geom2d
import OCC.Core.Extrema
import OCC.Core.math
import OCC.Core.Message
import OCC.Core.Adaptor3d
import OCC.Core.TopAbs
import OCC.Core.Adaptor2d
import OCC.Core.GeomAdaptor
import OCC.Core.Approx
import OCC.Core.AppCont
import OCC.Core.AppParCurves
class geomapi(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    To2d = _swig_new_static_method(_GeomAPI.geomapi_To2d)
    To3d = _swig_new_static_method(_GeomAPI.geomapi_To3d)

    __repr__ = _dumps_object


    def __init__(self):
        _GeomAPI.geomapi_swiginit(self, _GeomAPI.new_geomapi())
    __swig_destroy__ = _GeomAPI.delete_geomapi

# Register geomapi in _GeomAPI:
_GeomAPI.geomapi_swigregister(geomapi)
geomapi_To2d = _GeomAPI.geomapi_To2d
geomapi_To3d = _GeomAPI.geomapi_To3d

class GeomAPI_ExtremaCurveCurve(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Distance = _swig_new_instance_method(_GeomAPI.GeomAPI_ExtremaCurveCurve_Distance)
    Extrema = _swig_new_instance_method(_GeomAPI.GeomAPI_ExtremaCurveCurve_Extrema)

    def __init__(self, *args):
        r"""
        * Constructs an empty algorithm for computing extrema between two curves. Use an Init function to define the curves on which it is going to work.
        	:rtype: None* Computes the extrema between the curves C1 and C2.
        	:param C1:
        	:type C1: Geom_Curve
        	:param C2:
        	:type C2: Geom_Curve
        	:rtype: None* Computes the portion of the curve C1 limited by the two points of parameter (U1min,U1max), and - the portion of the curve C2 limited by the two points of parameter (U2min,U2max). Warning Use the function NbExtrema to obtain the number of solutions. If this algorithm fails, NbExtrema returns 0.
        	:param C1:
        	:type C1: Geom_Curve
        	:param C2:
        	:type C2: Geom_Curve
        	:param U1min:
        	:type U1min: float
        	:param U1max:
        	:type U1max: float
        	:param U2min:
        	:type U2min: float
        	:param U2max:
        	:type U2max: float
        	:rtype: None
        """
        _GeomAPI.GeomAPI_ExtremaCurveCurve_swiginit(self, _GeomAPI.new_GeomAPI_ExtremaCurveCurve(*args))
    Init = _swig_new_instance_method(_GeomAPI.GeomAPI_ExtremaCurveCurve_Init)
    LowerDistance = _swig_new_instance_method(_GeomAPI.GeomAPI_ExtremaCurveCurve_LowerDistance)
    LowerDistanceParameters = _swig_new_instance_method(_GeomAPI.GeomAPI_ExtremaCurveCurve_LowerDistanceParameters)
    NbExtrema = _swig_new_instance_method(_GeomAPI.GeomAPI_ExtremaCurveCurve_NbExtrema)
    NearestPoints = _swig_new_instance_method(_GeomAPI.GeomAPI_ExtremaCurveCurve_NearestPoints)
    Parameters = _swig_new_instance_method(_GeomAPI.GeomAPI_ExtremaCurveCurve_Parameters)
    Points = _swig_new_instance_method(_GeomAPI.GeomAPI_ExtremaCurveCurve_Points)
    TotalLowerDistance = _swig_new_instance_method(_GeomAPI.GeomAPI_ExtremaCurveCurve_TotalLowerDistance)
    TotalLowerDistanceParameters = _swig_new_instance_method(_GeomAPI.GeomAPI_ExtremaCurveCurve_TotalLowerDistanceParameters)
    TotalNearestPoints = _swig_new_instance_method(_GeomAPI.GeomAPI_ExtremaCurveCurve_TotalNearestPoints)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomAPI.delete_GeomAPI_ExtremaCurveCurve

# Register GeomAPI_ExtremaCurveCurve in _GeomAPI:
_GeomAPI.GeomAPI_ExtremaCurveCurve_swigregister(GeomAPI_ExtremaCurveCurve)

class GeomAPI_ExtremaCurveSurface(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Distance = _swig_new_instance_method(_GeomAPI.GeomAPI_ExtremaCurveSurface_Distance)
    Extrema = _swig_new_instance_method(_GeomAPI.GeomAPI_ExtremaCurveSurface_Extrema)

    def __init__(self, *args):
        r"""
        * Constructs an empty algorithm for computing extrema between a curve and a surface. Use an Init function to define the curve and the surface on which it is going to work.
        	:rtype: None* Computes the extrema distances between the curve <C> and the surface <S>.
        	:param Curve:
        	:type Curve: Geom_Curve
        	:param Surface:
        	:type Surface: Geom_Surface
        	:rtype: None* Computes the extrema distances between the curve <C> and the surface <S>. The solution point are computed in the domain [Wmin,Wmax] of the curve and in the domain [Umin,Umax] [Vmin,Vmax] of the surface. Warning Use the function NbExtrema to obtain the number of solutions. If this algorithm fails, NbExtrema returns 0.
        	:param Curve:
        	:type Curve: Geom_Curve
        	:param Surface:
        	:type Surface: Geom_Surface
        	:param Wmin:
        	:type Wmin: float
        	:param Wmax:
        	:type Wmax: float
        	:param Umin:
        	:type Umin: float
        	:param Umax:
        	:type Umax: float
        	:param Vmin:
        	:type Vmin: float
        	:param Vmax:
        	:type Vmax: float
        	:rtype: None
        """
        _GeomAPI.GeomAPI_ExtremaCurveSurface_swiginit(self, _GeomAPI.new_GeomAPI_ExtremaCurveSurface(*args))
    Init = _swig_new_instance_method(_GeomAPI.GeomAPI_ExtremaCurveSurface_Init)
    LowerDistance = _swig_new_instance_method(_GeomAPI.GeomAPI_ExtremaCurveSurface_LowerDistance)
    LowerDistanceParameters = _swig_new_instance_method(_GeomAPI.GeomAPI_ExtremaCurveSurface_LowerDistanceParameters)
    NbExtrema = _swig_new_instance_method(_GeomAPI.GeomAPI_ExtremaCurveSurface_NbExtrema)
    NearestPoints = _swig_new_instance_method(_GeomAPI.GeomAPI_ExtremaCurveSurface_NearestPoints)
    Parameters = _swig_new_instance_method(_GeomAPI.GeomAPI_ExtremaCurveSurface_Parameters)
    Points = _swig_new_instance_method(_GeomAPI.GeomAPI_ExtremaCurveSurface_Points)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomAPI.delete_GeomAPI_ExtremaCurveSurface

# Register GeomAPI_ExtremaCurveSurface in _GeomAPI:
_GeomAPI.GeomAPI_ExtremaCurveSurface_swigregister(GeomAPI_ExtremaCurveSurface)

class GeomAPI_ExtremaSurfaceSurface(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Distance = _swig_new_instance_method(_GeomAPI.GeomAPI_ExtremaSurfaceSurface_Distance)
    Extrema = _swig_new_instance_method(_GeomAPI.GeomAPI_ExtremaSurfaceSurface_Extrema)

    def __init__(self, *args):
        r"""
        * Constructs an empty algorithm for computing extrema between two surfaces. Use an Init function to define the surfaces on which it is going to work.
        	:rtype: None* Computes the extrema distances between the surfaces <S1> and <S2>
        	:param S1:
        	:type S1: Geom_Surface
        	:param S2:
        	:type S2: Geom_Surface
        	:rtype: None* Computes the extrema distances between the portion of the surface S1 limited by the two values of parameter (U1min,U1max) in the u parametric direction, and by the two values of parameter (V1min,V1max) in the v parametric direction, and - the portion of the surface S2 limited by the two values of parameter (U2min,U2max) in the u parametric direction, and by the two values of parameter (V2min,V2max) in the v parametric direction.
        	:param S1:
        	:type S1: Geom_Surface
        	:param S2:
        	:type S2: Geom_Surface
        	:param U1min:
        	:type U1min: float
        	:param U1max:
        	:type U1max: float
        	:param V1min:
        	:type V1min: float
        	:param V1max:
        	:type V1max: float
        	:param U2min:
        	:type U2min: float
        	:param U2max:
        	:type U2max: float
        	:param V2min:
        	:type V2min: float
        	:param V2max:
        	:type V2max: float
        	:rtype: None
        """
        _GeomAPI.GeomAPI_ExtremaSurfaceSurface_swiginit(self, _GeomAPI.new_GeomAPI_ExtremaSurfaceSurface(*args))
    Init = _swig_new_instance_method(_GeomAPI.GeomAPI_ExtremaSurfaceSurface_Init)
    LowerDistance = _swig_new_instance_method(_GeomAPI.GeomAPI_ExtremaSurfaceSurface_LowerDistance)
    LowerDistanceParameters = _swig_new_instance_method(_GeomAPI.GeomAPI_ExtremaSurfaceSurface_LowerDistanceParameters)
    NbExtrema = _swig_new_instance_method(_GeomAPI.GeomAPI_ExtremaSurfaceSurface_NbExtrema)
    NearestPoints = _swig_new_instance_method(_GeomAPI.GeomAPI_ExtremaSurfaceSurface_NearestPoints)
    Parameters = _swig_new_instance_method(_GeomAPI.GeomAPI_ExtremaSurfaceSurface_Parameters)
    Points = _swig_new_instance_method(_GeomAPI.GeomAPI_ExtremaSurfaceSurface_Points)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomAPI.delete_GeomAPI_ExtremaSurfaceSurface

# Register GeomAPI_ExtremaSurfaceSurface in _GeomAPI:
_GeomAPI.GeomAPI_ExtremaSurfaceSurface_swigregister(GeomAPI_ExtremaSurfaceSurface)

class GeomAPI_IntCS(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Creates an empty object. Use the function Perform for further initialization of the algorithm by the curve and the surface.
        	:rtype: None* Computes the intersections between the curve C and the surface S. Warning Use function IsDone to verify that the intersections are computed successfully.
        	:param C:
        	:type C: Geom_Curve
        	:param S:
        	:type S: Geom_Surface
        	:rtype: None
        """
        _GeomAPI.GeomAPI_IntCS_swiginit(self, _GeomAPI.new_GeomAPI_IntCS(*args))
    IsDone = _swig_new_instance_method(_GeomAPI.GeomAPI_IntCS_IsDone)
    NbPoints = _swig_new_instance_method(_GeomAPI.GeomAPI_IntCS_NbPoints)
    NbSegments = _swig_new_instance_method(_GeomAPI.GeomAPI_IntCS_NbSegments)
    Parameters = _swig_new_instance_method(_GeomAPI.GeomAPI_IntCS_Parameters)
    Perform = _swig_new_instance_method(_GeomAPI.GeomAPI_IntCS_Perform)
    Point = _swig_new_instance_method(_GeomAPI.GeomAPI_IntCS_Point)
    Segment = _swig_new_instance_method(_GeomAPI.GeomAPI_IntCS_Segment)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomAPI.delete_GeomAPI_IntCS

# Register GeomAPI_IntCS in _GeomAPI:
_GeomAPI.GeomAPI_IntCS_swigregister(GeomAPI_IntCS)

class GeomAPI_IntSS(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Constructs an empty object. Use the function Perform for further initialization algorithm by two surfaces.
        	:rtype: None* Computes the intersection curves between the two surfaces S1 and S2. Parameter Tol defines the precision of curves computation. For most cases the value 1.0e-7 is recommended to use. Warning Use the function IsDone to verify that the intersections are successfully computed.I
        	:param S1:
        	:type S1: Geom_Surface
        	:param S2:
        	:type S2: Geom_Surface
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        _GeomAPI.GeomAPI_IntSS_swiginit(self, _GeomAPI.new_GeomAPI_IntSS(*args))
    IsDone = _swig_new_instance_method(_GeomAPI.GeomAPI_IntSS_IsDone)
    Line = _swig_new_instance_method(_GeomAPI.GeomAPI_IntSS_Line)
    NbLines = _swig_new_instance_method(_GeomAPI.GeomAPI_IntSS_NbLines)
    Perform = _swig_new_instance_method(_GeomAPI.GeomAPI_IntSS_Perform)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomAPI.delete_GeomAPI_IntSS

# Register GeomAPI_IntSS in _GeomAPI:
_GeomAPI.GeomAPI_IntSS_swigregister(GeomAPI_IntSS)

class GeomAPI_Interpolate(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Curve = _swig_new_instance_method(_GeomAPI.GeomAPI_Interpolate_Curve)

    def __init__(self, *args):
        r"""
        * Initializes an algorithm for constructing a constrained BSpline curve passing through the points of the table Points. Tangential vectors can then be assigned, using the function Load. If PeriodicFlag is true, the constrained BSpline curve will be periodic and closed. In this case, the junction point is the first point of the table Points. The tolerance value Tolerance is used to check that: - points are not too close to each other, or - tangential vectors (defined using the function Load) are not too small. The resulting BSpline curve will be 'C2' continuous, except where a tangency constraint is defined on a point through which the curve passes (by using the Load function). In this case, it will be only 'C1' continuous. Once all the constraints are defined, use the function Perform to compute the curve. Warning - There must be at least 2 points in the table Points. - If PeriodicFlag is false, there must be as many parameters in the array Parameters as there are points in the array Points. - If PeriodicFlag is true, there must be one more parameter in the table Parameters: this is used to give the parameter on the resulting BSpline curve of the junction point of the curve (which is also the first point of the table Points). Exceptions - Standard_ConstructionError if the distance between two consecutive points in the table Points is less than or equal to Tolerance. - Standard_OutOfRange if: - there are less than two points in the table Points, or - conditions relating to the respective number of elements in the parallel tables Points and Parameters are not respected.
        	:param Points:
        	:type Points: TColgp_HArray1OfPnt
        	:param PeriodicFlag:
        	:type PeriodicFlag: bool
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None* Initializes an algorithm for constructing a constrained BSpline curve passing through the points of the table Points, where the parameters of each of its points are given by the parallel table Parameters. Tangential vectors can then be assigned, using the function Load. If PeriodicFlag is true, the constrained BSpline curve will be periodic and closed. In this case, the junction point is the first point of the table Points. The tolerance value Tolerance is used to check that: - points are not too close to each other, or - tangential vectors (defined using the function Load) are not too small. The resulting BSpline curve will be 'C2' continuous, except where a tangency constraint is defined on a point through which the curve passes (by using the Load function). In this case, it will be only 'C1' continuous. Once all the constraints are defined, use the function Perform to compute the curve. Warning - There must be at least 2 points in the table Points. - If PeriodicFlag is false, there must be as many parameters in the array Parameters as there are points in the array Points. - If PeriodicFlag is true, there must be one more parameter in the table Parameters: this is used to give the parameter on the resulting BSpline curve of the junction point of the curve (which is also the first point of the table Points). Exceptions - Standard_ConstructionError if the distance between two consecutive points in the table Points is less than or equal to Tolerance. - Standard_OutOfRange if: - there are less than two points in the table Points, or - conditions relating to the respective number of elements in the parallel tables Points and Parameters are not respected.
        	:param Points:
        	:type Points: TColgp_HArray1OfPnt
        	:param Parameters:
        	:type Parameters: TColStd_HArray1OfReal
        	:param PeriodicFlag:
        	:type PeriodicFlag: bool
        	:param Tolerance:
        	:type Tolerance: float
        	:rtype: None
        """
        _GeomAPI.GeomAPI_Interpolate_swiginit(self, _GeomAPI.new_GeomAPI_Interpolate(*args))
    IsDone = _swig_new_instance_method(_GeomAPI.GeomAPI_Interpolate_IsDone)
    Load = _swig_new_instance_method(_GeomAPI.GeomAPI_Interpolate_Load)
    Perform = _swig_new_instance_method(_GeomAPI.GeomAPI_Interpolate_Perform)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomAPI.delete_GeomAPI_Interpolate

# Register GeomAPI_Interpolate in _GeomAPI:
_GeomAPI.GeomAPI_Interpolate_swigregister(GeomAPI_Interpolate)

class GeomAPI_PointsToBSpline(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Curve = _swig_new_instance_method(_GeomAPI.GeomAPI_PointsToBSpline_Curve)

    def __init__(self, *args):
        r"""
        * Constructs an empty approximation algorithm. Use an Init function to define and build the BSpline curve.
        	:rtype: None* Approximate a BSpline Curve passing through an array of Point. The resulting BSpline will have the following properties: 1- his degree will be in the range [Degmin,Degmax] 2- his continuity will be at least <Continuity> 3- the distance from the point <Points> to the BSpline will be lower to Tol3D
        	:param Points:
        	:type Points: TColgp_Array1OfPnt
        	:param DegMin: default value is 3
        	:type DegMin: int
        	:param DegMax: default value is 8
        	:type DegMax: int
        	:param Continuity: default value is GeomAbs_C2
        	:type Continuity: GeomAbs_Shape
        	:param Tol3D: default value is 1.0e-3
        	:type Tol3D: float
        	:rtype: None* Approximate a BSpline Curve passing through an array of Point. The resulting BSpline will have the following properties: 1- his degree will be in the range [Degmin,Degmax] 2- his continuity will be at least <Continuity> 3- the distance from the point <Points> to the BSpline will be lower to Tol3D
        	:param Points:
        	:type Points: TColgp_Array1OfPnt
        	:param ParType:
        	:type ParType: Approx_ParametrizationType
        	:param DegMin: default value is 3
        	:type DegMin: int
        	:param DegMax: default value is 8
        	:type DegMax: int
        	:param Continuity: default value is GeomAbs_C2
        	:type Continuity: GeomAbs_Shape
        	:param Tol3D: default value is 1.0e-3
        	:type Tol3D: float
        	:rtype: None* Approximate a BSpline Curve passing through an array of Point, which parameters are given by the array <Parameters>. The resulting BSpline will have the following properties: 1- his degree will be in the range [Degmin,Degmax] 2- his continuity will be at least <Continuity> 3- the distance from the point <Points> to the BSpline will be lower to Tol3D
        	:param Points:
        	:type Points: TColgp_Array1OfPnt
        	:param Parameters:
        	:type Parameters: TColStd_Array1OfReal
        	:param DegMin: default value is 3
        	:type DegMin: int
        	:param DegMax: default value is 8
        	:type DegMax: int
        	:param Continuity: default value is GeomAbs_C2
        	:type Continuity: GeomAbs_Shape
        	:param Tol3D: default value is 1.0e-3
        	:type Tol3D: float
        	:rtype: None* Approximate a BSpline Curve passing through an array of Point using variational smoothing algorithm, which tries to minimize additional criterium: Weight1*CurveLength + Weight2*Curvature + Weight3*Torsion
        	:param Points:
        	:type Points: TColgp_Array1OfPnt
        	:param Weight1:
        	:type Weight1: float
        	:param Weight2:
        	:type Weight2: float
        	:param Weight3:
        	:type Weight3: float
        	:param DegMax: default value is 8
        	:type DegMax: int
        	:param Continuity: default value is GeomAbs_C2
        	:type Continuity: GeomAbs_Shape
        	:param Tol3D: default value is 1.0e-3
        	:type Tol3D: float
        	:rtype: None
        """
        _GeomAPI.GeomAPI_PointsToBSpline_swiginit(self, _GeomAPI.new_GeomAPI_PointsToBSpline(*args))
    Init = _swig_new_instance_method(_GeomAPI.GeomAPI_PointsToBSpline_Init)
    IsDone = _swig_new_instance_method(_GeomAPI.GeomAPI_PointsToBSpline_IsDone)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomAPI.delete_GeomAPI_PointsToBSpline

# Register GeomAPI_PointsToBSpline in _GeomAPI:
_GeomAPI.GeomAPI_PointsToBSpline_swigregister(GeomAPI_PointsToBSpline)

class GeomAPI_PointsToBSplineSurface(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        * Constructs an empty algorithm for approximation or interpolation of a surface. Use: - an Init function to define and build the BSpline surface by approximation, or - an Interpolate function to define and build the BSpline surface by interpolation.
        	:rtype: None* Approximates a BSpline Surface passing through an array of Points. The resulting BSpline will have the following properties: 1- his degree will be in the range [Degmin,Degmax] 2- his continuity will be at least <Continuity> 3- the distance from the point <Points> to the BSpline will be lower to Tol3D.
        	:param Points:
        	:type Points: TColgp_Array2OfPnt
        	:param DegMin: default value is 3
        	:type DegMin: int
        	:param DegMax: default value is 8
        	:type DegMax: int
        	:param Continuity: default value is GeomAbs_C2
        	:type Continuity: GeomAbs_Shape
        	:param Tol3D: default value is 1.0e-3
        	:type Tol3D: float
        	:rtype: None* Approximates a BSpline Surface passing through an array of Points. The resulting BSpline will have the following properties: 1- his degree will be in the range [Degmin,Degmax] 2- his continuity will be at least <Continuity> 3- the distance from the point <Points> to the BSpline will be lower to Tol3D.
        	:param Points:
        	:type Points: TColgp_Array2OfPnt
        	:param ParType:
        	:type ParType: Approx_ParametrizationType
        	:param DegMin: default value is 3
        	:type DegMin: int
        	:param DegMax: default value is 8
        	:type DegMax: int
        	:param Continuity: default value is GeomAbs_C2
        	:type Continuity: GeomAbs_Shape
        	:param Tol3D: default value is 1.0e-3
        	:type Tol3D: float
        	:rtype: None* Approximates a BSpline Surface passing through an array of points using variational smoothing algorithm, which tries to minimize additional criterium: Weight1*CurveLength + Weight2*Curvature + Weight3*Torsion.
        	:param Points:
        	:type Points: TColgp_Array2OfPnt
        	:param Weight1:
        	:type Weight1: float
        	:param Weight2:
        	:type Weight2: float
        	:param Weight3:
        	:type Weight3: float
        	:param DegMax: default value is 8
        	:type DegMax: int
        	:param Continuity: default value is GeomAbs_C2
        	:type Continuity: GeomAbs_Shape
        	:param Tol3D: default value is 1.0e-3
        	:type Tol3D: float
        	:rtype: None* Approximates a BSpline Surface passing through an array of Points. //! The points will be constructed as follow: P(i,j) = gp_Pnt( X0 + (i-1)*dX , Y0 + (j-1)*dY , ZPoints(i,j) ) //! The resulting BSpline will have the following properties: 1- his degree will be in the range [Degmin,Degmax] 2- his continuity will be at least <Continuity> 3- the distance from the point <Points> to the BSpline will be lower to Tol3D 4- the parametrization of the surface will verify: S->Value( U, V) = gp_Pnt( U, V, Z(U,V) );
        	:param ZPoints:
        	:type ZPoints: TColStd_Array2OfReal
        	:param X0:
        	:type X0: float
        	:param dX:
        	:type dX: float
        	:param Y0:
        	:type Y0: float
        	:param dY:
        	:type dY: float
        	:param DegMin: default value is 3
        	:type DegMin: int
        	:param DegMax: default value is 8
        	:type DegMax: int
        	:param Continuity: default value is GeomAbs_C2
        	:type Continuity: GeomAbs_Shape
        	:param Tol3D: default value is 1.0e-3
        	:type Tol3D: float
        	:rtype: None
        """
        _GeomAPI.GeomAPI_PointsToBSplineSurface_swiginit(self, _GeomAPI.new_GeomAPI_PointsToBSplineSurface(*args))
    Init = _swig_new_instance_method(_GeomAPI.GeomAPI_PointsToBSplineSurface_Init)
    Interpolate = _swig_new_instance_method(_GeomAPI.GeomAPI_PointsToBSplineSurface_Interpolate)
    IsDone = _swig_new_instance_method(_GeomAPI.GeomAPI_PointsToBSplineSurface_IsDone)
    Surface = _swig_new_instance_method(_GeomAPI.GeomAPI_PointsToBSplineSurface_Surface)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomAPI.delete_GeomAPI_PointsToBSplineSurface

# Register GeomAPI_PointsToBSplineSurface in _GeomAPI:
_GeomAPI.GeomAPI_PointsToBSplineSurface_swigregister(GeomAPI_PointsToBSplineSurface)

class GeomAPI_ProjectPointOnCurve(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Distance = _swig_new_instance_method(_GeomAPI.GeomAPI_ProjectPointOnCurve_Distance)
    Extrema = _swig_new_instance_method(_GeomAPI.GeomAPI_ProjectPointOnCurve_Extrema)

    def __init__(self, *args):
        r"""
        * Creates an empty object. Use an Init function for further initialization.
        	:rtype: None* Create the projection of a point <P> on a curve <Curve>
        	:param P:
        	:type P: gp_Pnt
        	:param Curve:
        	:type Curve: Geom_Curve
        	:rtype: None* Create the projection of a point <P> on a curve <Curve> limited by the two points of parameter Umin and Usup.
        	:param P:
        	:type P: gp_Pnt
        	:param Curve:
        	:type Curve: Geom_Curve
        	:param Umin:
        	:type Umin: float
        	:param Usup:
        	:type Usup: float
        	:rtype: None
        """
        _GeomAPI.GeomAPI_ProjectPointOnCurve_swiginit(self, _GeomAPI.new_GeomAPI_ProjectPointOnCurve(*args))
    Init = _swig_new_instance_method(_GeomAPI.GeomAPI_ProjectPointOnCurve_Init)
    LowerDistance = _swig_new_instance_method(_GeomAPI.GeomAPI_ProjectPointOnCurve_LowerDistance)
    LowerDistanceParameter = _swig_new_instance_method(_GeomAPI.GeomAPI_ProjectPointOnCurve_LowerDistanceParameter)
    NbPoints = _swig_new_instance_method(_GeomAPI.GeomAPI_ProjectPointOnCurve_NbPoints)
    NearestPoint = _swig_new_instance_method(_GeomAPI.GeomAPI_ProjectPointOnCurve_NearestPoint)
    Parameter = _swig_new_instance_method(_GeomAPI.GeomAPI_ProjectPointOnCurve_Parameter)
    Perform = _swig_new_instance_method(_GeomAPI.GeomAPI_ProjectPointOnCurve_Perform)
    Point = _swig_new_instance_method(_GeomAPI.GeomAPI_ProjectPointOnCurve_Point)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomAPI.delete_GeomAPI_ProjectPointOnCurve

# Register GeomAPI_ProjectPointOnCurve in _GeomAPI:
_GeomAPI.GeomAPI_ProjectPointOnCurve_swigregister(GeomAPI_ProjectPointOnCurve)

class GeomAPI_ProjectPointOnSurf(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Distance = _swig_new_instance_method(_GeomAPI.GeomAPI_ProjectPointOnSurf_Distance)
    Extrema = _swig_new_instance_method(_GeomAPI.GeomAPI_ProjectPointOnSurf_Extrema)

    def __init__(self, *args):
        r"""
        * Creates an empty object. Use the Init function for further initialization.
        	:rtype: None* Create the projection of a point <P> on a surface <Surface>
        	:param P:
        	:type P: gp_Pnt
        	:param Surface:
        	:type Surface: Geom_Surface
        	:param Algo: default value is Extrema_ExtAlgo_Grad
        	:type Algo: Extrema_ExtAlgo
        	:rtype: None* Create the projection of a point <P> on a surface <Surface> Create the projection of a point <P> on a surface <Surface>. The solution are computed in the domain [Umin,Usup] [Vmin,Vsup] of the surface.
        	:param P:
        	:type P: gp_Pnt
        	:param Surface:
        	:type Surface: Geom_Surface
        	:param Tolerance:
        	:type Tolerance: float
        	:param Algo: default value is Extrema_ExtAlgo_Grad
        	:type Algo: Extrema_ExtAlgo
        	:rtype: None:param P:
        	:type P: gp_Pnt
        	:param Surface:
        	:type Surface: Geom_Surface
        	:param Umin:
        	:type Umin: float
        	:param Usup:
        	:type Usup: float
        	:param Vmin:
        	:type Vmin: float
        	:param Vsup:
        	:type Vsup: float
        	:param Tolerance:
        	:type Tolerance: float
        	:param Algo: default value is Extrema_ExtAlgo_Grad
        	:type Algo: Extrema_ExtAlgo
        	:rtype: None* Init the projection of a point <P> on a surface <Surface>
        	:param P:
        	:type P: gp_Pnt
        	:param Surface:
        	:type Surface: Geom_Surface
        	:param Umin:
        	:type Umin: float
        	:param Usup:
        	:type Usup: float
        	:param Vmin:
        	:type Vmin: float
        	:param Vsup:
        	:type Vsup: float
        	:param Algo: default value is Extrema_ExtAlgo_Grad
        	:type Algo: Extrema_ExtAlgo
        	:rtype: None
        """
        _GeomAPI.GeomAPI_ProjectPointOnSurf_swiginit(self, _GeomAPI.new_GeomAPI_ProjectPointOnSurf(*args))
    Init = _swig_new_instance_method(_GeomAPI.GeomAPI_ProjectPointOnSurf_Init)
    IsDone = _swig_new_instance_method(_GeomAPI.GeomAPI_ProjectPointOnSurf_IsDone)
    LowerDistance = _swig_new_instance_method(_GeomAPI.GeomAPI_ProjectPointOnSurf_LowerDistance)
    LowerDistanceParameters = _swig_new_instance_method(_GeomAPI.GeomAPI_ProjectPointOnSurf_LowerDistanceParameters)
    NbPoints = _swig_new_instance_method(_GeomAPI.GeomAPI_ProjectPointOnSurf_NbPoints)
    NearestPoint = _swig_new_instance_method(_GeomAPI.GeomAPI_ProjectPointOnSurf_NearestPoint)
    Parameters = _swig_new_instance_method(_GeomAPI.GeomAPI_ProjectPointOnSurf_Parameters)
    Perform = _swig_new_instance_method(_GeomAPI.GeomAPI_ProjectPointOnSurf_Perform)
    Point = _swig_new_instance_method(_GeomAPI.GeomAPI_ProjectPointOnSurf_Point)
    SetExtremaAlgo = _swig_new_instance_method(_GeomAPI.GeomAPI_ProjectPointOnSurf_SetExtremaAlgo)
    SetExtremaFlag = _swig_new_instance_method(_GeomAPI.GeomAPI_ProjectPointOnSurf_SetExtremaFlag)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomAPI.delete_GeomAPI_ProjectPointOnSurf

# Register GeomAPI_ProjectPointOnSurf in _GeomAPI:
_GeomAPI.GeomAPI_ProjectPointOnSurf_swigregister(GeomAPI_ProjectPointOnSurf)



