# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
math module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_math.html
"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _math
else:
    import _math

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _math.SWIG_PyInstanceMethod_New
_swig_new_static_method = _math.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _math.delete_SwigPyIterator
    value = _swig_new_instance_method(_math.SwigPyIterator_value)
    incr = _swig_new_instance_method(_math.SwigPyIterator_incr)
    decr = _swig_new_instance_method(_math.SwigPyIterator_decr)
    distance = _swig_new_instance_method(_math.SwigPyIterator_distance)
    equal = _swig_new_instance_method(_math.SwigPyIterator_equal)
    copy = _swig_new_instance_method(_math.SwigPyIterator_copy)
    next = _swig_new_instance_method(_math.SwigPyIterator_next)
    __next__ = _swig_new_instance_method(_math.SwigPyIterator___next__)
    previous = _swig_new_instance_method(_math.SwigPyIterator_previous)
    advance = _swig_new_instance_method(_math.SwigPyIterator_advance)
    __eq__ = _swig_new_instance_method(_math.SwigPyIterator___eq__)
    __ne__ = _swig_new_instance_method(_math.SwigPyIterator___ne__)
    __iadd__ = _swig_new_instance_method(_math.SwigPyIterator___iadd__)
    __isub__ = _swig_new_instance_method(_math.SwigPyIterator___isub__)
    __add__ = _swig_new_instance_method(_math.SwigPyIterator___add__)
    __sub__ = _swig_new_instance_method(_math.SwigPyIterator___sub__)
    def __iter__(self):
        return self

# Register SwigPyIterator in _math:
_math.SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.Message
import OCC.Core.gp
math_OK = _math.math_OK
math_TooManyIterations = _math.math_TooManyIterations
math_FunctionError = _math.math_FunctionError
math_DirectionSearchError = _math.math_DirectionSearchError
math_NotBracketed = _math.math_NotBracketed
class math_Array1OfValueAndWeight(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    begin = _swig_new_instance_method(_math.math_Array1OfValueAndWeight_begin)
    end = _swig_new_instance_method(_math.math_Array1OfValueAndWeight_end)
    cbegin = _swig_new_instance_method(_math.math_Array1OfValueAndWeight_cbegin)
    cend = _swig_new_instance_method(_math.math_Array1OfValueAndWeight_cend)

    def __init__(self, *args):
        _math.math_Array1OfValueAndWeight_swiginit(self, _math.new_math_Array1OfValueAndWeight(*args))
    Init = _swig_new_instance_method(_math.math_Array1OfValueAndWeight_Init)
    Size = _swig_new_instance_method(_math.math_Array1OfValueAndWeight_Size)
    Length = _swig_new_instance_method(_math.math_Array1OfValueAndWeight_Length)
    IsEmpty = _swig_new_instance_method(_math.math_Array1OfValueAndWeight_IsEmpty)
    Lower = _swig_new_instance_method(_math.math_Array1OfValueAndWeight_Lower)
    Upper = _swig_new_instance_method(_math.math_Array1OfValueAndWeight_Upper)
    IsDeletable = _swig_new_instance_method(_math.math_Array1OfValueAndWeight_IsDeletable)
    IsAllocated = _swig_new_instance_method(_math.math_Array1OfValueAndWeight_IsAllocated)
    Assign = _swig_new_instance_method(_math.math_Array1OfValueAndWeight_Assign)
    Move = _swig_new_instance_method(_math.math_Array1OfValueAndWeight_Move)
    Set = _swig_new_instance_method(_math.math_Array1OfValueAndWeight_Set)
    First = _swig_new_instance_method(_math.math_Array1OfValueAndWeight_First)
    ChangeFirst = _swig_new_instance_method(_math.math_Array1OfValueAndWeight_ChangeFirst)
    Last = _swig_new_instance_method(_math.math_Array1OfValueAndWeight_Last)
    ChangeLast = _swig_new_instance_method(_math.math_Array1OfValueAndWeight_ChangeLast)
    Value = _swig_new_instance_method(_math.math_Array1OfValueAndWeight_Value)
    ChangeValue = _swig_new_instance_method(_math.math_Array1OfValueAndWeight_ChangeValue)
    __call__ = _swig_new_instance_method(_math.math_Array1OfValueAndWeight___call__)
    SetValue = _swig_new_instance_method(_math.math_Array1OfValueAndWeight_SetValue)
    Resize = _swig_new_instance_method(_math.math_Array1OfValueAndWeight_Resize)
    __swig_destroy__ = _math.delete_math_Array1OfValueAndWeight

    def __getitem__(self, index):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            return self.Value(index + self.Lower())

    def __setitem__(self, index, value):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            self.SetValue(index + self.Lower(), value)

    def __len__(self):
        return self.Length()

    def __iter__(self):
        self.low = self.Lower()
        self.up = self.Upper()
        self.current = self.Lower() - 1
        return self

    def next(self):
        if self.current >= self.Upper():
            raise StopIteration
        else:
            self.current += 1
        return self.Value(self.current)

    __next__ = next


# Register math_Array1OfValueAndWeight in _math:
_math.math_Array1OfValueAndWeight_swigregister(math_Array1OfValueAndWeight)

class math(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    GaussPoints = _swig_new_static_method(_math.math_GaussPoints)
    GaussPointsMax = _swig_new_static_method(_math.math_GaussPointsMax)
    GaussWeights = _swig_new_static_method(_math.math_GaussWeights)
    KronrodPointsAndWeights = _swig_new_static_method(_math.math_KronrodPointsAndWeights)
    KronrodPointsMax = _swig_new_static_method(_math.math_KronrodPointsMax)
    OrderedGaussPointsAndWeights = _swig_new_static_method(_math.math_OrderedGaussPointsAndWeights)

    __repr__ = _dumps_object


    def __init__(self):
        _math.math_swiginit(self, _math.new_math())
    __swig_destroy__ = _math.delete_math

# Register math in _math:
_math.math_swigregister(math)
math_GaussPoints = _math.math_GaussPoints
math_GaussPointsMax = _math.math_GaussPointsMax
math_GaussWeights = _math.math_GaussWeights
math_KronrodPointsAndWeights = _math.math_KronrodPointsAndWeights
math_KronrodPointsMax = _math.math_KronrodPointsMax
math_OrderedGaussPointsAndWeights = _math.math_OrderedGaussPointsAndWeights

class math_BFGS(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DumpToString = _swig_new_instance_method(_math.math_BFGS_DumpToString)
    Gradient = _swig_new_instance_method(_math.math_BFGS_Gradient)
    IsDone = _swig_new_instance_method(_math.math_BFGS_IsDone)
    IsSolutionReached = _swig_new_instance_method(_math.math_BFGS_IsSolutionReached)
    Location = _swig_new_instance_method(_math.math_BFGS_Location)
    Minimum = _swig_new_instance_method(_math.math_BFGS_Minimum)
    NbIterations = _swig_new_instance_method(_math.math_BFGS_NbIterations)
    Perform = _swig_new_instance_method(_math.math_BFGS_Perform)
    SetBoundary = _swig_new_instance_method(_math.math_BFGS_SetBoundary)

    def __init__(self, *args):
        r"""
        * Initializes the computation of the minimum of a function with NbVariables. Tolerance, ZEPS and NbIterations are described in the method Perform. Warning: A call to the Perform method must be made after this initialization to effectively compute the minimum of the function F.
        	:param NbVariables:
        	:type NbVariables: int
        	:param Tolerance: default value is 1.0e-8
        	:type Tolerance: float
        	:param NbIterations: default value is 200
        	:type NbIterations: int
        	:param ZEPS: default value is 1.0e-12
        	:type ZEPS: float
        	:rtype: None
        """
        _math.math_BFGS_swiginit(self, _math.new_math_BFGS(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_BFGS

# Register math_BFGS in _math:
_math.math_BFGS_swigregister(math_BFGS)

class math_BissecNewton(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Derivative = _swig_new_instance_method(_math.math_BissecNewton_Derivative)
    DumpToString = _swig_new_instance_method(_math.math_BissecNewton_DumpToString)
    IsDone = _swig_new_instance_method(_math.math_BissecNewton_IsDone)
    IsSolutionReached = _swig_new_instance_method(_math.math_BissecNewton_IsSolutionReached)
    Perform = _swig_new_instance_method(_math.math_BissecNewton_Perform)
    Root = _swig_new_instance_method(_math.math_BissecNewton_Root)
    Value = _swig_new_instance_method(_math.math_BissecNewton_Value)

    def __init__(self, *args):
        r"""
        * Constructor. @param theXTolerance - algorithm tolerance.
        	:param theXTolerance:
        	:type theXTolerance: float
        	:rtype: None
        """
        _math.math_BissecNewton_swiginit(self, _math.new_math_BissecNewton(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_BissecNewton

# Register math_BissecNewton in _math:
_math.math_BissecNewton_swigregister(math_BissecNewton)

class math_BracketMinimum(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DumpToString = _swig_new_instance_method(_math.math_BracketMinimum_DumpToString)
    FunctionValues = _swig_new_instance_method(_math.math_BracketMinimum_FunctionValues)
    IsDone = _swig_new_instance_method(_math.math_BracketMinimum_IsDone)
    Perform = _swig_new_instance_method(_math.math_BracketMinimum_Perform)
    SetFA = _swig_new_instance_method(_math.math_BracketMinimum_SetFA)
    SetFB = _swig_new_instance_method(_math.math_BracketMinimum_SetFB)
    SetLimits = _swig_new_instance_method(_math.math_BracketMinimum_SetLimits)
    Values = _swig_new_instance_method(_math.math_BracketMinimum_Values)

    def __init__(self, *args):
        r"""
        * Constructor preparing A and B parameters only. It does not perform the job.
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:rtype: None* Given two initial values this class computes a bracketing triplet of abscissae Ax, Bx, Cx (such that Bx is between Ax and Cx, F(Bx) is less than both F(Bx) and F(Cx)) the Brent minimization is done on the function F.
        	:param F:
        	:type F: math_Function
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:rtype: None* Given two initial values this class computes a bracketing triplet of abscissae Ax, Bx, Cx (such that Bx is between Ax and Cx, F(Bx) is less than both F(Bx) and F(Cx)) the Brent minimization is done on the function F. This constructor has to be used if F(A) is known.
        	:param F:
        	:type F: math_Function
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param FA:
        	:type FA: float
        	:rtype: None* Given two initial values this class computes a bracketing triplet of abscissae Ax, Bx, Cx (such that Bx is between Ax and Cx, F(Bx) is less than both F(Bx) and F(Cx)) the Brent minimization is done on the function F. This constructor has to be used if F(A) and F(B) are known.
        	:param F:
        	:type F: math_Function
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param FA:
        	:type FA: float
        	:param FB:
        	:type FB: float
        	:rtype: None
        """
        _math.math_BracketMinimum_swiginit(self, _math.new_math_BracketMinimum(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_BracketMinimum

# Register math_BracketMinimum in _math:
_math.math_BracketMinimum_swigregister(math_BracketMinimum)

class math_BracketedRoot(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DumpToString = _swig_new_instance_method(_math.math_BracketedRoot_DumpToString)
    IsDone = _swig_new_instance_method(_math.math_BracketedRoot_IsDone)
    NbIterations = _swig_new_instance_method(_math.math_BracketedRoot_NbIterations)
    Root = _swig_new_instance_method(_math.math_BracketedRoot_Root)
    Value = _swig_new_instance_method(_math.math_BracketedRoot_Value)

    def __init__(self, *args):
        r"""
        * The Brent method is used to find the root of the function F between the bounds Bound1 and Bound2 on the function F. If F(Bound1)*F(Bound2) >0 the Brent method fails. The tolerance required for the root is given by Tolerance. The solution is found when : abs(Xi - Xi-1) <= Tolerance; The maximum number of iterations allowed is given by NbIterations.
        	:param F:
        	:type F: math_Function
        	:param Bound1:
        	:type Bound1: float
        	:param Bound2:
        	:type Bound2: float
        	:param Tolerance:
        	:type Tolerance: float
        	:param NbIterations: default value is 100
        	:type NbIterations: int
        	:param ZEPS: default value is 1.0e-12
        	:type ZEPS: float
        	:rtype: None
        """
        _math.math_BracketedRoot_swiginit(self, _math.new_math_BracketedRoot(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_BracketedRoot

# Register math_BracketedRoot in _math:
_math.math_BracketedRoot_swigregister(math_BracketedRoot)

class math_BrentMinimum(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DumpToString = _swig_new_instance_method(_math.math_BrentMinimum_DumpToString)
    IsDone = _swig_new_instance_method(_math.math_BrentMinimum_IsDone)
    IsSolutionReached = _swig_new_instance_method(_math.math_BrentMinimum_IsSolutionReached)
    Location = _swig_new_instance_method(_math.math_BrentMinimum_Location)
    Minimum = _swig_new_instance_method(_math.math_BrentMinimum_Minimum)
    NbIterations = _swig_new_instance_method(_math.math_BrentMinimum_NbIterations)
    Perform = _swig_new_instance_method(_math.math_BrentMinimum_Perform)

    def __init__(self, *args):
        r"""
        * This constructor should be used in a sub-class to initialize correctly all the fields of this class.
        	:param TolX:
        	:type TolX: float
        	:param NbIterations: default value is 100
        	:type NbIterations: int
        	:param ZEPS: default value is 1.0e-12
        	:type ZEPS: float
        	:rtype: None* This constructor should be used in a sub-class to initialize correctly all the fields of this class. It has to be used if F(Bx) is known.
        	:param TolX:
        	:type TolX: float
        	:param Fbx:
        	:type Fbx: float
        	:param NbIterations: default value is 100
        	:type NbIterations: int
        	:param ZEPS: default value is 1.0e-12
        	:type ZEPS: float
        	:rtype: None
        """
        _math.math_BrentMinimum_swiginit(self, _math.new_math_BrentMinimum(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_BrentMinimum

# Register math_BrentMinimum in _math:
_math.math_BrentMinimum_swigregister(math_BrentMinimum)

class math_BullardGenerator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    NextInt = _swig_new_instance_method(_math.math_BullardGenerator_NextInt)
    NextReal = _swig_new_instance_method(_math.math_BullardGenerator_NextReal)
    SetSeed = _swig_new_instance_method(_math.math_BullardGenerator_SetSeed)

    def __init__(self, *args):
        r"""
        * Creates new Xorshift 64-bit RNG.
        	:param theSeed: default value is 1
        	:type theSeed: unsigned int
        	:rtype: None
        """
        _math.math_BullardGenerator_swiginit(self, _math.new_math_BullardGenerator(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_BullardGenerator

# Register math_BullardGenerator in _math:
_math.math_BullardGenerator_swigregister(math_BullardGenerator)

class math_ComputeGaussPointsAndWeights(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    IsDone = _swig_new_instance_method(_math.math_ComputeGaussPointsAndWeights_IsDone)
    Points = _swig_new_instance_method(_math.math_ComputeGaussPointsAndWeights_Points)
    Weights = _swig_new_instance_method(_math.math_ComputeGaussPointsAndWeights_Weights)

    def __init__(self, *args):
        r"""
        :param Number:
        	:type Number: int
        	:rtype: None
        """
        _math.math_ComputeGaussPointsAndWeights_swiginit(self, _math.new_math_ComputeGaussPointsAndWeights(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_ComputeGaussPointsAndWeights

# Register math_ComputeGaussPointsAndWeights in _math:
_math.math_ComputeGaussPointsAndWeights_swigregister(math_ComputeGaussPointsAndWeights)

class math_ComputeKronrodPointsAndWeights(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    IsDone = _swig_new_instance_method(_math.math_ComputeKronrodPointsAndWeights_IsDone)
    Points = _swig_new_instance_method(_math.math_ComputeKronrodPointsAndWeights_Points)
    Weights = _swig_new_instance_method(_math.math_ComputeKronrodPointsAndWeights_Weights)

    def __init__(self, *args):
        r"""
        :param Number:
        	:type Number: int
        	:rtype: None
        """
        _math.math_ComputeKronrodPointsAndWeights_swiginit(self, _math.new_math_ComputeKronrodPointsAndWeights(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_ComputeKronrodPointsAndWeights

# Register math_ComputeKronrodPointsAndWeights in _math:
_math.math_ComputeKronrodPointsAndWeights_swigregister(math_ComputeKronrodPointsAndWeights)

class math_Crout(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Determinant = _swig_new_instance_method(_math.math_Crout_Determinant)
    DumpToString = _swig_new_instance_method(_math.math_Crout_DumpToString)
    Inverse = _swig_new_instance_method(_math.math_Crout_Inverse)
    Invert = _swig_new_instance_method(_math.math_Crout_Invert)
    IsDone = _swig_new_instance_method(_math.math_Crout_IsDone)
    Solve = _swig_new_instance_method(_math.math_Crout_Solve)

    def __init__(self, *args):
        r"""
        * Given an input matrix A, this algorithm inverts A by the Crout algorithm. The user can give only the inferior triangle for the implementation. A can be decomposed like this: A = L * D * T(L) where L is triangular inferior and D is diagonal. If one element of A is less than MinPivot, A is considered as singular. Exception NotSquare is raised if A is not a square matrix.
        	:param A:
        	:type A: math_Matrix
        	:param MinPivot: default value is 1.0e-20
        	:type MinPivot: float
        	:rtype: None
        """
        _math.math_Crout_swiginit(self, _math.new_math_Crout(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_Crout

# Register math_Crout in _math:
_math.math_Crout_swigregister(math_Crout)

class math_DirectPolynomialRoots(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DumpToString = _swig_new_instance_method(_math.math_DirectPolynomialRoots_DumpToString)
    InfiniteRoots = _swig_new_instance_method(_math.math_DirectPolynomialRoots_InfiniteRoots)
    IsDone = _swig_new_instance_method(_math.math_DirectPolynomialRoots_IsDone)
    NbSolutions = _swig_new_instance_method(_math.math_DirectPolynomialRoots_NbSolutions)
    Value = _swig_new_instance_method(_math.math_DirectPolynomialRoots_Value)

    def __init__(self, *args):
        r"""
        * computes all the real roots of the polynomial Ax4 + Bx3 + Cx2 + Dx + E using a direct method.
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param C:
        	:type C: float
        	:param D:
        	:type D: float
        	:param E:
        	:type E: float
        	:rtype: None* computes all the real roots of the polynomial Ax3 + Bx2 + Cx + D using a direct method.
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param C:
        	:type C: float
        	:param D:
        	:type D: float
        	:rtype: None* computes all the real roots of the polynomial Ax2 + Bx + C using a direct method.
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param C:
        	:type C: float
        	:rtype: None* computes the real root of the polynomial Ax + B.
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:rtype: None
        """
        _math.math_DirectPolynomialRoots_swiginit(self, _math.new_math_DirectPolynomialRoots(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_DirectPolynomialRoots

# Register math_DirectPolynomialRoots in _math:
_math.math_DirectPolynomialRoots_swigregister(math_DirectPolynomialRoots)

class math_DoubleTab(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Copy = _swig_new_instance_method(_math.math_DoubleTab_Copy)
    Free = _swig_new_instance_method(_math.math_DoubleTab_Free)
    Init = _swig_new_instance_method(_math.math_DoubleTab_Init)
    SetLowerCol = _swig_new_instance_method(_math.math_DoubleTab_SetLowerCol)
    SetLowerRow = _swig_new_instance_method(_math.math_DoubleTab_SetLowerRow)
    GetValue = _swig_new_instance_method(_math.math_DoubleTab_GetValue)
    SetValue = _swig_new_instance_method(_math.math_DoubleTab_SetValue)

    def __init__(self, *args):
        r"""
        :param LowerRow:
        	:type LowerRow: int
        	:param UpperRow:
        	:type UpperRow: int
        	:param LowerCol:
        	:type LowerCol: int
        	:param UpperCol:
        	:type UpperCol: int
        	:rtype: None:param Tab:
        	:type Tab: Standard_Address
        	:param LowerRow:
        	:type LowerRow: int
        	:param UpperRow:
        	:type UpperRow: int
        	:param LowerCol:
        	:type LowerCol: int
        	:param UpperCol:
        	:type UpperCol: int
        	:rtype: None:param Other:
        	:type Other: math_DoubleTab
        	:rtype: None
        """
        _math.math_DoubleTab_swiginit(self, _math.new_math_DoubleTab(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_DoubleTab

# Register math_DoubleTab in _math:
_math.math_DoubleTab_swigregister(math_DoubleTab)

class math_EigenValuesSearcher(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Dimension = _swig_new_instance_method(_math.math_EigenValuesSearcher_Dimension)
    EigenValue = _swig_new_instance_method(_math.math_EigenValuesSearcher_EigenValue)
    EigenVector = _swig_new_instance_method(_math.math_EigenValuesSearcher_EigenVector)
    IsDone = _swig_new_instance_method(_math.math_EigenValuesSearcher_IsDone)

    def __init__(self, *args):
        r"""
        :param Diagonal:
        	:type Diagonal: TColStd_Array1OfReal
        	:param Subdiagonal:
        	:type Subdiagonal: TColStd_Array1OfReal
        	:rtype: None
        """
        _math.math_EigenValuesSearcher_swiginit(self, _math.new_math_EigenValuesSearcher(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_EigenValuesSearcher

# Register math_EigenValuesSearcher in _math:
_math.math_EigenValuesSearcher_swigregister(math_EigenValuesSearcher)

class math_FRPR(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DumpToString = _swig_new_instance_method(_math.math_FRPR_DumpToString)
    Gradient = _swig_new_instance_method(_math.math_FRPR_Gradient)
    IsDone = _swig_new_instance_method(_math.math_FRPR_IsDone)
    IsSolutionReached = _swig_new_instance_method(_math.math_FRPR_IsSolutionReached)
    Location = _swig_new_instance_method(_math.math_FRPR_Location)
    Minimum = _swig_new_instance_method(_math.math_FRPR_Minimum)
    NbIterations = _swig_new_instance_method(_math.math_FRPR_NbIterations)
    Perform = _swig_new_instance_method(_math.math_FRPR_Perform)

    def __init__(self, *args):
        r"""
        * Initializes the computation of the minimum of F. Warning: constructor does not perform computations.
        	:param theFunction:
        	:type theFunction: math_MultipleVarFunctionWithGradient
        	:param theTolerance:
        	:type theTolerance: float
        	:param theNbIterations: default value is 200
        	:type theNbIterations: int
        	:param theZEPS: default value is 1.0e-12
        	:type theZEPS: float
        	:rtype: None
        """
        _math.math_FRPR_swiginit(self, _math.new_math_FRPR(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FRPR

# Register math_FRPR in _math:
_math.math_FRPR_swigregister(math_FRPR)

class math_Function(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    GetStateNumber = _swig_new_instance_method(_math.math_Function_GetStateNumber)
    Value = _swig_new_instance_method(_math.math_Function_Value)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_Function

# Register math_Function in _math:
_math.math_Function_swigregister(math_Function)

class math_FunctionAllRoots(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DumpToString = _swig_new_instance_method(_math.math_FunctionAllRoots_DumpToString)
    GetInterval = _swig_new_instance_method(_math.math_FunctionAllRoots_GetInterval)
    GetIntervalState = _swig_new_instance_method(_math.math_FunctionAllRoots_GetIntervalState)
    GetPoint = _swig_new_instance_method(_math.math_FunctionAllRoots_GetPoint)
    GetPointState = _swig_new_instance_method(_math.math_FunctionAllRoots_GetPointState)
    IsDone = _swig_new_instance_method(_math.math_FunctionAllRoots_IsDone)
    NbIntervals = _swig_new_instance_method(_math.math_FunctionAllRoots_NbIntervals)
    NbPoints = _swig_new_instance_method(_math.math_FunctionAllRoots_NbPoints)

    def __init__(self, *args):
        r"""
        * The algorithm uses the sample to find intervals on which the function is null. An interval is found if, for at least two consecutive points of the sample, Ui and Ui+1, we get |F(Ui)|<=EpsNul and |F(Ui+1)|<=EpsNul. The real bounds of an interval are computed with the FunctionRoots. algorithm. Between two intervals, the roots of the function F are calculated using the FunctionRoots algorithm.
        	:param F:
        	:type F: math_FunctionWithDerivative
        	:param S:
        	:type S: math_FunctionSample
        	:param EpsX:
        	:type EpsX: float
        	:param EpsF:
        	:type EpsF: float
        	:param EpsNul:
        	:type EpsNul: float
        	:rtype: None
        """
        _math.math_FunctionAllRoots_swiginit(self, _math.new_math_FunctionAllRoots(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FunctionAllRoots

# Register math_FunctionAllRoots in _math:
_math.math_FunctionAllRoots_swigregister(math_FunctionAllRoots)

class math_FunctionRoot(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Derivative = _swig_new_instance_method(_math.math_FunctionRoot_Derivative)
    DumpToString = _swig_new_instance_method(_math.math_FunctionRoot_DumpToString)
    IsDone = _swig_new_instance_method(_math.math_FunctionRoot_IsDone)
    NbIterations = _swig_new_instance_method(_math.math_FunctionRoot_NbIterations)
    Root = _swig_new_instance_method(_math.math_FunctionRoot_Root)
    Value = _swig_new_instance_method(_math.math_FunctionRoot_Value)

    def __init__(self, *args):
        r"""
        * The Newton-Raphson method is done to find the root of the function F from the initial guess Guess.The tolerance required on the root is given by Tolerance. Iterations are stopped if the expected solution does not stay in the range A..B. The solution is found when abs(Xi - Xi-1) <= Tolerance; The maximum number of iterations allowed is given by NbIterations.
        	:param F:
        	:type F: math_FunctionWithDerivative
        	:param Guess:
        	:type Guess: float
        	:param Tolerance:
        	:type Tolerance: float
        	:param NbIterations: default value is 100
        	:type NbIterations: int
        	:rtype: None* The Newton-Raphson method is done to find the root of the function F from the initial guess Guess. The tolerance required on the root is given by Tolerance. Iterations are stopped if the expected solution does not stay in the range A..B The solution is found when abs(Xi - Xi-1) <= Tolerance; The maximum number of iterations allowed is given by NbIterations.
        	:param F:
        	:type F: math_FunctionWithDerivative
        	:param Guess:
        	:type Guess: float
        	:param Tolerance:
        	:type Tolerance: float
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param NbIterations: default value is 100
        	:type NbIterations: int
        	:rtype: None
        """
        _math.math_FunctionRoot_swiginit(self, _math.new_math_FunctionRoot(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FunctionRoot

# Register math_FunctionRoot in _math:
_math.math_FunctionRoot_swigregister(math_FunctionRoot)

class math_FunctionRoots(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DumpToString = _swig_new_instance_method(_math.math_FunctionRoots_DumpToString)
    IsAllNull = _swig_new_instance_method(_math.math_FunctionRoots_IsAllNull)
    IsDone = _swig_new_instance_method(_math.math_FunctionRoots_IsDone)
    NbSolutions = _swig_new_instance_method(_math.math_FunctionRoots_NbSolutions)
    StateNumber = _swig_new_instance_method(_math.math_FunctionRoots_StateNumber)
    Value = _swig_new_instance_method(_math.math_FunctionRoots_Value)

    def __init__(self, *args):
        r"""
        * Calculates all the real roots of a function F-K within the range A..B. whithout conditions on A and B A solution X is found when abs(Xi - Xi-1) <= Epsx and abs(F(Xi)-K) <= EpsF. The function is considered as null between A and B if abs(F-K) <= EpsNull within this range.
        	:param F:
        	:type F: math_FunctionWithDerivative
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param NbSample:
        	:type NbSample: int
        	:param EpsX: default value is 0.0
        	:type EpsX: float
        	:param EpsF: default value is 0.0
        	:type EpsF: float
        	:param EpsNull: default value is 0.0
        	:type EpsNull: float
        	:param K: default value is 0.0
        	:type K: float
        	:rtype: None
        """
        _math.math_FunctionRoots_swiginit(self, _math.new_math_FunctionRoots(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FunctionRoots

# Register math_FunctionRoots in _math:
_math.math_FunctionRoots_swigregister(math_FunctionRoots)

class math_FunctionSample(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Bounds = _swig_new_instance_method(_math.math_FunctionSample_Bounds)
    GetParameter = _swig_new_instance_method(_math.math_FunctionSample_GetParameter)
    NbPoints = _swig_new_instance_method(_math.math_FunctionSample_NbPoints)

    def __init__(self, *args):
        r"""
        :param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param N:
        	:type N: int
        	:rtype: None
        """
        _math.math_FunctionSample_swiginit(self, _math.new_math_FunctionSample(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FunctionSample

# Register math_FunctionSample in _math:
_math.math_FunctionSample_swigregister(math_FunctionSample)

class math_FunctionSet(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    GetStateNumber = _swig_new_instance_method(_math.math_FunctionSet_GetStateNumber)
    NbEquations = _swig_new_instance_method(_math.math_FunctionSet_NbEquations)
    NbVariables = _swig_new_instance_method(_math.math_FunctionSet_NbVariables)
    Value = _swig_new_instance_method(_math.math_FunctionSet_Value)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FunctionSet

# Register math_FunctionSet in _math:
_math.math_FunctionSet_swigregister(math_FunctionSet)

class math_FunctionSetRoot(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Derivative = _swig_new_instance_method(_math.math_FunctionSetRoot_Derivative)
    DumpToString = _swig_new_instance_method(_math.math_FunctionSetRoot_DumpToString)
    FunctionSetErrors = _swig_new_instance_method(_math.math_FunctionSetRoot_FunctionSetErrors)
    IsDivergent = _swig_new_instance_method(_math.math_FunctionSetRoot_IsDivergent)
    IsDone = _swig_new_instance_method(_math.math_FunctionSetRoot_IsDone)
    IsSolutionReached = _swig_new_instance_method(_math.math_FunctionSetRoot_IsSolutionReached)
    NbIterations = _swig_new_instance_method(_math.math_FunctionSetRoot_NbIterations)
    Perform = _swig_new_instance_method(_math.math_FunctionSetRoot_Perform)
    Root = _swig_new_instance_method(_math.math_FunctionSetRoot_Root)
    SetTolerance = _swig_new_instance_method(_math.math_FunctionSetRoot_SetTolerance)
    StateNumber = _swig_new_instance_method(_math.math_FunctionSetRoot_StateNumber)

    def __init__(self, *args):
        r"""
        * is used in a sub-class to initialize correctly all the fields of this class. The range (1, F.NbVariables()) must be especially respected for all vectors and matrix declarations.
        	:param F:
        	:type F: math_FunctionSetWithDerivatives
        	:param Tolerance:
        	:type Tolerance: math_Vector
        	:param NbIterations: default value is 100
        	:type NbIterations: int
        	:rtype: None* is used in a sub-class to initialize correctly all the fields of this class. The range (1, F.NbVariables()) must be especially respected for all vectors and matrix declarations. The method SetTolerance must be called after this constructor.
        	:param F:
        	:type F: math_FunctionSetWithDerivatives
        	:param NbIterations: default value is 100
        	:type NbIterations: int
        	:rtype: None
        """
        _math.math_FunctionSetRoot_swiginit(self, _math.new_math_FunctionSetRoot(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FunctionSetRoot

# Register math_FunctionSetRoot in _math:
_math.math_FunctionSetRoot_swigregister(math_FunctionSetRoot)

class math_Gauss(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Determinant = _swig_new_instance_method(_math.math_Gauss_Determinant)
    DumpToString = _swig_new_instance_method(_math.math_Gauss_DumpToString)
    Invert = _swig_new_instance_method(_math.math_Gauss_Invert)
    IsDone = _swig_new_instance_method(_math.math_Gauss_IsDone)
    Solve = _swig_new_instance_method(_math.math_Gauss_Solve)

    def __init__(self, *args):
        r"""
        * Given an input n X n matrix A this constructor performs its LU decomposition with partial pivoting (interchange of rows). This LU decomposition is stored internally and may be used to do subsequent calculation. If the largest pivot found is less than MinPivot the matrix A is considered as singular. Exception NotSquare is raised if A is not a square matrix.
        	:param A:
        	:type A: math_Matrix
        	:param MinPivot: default value is 1.0e-20
        	:type MinPivot: float
        	:param aProgress: default value is opencascade::handle<Message_ProgressIndicator>()
        	:type aProgress: Message_ProgressIndicator
        	:rtype: None
        """
        _math.math_Gauss_swiginit(self, _math.new_math_Gauss(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_Gauss

# Register math_Gauss in _math:
_math.math_Gauss_swigregister(math_Gauss)

class math_GaussLeastSquare(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DumpToString = _swig_new_instance_method(_math.math_GaussLeastSquare_DumpToString)
    IsDone = _swig_new_instance_method(_math.math_GaussLeastSquare_IsDone)
    Solve = _swig_new_instance_method(_math.math_GaussLeastSquare_Solve)

    def __init__(self, *args):
        r"""
        * Given an input n X m matrix A with n >= m this constructor performs the LU decomposition with partial pivoting (interchange of rows) of the matrix AA = A.Transposed() * A; This LU decomposition is stored internally and may be used to do subsequent calculation. If the largest pivot found is less than MinPivot the matrix <A> is considered as singular.
        	:param A:
        	:type A: math_Matrix
        	:param MinPivot: default value is 1.0e-20
        	:type MinPivot: float
        	:rtype: None
        """
        _math.math_GaussLeastSquare_swiginit(self, _math.new_math_GaussLeastSquare(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_GaussLeastSquare

# Register math_GaussLeastSquare in _math:
_math.math_GaussLeastSquare_swigregister(math_GaussLeastSquare)

class math_GaussMultipleIntegration(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DumpToString = _swig_new_instance_method(_math.math_GaussMultipleIntegration_DumpToString)
    IsDone = _swig_new_instance_method(_math.math_GaussMultipleIntegration_IsDone)
    Value = _swig_new_instance_method(_math.math_GaussMultipleIntegration_Value)

    def __init__(self, *args):
        r"""
        * The Gauss-Legendre integration with Order = points of integration for each unknow, is done on the function F between the bounds Lower and Upper.
        	:param F:
        	:type F: math_MultipleVarFunction
        	:param Lower:
        	:type Lower: math_Vector
        	:param Upper:
        	:type Upper: math_Vector
        	:param Order:
        	:type Order: math_IntegerVector
        	:rtype: None
        """
        _math.math_GaussMultipleIntegration_swiginit(self, _math.new_math_GaussMultipleIntegration(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_GaussMultipleIntegration

# Register math_GaussMultipleIntegration in _math:
_math.math_GaussMultipleIntegration_swigregister(math_GaussMultipleIntegration)

class math_GaussSetIntegration(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DumpToString = _swig_new_instance_method(_math.math_GaussSetIntegration_DumpToString)
    IsDone = _swig_new_instance_method(_math.math_GaussSetIntegration_IsDone)
    Value = _swig_new_instance_method(_math.math_GaussSetIntegration_Value)

    def __init__(self, *args):
        r"""
        * The Gauss-Legendre integration with Order = points of integration for each unknow, is done on the function F between the bounds Lower and Upper.
        	:param F:
        	:type F: math_FunctionSet
        	:param Lower:
        	:type Lower: math_Vector
        	:param Upper:
        	:type Upper: math_Vector
        	:param Order:
        	:type Order: math_IntegerVector
        	:rtype: None
        """
        _math.math_GaussSetIntegration_swiginit(self, _math.new_math_GaussSetIntegration(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_GaussSetIntegration

# Register math_GaussSetIntegration in _math:
_math.math_GaussSetIntegration_swigregister(math_GaussSetIntegration)

class math_GaussSingleIntegration(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DumpToString = _swig_new_instance_method(_math.math_GaussSingleIntegration_DumpToString)
    IsDone = _swig_new_instance_method(_math.math_GaussSingleIntegration_IsDone)
    Value = _swig_new_instance_method(_math.math_GaussSingleIntegration_Value)

    def __init__(self, *args):
        r"""
        :rtype: None* The Gauss-Legendre integration with N = Order points of integration, is done on the function F between the bounds Lower and Upper.
        	:param F:
        	:type F: math_Function
        	:param Lower:
        	:type Lower: float
        	:param Upper:
        	:type Upper: float
        	:param Order:
        	:type Order: int
        	:rtype: None* The Gauss-Legendre integration with N = Order points of integration and given tolerance = Tol is done on the function F between the bounds Lower and Upper.
        	:param F:
        	:type F: math_Function
        	:param Lower:
        	:type Lower: float
        	:param Upper:
        	:type Upper: float
        	:param Order:
        	:type Order: int
        	:param Tol:
        	:type Tol: float
        	:rtype: None
        """
        _math.math_GaussSingleIntegration_swiginit(self, _math.new_math_GaussSingleIntegration(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_GaussSingleIntegration

# Register math_GaussSingleIntegration in _math:
_math.math_GaussSingleIntegration_swigregister(math_GaussSingleIntegration)

class math_GlobOptMin(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    GetContinuity = _swig_new_instance_method(_math.math_GlobOptMin_GetContinuity)
    GetF = _swig_new_instance_method(_math.math_GlobOptMin_GetF)
    GetFunctionalMinimalValue = _swig_new_instance_method(_math.math_GlobOptMin_GetFunctionalMinimalValue)
    GetLipConstState = _swig_new_instance_method(_math.math_GlobOptMin_GetLipConstState)
    GetTol = _swig_new_instance_method(_math.math_GlobOptMin_GetTol)
    NbExtrema = _swig_new_instance_method(_math.math_GlobOptMin_NbExtrema)
    Perform = _swig_new_instance_method(_math.math_GlobOptMin_Perform)
    Points = _swig_new_instance_method(_math.math_GlobOptMin_Points)
    SetContinuity = _swig_new_instance_method(_math.math_GlobOptMin_SetContinuity)
    SetFunctionalMinimalValue = _swig_new_instance_method(_math.math_GlobOptMin_SetFunctionalMinimalValue)
    SetGlobalParams = _swig_new_instance_method(_math.math_GlobOptMin_SetGlobalParams)
    SetLipConstState = _swig_new_instance_method(_math.math_GlobOptMin_SetLipConstState)
    SetLocalParams = _swig_new_instance_method(_math.math_GlobOptMin_SetLocalParams)
    SetTol = _swig_new_instance_method(_math.math_GlobOptMin_SetTol)

    def __init__(self, *args):
        r"""
        * Constructor. Perform method is not called from it. @param theFunc - objective functional. @param theLowerBorder - lower corner of the search box. @param theUpperBorder - upper corner of the search box. @param theC - Lipschitz constant. @param theDiscretizationTol - parameter space discretization tolerance. @param theSameTol - functional value space indifference tolerance.
        	:param theFunc:
        	:type theFunc: math_MultipleVarFunction *
        	:param theLowerBorder:
        	:type theLowerBorder: math_Vector
        	:param theUpperBorder:
        	:type theUpperBorder: math_Vector
        	:param theC: default value is 9
        	:type theC: float
        	:param theDiscretizationTol: default value is 1.0e-2
        	:type theDiscretizationTol: float
        	:param theSameTol: default value is 1.0e-7
        	:type theSameTol: float
        	:rtype: None
        """
        _math.math_GlobOptMin_swiginit(self, _math.new_math_GlobOptMin(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_GlobOptMin

# Register math_GlobOptMin in _math:
_math.math_GlobOptMin_swigregister(math_GlobOptMin)

class math_Householder(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    AllValues = _swig_new_instance_method(_math.math_Householder_AllValues)
    DumpToString = _swig_new_instance_method(_math.math_Householder_DumpToString)
    IsDone = _swig_new_instance_method(_math.math_Householder_IsDone)
    Value = _swig_new_instance_method(_math.math_Householder_Value)

    def __init__(self, *args):
        r"""
        * Given an input matrix A with n>= m, given an input matrix B this constructor performs the least square resolution of the set of linear equations A.X = B for each column of B. If a column norm is less than EPS, the resolution can't be done. Exception DimensionError is raised if the row number of B is different from the A row number.
        	:param A:
        	:type A: math_Matrix
        	:param B:
        	:type B: math_Matrix
        	:param EPS: default value is 1.0e-20
        	:type EPS: float
        	:rtype: None* Given an input matrix A with n>= m, given an input matrix B this constructor performs the least square resolution of the set of linear equations A.X = B for each column of B. If a column norm is less than EPS, the resolution can't be done. Exception DimensionError is raised if the row number of B is different from the A row number.
        	:param A:
        	:type A: math_Matrix
        	:param B:
        	:type B: math_Matrix
        	:param lowerArow:
        	:type lowerArow: int
        	:param upperArow:
        	:type upperArow: int
        	:param lowerAcol:
        	:type lowerAcol: int
        	:param upperAcol:
        	:type upperAcol: int
        	:param EPS: default value is 1.0e-20
        	:type EPS: float
        	:rtype: None* Given an input matrix A with n>= m, given an input vector B this constructor performs the least square resolution of the set of linear equations A.X = B. If a column norm is less than EPS, the resolution can't be done. Exception DimensionError is raised if the length of B is different from the A row number.
        	:param A:
        	:type A: math_Matrix
        	:param B:
        	:type B: math_Vector
        	:param EPS: default value is 1.0e-20
        	:type EPS: float
        	:rtype: None
        """
        _math.math_Householder_swiginit(self, _math.new_math_Householder(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_Householder

# Register math_Householder in _math:
_math.math_Householder_swigregister(math_Householder)

class math_IntegerVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Add = _swig_new_instance_method(_math.math_IntegerVector_Add)
    Added = _swig_new_instance_method(_math.math_IntegerVector_Added)
    DumpToString = _swig_new_instance_method(_math.math_IntegerVector_DumpToString)
    Init = _swig_new_instance_method(_math.math_IntegerVector_Init)
    Initialized = _swig_new_instance_method(_math.math_IntegerVector_Initialized)
    Inverse = _swig_new_instance_method(_math.math_IntegerVector_Inverse)
    Invert = _swig_new_instance_method(_math.math_IntegerVector_Invert)
    Length = _swig_new_instance_method(_math.math_IntegerVector_Length)
    Lower = _swig_new_instance_method(_math.math_IntegerVector_Lower)
    Max = _swig_new_instance_method(_math.math_IntegerVector_Max)
    Min = _swig_new_instance_method(_math.math_IntegerVector_Min)
    Multiplied = _swig_new_instance_method(_math.math_IntegerVector_Multiplied)
    Multiply = _swig_new_instance_method(_math.math_IntegerVector_Multiply)
    Norm = _swig_new_instance_method(_math.math_IntegerVector_Norm)
    Norm2 = _swig_new_instance_method(_math.math_IntegerVector_Norm2)
    Opposite = _swig_new_instance_method(_math.math_IntegerVector_Opposite)
    Slice = _swig_new_instance_method(_math.math_IntegerVector_Slice)
    Subtract = _swig_new_instance_method(_math.math_IntegerVector_Subtract)
    Subtracted = _swig_new_instance_method(_math.math_IntegerVector_Subtracted)
    TMultiplied = _swig_new_instance_method(_math.math_IntegerVector_TMultiplied)
    Upper = _swig_new_instance_method(_math.math_IntegerVector_Upper)
    Value = _swig_new_instance_method(_math.math_IntegerVector_Value)

    def __init__(self, *args):
        r"""
        * contructs an IntegerVector in the range [Lower..Upper]
        	:param theFirst:
        	:type theFirst: int
        	:param theLast:
        	:type theLast: int
        	:rtype: None* contructs an IntegerVector in the range [Lower..Upper] with all the elements set to theInitialValue.
        	:param theFirst:
        	:type theFirst: int
        	:param theLast:
        	:type theLast: int
        	:param theInitialValue:
        	:type theInitialValue: int
        	:rtype: None* constructs an IntegerVector in the range [Lower..Upper] which share the 'c array' theTab.
        	:param theTab:
        	:type theTab: int *
        	:param theFirst:
        	:type theFirst: int
        	:param theLast:
        	:type theLast: int
        	:rtype: None* constructs a copy for initialization. An exception is raised if the lengths of the IntegerVectors are different.
        	:param theOther:
        	:type theOther: math_IntegerVector
        	:rtype: None
        """
        _math.math_IntegerVector_swiginit(self, _math.new_math_IntegerVector(*args))
    __mul__ = _swig_new_instance_method(_math.math_IntegerVector___mul__)
    __imul_wrapper__ = _swig_new_instance_method(_math.math_IntegerVector___imul_wrapper__)

    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self

    __add__ = _swig_new_instance_method(_math.math_IntegerVector___add__)
    __iadd_wrapper__ = _swig_new_instance_method(_math.math_IntegerVector___iadd_wrapper__)

    def __iadd__(self, right):
        self.__iadd_wrapper__(right)
        return self

    __neg__ = _swig_new_instance_method(_math.math_IntegerVector___neg__)
    __sub__ = _swig_new_instance_method(_math.math_IntegerVector___sub__)
    __isub_wrapper__ = _swig_new_instance_method(_math.math_IntegerVector___isub_wrapper__)

    def __isub__(self, right):
        self.__isub_wrapper__(right)
        return self

    Set = _swig_new_instance_method(_math.math_IntegerVector_Set)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_IntegerVector

# Register math_IntegerVector in _math:
_math.math_IntegerVector_swigregister(math_IntegerVector)

class math_Jacobi(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DumpToString = _swig_new_instance_method(_math.math_Jacobi_DumpToString)
    IsDone = _swig_new_instance_method(_math.math_Jacobi_IsDone)
    Value = _swig_new_instance_method(_math.math_Jacobi_Value)
    Values = _swig_new_instance_method(_math.math_Jacobi_Values)
    Vector = _swig_new_instance_method(_math.math_Jacobi_Vector)
    Vectors = _swig_new_instance_method(_math.math_Jacobi_Vectors)

    def __init__(self, *args):
        r"""
        * Given a Real n X n matrix A, this constructor computes all its eigenvalues and eigenvectors using the Jacobi method. The exception NotSquare is raised if the matrix is not square. No verification that the matrix A is really symmetric is done.
        	:param A:
        	:type A: math_Matrix
        	:rtype: None
        """
        _math.math_Jacobi_swiginit(self, _math.new_math_Jacobi(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_Jacobi

# Register math_Jacobi in _math:
_math.math_Jacobi_swigregister(math_Jacobi)

class math_KronrodSingleIntegration(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    AbsolutError = _swig_new_instance_method(_math.math_KronrodSingleIntegration_AbsolutError)
    ErrorReached = _swig_new_instance_method(_math.math_KronrodSingleIntegration_ErrorReached)
    GKRule = _swig_new_static_method(_math.math_KronrodSingleIntegration_GKRule)
    IsDone = _swig_new_instance_method(_math.math_KronrodSingleIntegration_IsDone)
    NbIterReached = _swig_new_instance_method(_math.math_KronrodSingleIntegration_NbIterReached)
    OrderReached = _swig_new_instance_method(_math.math_KronrodSingleIntegration_OrderReached)
    Perform = _swig_new_instance_method(_math.math_KronrodSingleIntegration_Perform)
    Value = _swig_new_instance_method(_math.math_KronrodSingleIntegration_Value)

    def __init__(self, *args):
        r"""
        * An empty constructor.
        	:rtype: None* Constructor. Takes the function, the lower and upper bound values, the initial number of Kronrod points
        	:param theFunction:
        	:type theFunction: math_Function
        	:param theLower:
        	:type theLower: float
        	:param theUpper:
        	:type theUpper: float
        	:param theNbPnts:
        	:type theNbPnts: int
        	:rtype: None* Constructor. Takes the function, the lower and upper bound values, the initial number of Kronrod points, the tolerance value and the maximal number of iterations as parameters.
        	:param theFunction:
        	:type theFunction: math_Function
        	:param theLower:
        	:type theLower: float
        	:param theUpper:
        	:type theUpper: float
        	:param theNbPnts:
        	:type theNbPnts: int
        	:param theTolerance:
        	:type theTolerance: float
        	:param theMaxNbIter:
        	:type theMaxNbIter: int
        	:rtype: None
        """
        _math.math_KronrodSingleIntegration_swiginit(self, _math.new_math_KronrodSingleIntegration(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_KronrodSingleIntegration

# Register math_KronrodSingleIntegration in _math:
_math.math_KronrodSingleIntegration_swigregister(math_KronrodSingleIntegration)
math_KronrodSingleIntegration_GKRule = _math.math_KronrodSingleIntegration_GKRule

class math_Matrix(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Add = _swig_new_instance_method(_math.math_Matrix_Add)
    Added = _swig_new_instance_method(_math.math_Matrix_Added)
    Col = _swig_new_instance_method(_math.math_Matrix_Col)
    ColNumber = _swig_new_instance_method(_math.math_Matrix_ColNumber)
    Determinant = _swig_new_instance_method(_math.math_Matrix_Determinant)
    Divide = _swig_new_instance_method(_math.math_Matrix_Divide)
    Divided = _swig_new_instance_method(_math.math_Matrix_Divided)
    DumpToString = _swig_new_instance_method(_math.math_Matrix_DumpToString)
    Init = _swig_new_instance_method(_math.math_Matrix_Init)
    Initialized = _swig_new_instance_method(_math.math_Matrix_Initialized)
    Inverse = _swig_new_instance_method(_math.math_Matrix_Inverse)
    Invert = _swig_new_instance_method(_math.math_Matrix_Invert)
    LowerCol = _swig_new_instance_method(_math.math_Matrix_LowerCol)
    LowerRow = _swig_new_instance_method(_math.math_Matrix_LowerRow)
    Multiplied = _swig_new_instance_method(_math.math_Matrix_Multiplied)
    Multiply = _swig_new_instance_method(_math.math_Matrix_Multiply)
    Opposite = _swig_new_instance_method(_math.math_Matrix_Opposite)
    Row = _swig_new_instance_method(_math.math_Matrix_Row)
    RowNumber = _swig_new_instance_method(_math.math_Matrix_RowNumber)
    SetCol = _swig_new_instance_method(_math.math_Matrix_SetCol)
    SetDiag = _swig_new_instance_method(_math.math_Matrix_SetDiag)
    SetRow = _swig_new_instance_method(_math.math_Matrix_SetRow)
    Subtract = _swig_new_instance_method(_math.math_Matrix_Subtract)
    Subtracted = _swig_new_instance_method(_math.math_Matrix_Subtracted)
    SwapCol = _swig_new_instance_method(_math.math_Matrix_SwapCol)
    SwapRow = _swig_new_instance_method(_math.math_Matrix_SwapRow)
    TMultiplied = _swig_new_instance_method(_math.math_Matrix_TMultiplied)
    TMultiply = _swig_new_instance_method(_math.math_Matrix_TMultiply)
    Transpose = _swig_new_instance_method(_math.math_Matrix_Transpose)
    Transposed = _swig_new_instance_method(_math.math_Matrix_Transposed)
    UpperCol = _swig_new_instance_method(_math.math_Matrix_UpperCol)
    UpperRow = _swig_new_instance_method(_math.math_Matrix_UpperRow)
    GetValue = _swig_new_instance_method(_math.math_Matrix_GetValue)
    SetValue = _swig_new_instance_method(_math.math_Matrix_SetValue)

    def __init__(self, *args):
        r"""
        * Constructs a non-initialized matrix of range [LowerRow..UpperRow, LowerCol..UpperCol] For the constructed matrix: - LowerRow and UpperRow are the indexes of the lower and upper bounds of a row, and - LowerCol and UpperCol are the indexes of the lower and upper bounds of a column.
        	:param LowerRow:
        	:type LowerRow: int
        	:param UpperRow:
        	:type UpperRow: int
        	:param LowerCol:
        	:type LowerCol: int
        	:param UpperCol:
        	:type UpperCol: int
        	:rtype: None* constructs a non-initialized matrix of range [LowerRow..UpperRow, LowerCol..UpperCol] whose values are all initialized with the value InitialValue.
        	:param LowerRow:
        	:type LowerRow: int
        	:param UpperRow:
        	:type UpperRow: int
        	:param LowerCol:
        	:type LowerCol: int
        	:param UpperCol:
        	:type UpperCol: int
        	:param InitialValue:
        	:type InitialValue: float
        	:rtype: None* constructs a matrix of range [LowerRow..UpperRow, LowerCol..UpperCol] Sharing data with a 'C array' pointed by Tab.
        	:param Tab:
        	:type Tab: Standard_Address
        	:param LowerRow:
        	:type LowerRow: int
        	:param UpperRow:
        	:type UpperRow: int
        	:param LowerCol:
        	:type LowerCol: int
        	:param UpperCol:
        	:type UpperCol: int
        	:rtype: None* constructs a matrix for copy in initialization. An exception is raised if the matrixes have not the same dimensions.
        	:param Other:
        	:type Other: math_Matrix
        	:rtype: None
        """
        _math.math_Matrix_swiginit(self, _math.new_math_Matrix(*args))
    __mul__ = _swig_new_instance_method(_math.math_Matrix___mul__)

    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self

    __imul_wrapper__ = _swig_new_instance_method(_math.math_Matrix___imul_wrapper__)

    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self

    __add__ = _swig_new_instance_method(_math.math_Matrix___add__)
    __iadd_wrapper__ = _swig_new_instance_method(_math.math_Matrix___iadd_wrapper__)

    def __iadd__(self, right):
        self.__iadd_wrapper__(right)
        return self

    __sub__ = _swig_new_instance_method(_math.math_Matrix___sub__)
    __neg__ = _swig_new_instance_method(_math.math_Matrix___neg__)
    __isub_wrapper__ = _swig_new_instance_method(_math.math_Matrix___isub_wrapper__)

    def __isub__(self, right):
        self.__isub_wrapper__(right)
        return self


    def __truediv__(self, *args):
        return _math.math_Matrix___truediv__(self, *args)
    __div__ = __truediv__


    __itruediv_wrapper__ = _swig_new_instance_method(_math.math_Matrix___itruediv_wrapper__)

    def __itruediv__(self, right):
        self.__itruediv_wrapper__(right)
        return self

    Set = _swig_new_instance_method(_math.math_Matrix_Set)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_Matrix

# Register math_Matrix in _math:
_math.math_Matrix_swigregister(math_Matrix)

class math_MultipleVarFunction(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    GetStateNumber = _swig_new_instance_method(_math.math_MultipleVarFunction_GetStateNumber)
    NbVariables = _swig_new_instance_method(_math.math_MultipleVarFunction_NbVariables)
    Value = _swig_new_instance_method(_math.math_MultipleVarFunction_Value)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_MultipleVarFunction

# Register math_MultipleVarFunction in _math:
_math.math_MultipleVarFunction_swigregister(math_MultipleVarFunction)

class math_NewtonFunctionRoot(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Derivative = _swig_new_instance_method(_math.math_NewtonFunctionRoot_Derivative)
    DumpToString = _swig_new_instance_method(_math.math_NewtonFunctionRoot_DumpToString)
    IsDone = _swig_new_instance_method(_math.math_NewtonFunctionRoot_IsDone)
    NbIterations = _swig_new_instance_method(_math.math_NewtonFunctionRoot_NbIterations)
    Perform = _swig_new_instance_method(_math.math_NewtonFunctionRoot_Perform)
    Root = _swig_new_instance_method(_math.math_NewtonFunctionRoot_Root)
    Value = _swig_new_instance_method(_math.math_NewtonFunctionRoot_Value)

    def __init__(self, *args):
        r"""
        * The Newton method is done to find the root of the function F from the initial guess Guess. The tolerance required on the root is given by Tolerance. The solution is found when : abs(Xi - Xi-1) <= EpsX and abs(F(Xi))<= EpsF The maximum number of iterations allowed is given by NbIterations.
        	:param F:
        	:type F: math_FunctionWithDerivative
        	:param Guess:
        	:type Guess: float
        	:param EpsX:
        	:type EpsX: float
        	:param EpsF:
        	:type EpsF: float
        	:param NbIterations: default value is 100
        	:type NbIterations: int
        	:rtype: None* The Newton method is done to find the root of the function F from the initial guess Guess. The solution must be inside the interval [A, B]. The tolerance required on the root is given by Tolerance. The solution is found when : abs(Xi - Xi-1) <= EpsX and abs(F(Xi))<= EpsF The maximum number of iterations allowed is given by NbIterations.
        	:param F:
        	:type F: math_FunctionWithDerivative
        	:param Guess:
        	:type Guess: float
        	:param EpsX:
        	:type EpsX: float
        	:param EpsF:
        	:type EpsF: float
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param NbIterations: default value is 100
        	:type NbIterations: int
        	:rtype: None* is used in a sub-class to initialize correctly all the fields of this class.
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param EpsX:
        	:type EpsX: float
        	:param EpsF:
        	:type EpsF: float
        	:param NbIterations: default value is 100
        	:type NbIterations: int
        	:rtype: None
        """
        _math.math_NewtonFunctionRoot_swiginit(self, _math.new_math_NewtonFunctionRoot(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_NewtonFunctionRoot

# Register math_NewtonFunctionRoot in _math:
_math.math_NewtonFunctionRoot_swigregister(math_NewtonFunctionRoot)

class math_NewtonFunctionSetRoot(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Derivative = _swig_new_instance_method(_math.math_NewtonFunctionSetRoot_Derivative)
    DumpToString = _swig_new_instance_method(_math.math_NewtonFunctionSetRoot_DumpToString)
    FunctionSetErrors = _swig_new_instance_method(_math.math_NewtonFunctionSetRoot_FunctionSetErrors)
    IsDone = _swig_new_instance_method(_math.math_NewtonFunctionSetRoot_IsDone)
    IsSolutionReached = _swig_new_instance_method(_math.math_NewtonFunctionSetRoot_IsSolutionReached)
    NbIterations = _swig_new_instance_method(_math.math_NewtonFunctionSetRoot_NbIterations)
    Perform = _swig_new_instance_method(_math.math_NewtonFunctionSetRoot_Perform)
    Root = _swig_new_instance_method(_math.math_NewtonFunctionSetRoot_Root)
    SetTolerance = _swig_new_instance_method(_math.math_NewtonFunctionSetRoot_SetTolerance)

    def __init__(self, *args):
        r"""
        * Initialize correctly all the fields of this class. The range (1, F.NbVariables()) must be especially respected for all vectors and matrix declarations.
        	:param theFunction:
        	:type theFunction: math_FunctionSetWithDerivatives
        	:param theXTolerance:
        	:type theXTolerance: math_Vector
        	:param theFTolerance:
        	:type theFTolerance: float
        	:param tehNbIterations: default value is 100
        	:type tehNbIterations: int
        	:rtype: None* This constructor should be used in a sub-class to initialize correctly all the fields of this class. The range (1, F.NbVariables()) must be especially respected for all vectors and matrix declarations. The method SetTolerance must be called before performing the algorithm.
        	:param theFunction:
        	:type theFunction: math_FunctionSetWithDerivatives
        	:param theFTolerance:
        	:type theFTolerance: float
        	:param theNbIterations: default value is 100
        	:type theNbIterations: int
        	:rtype: None
        """
        _math.math_NewtonFunctionSetRoot_swiginit(self, _math.new_math_NewtonFunctionSetRoot(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_NewtonFunctionSetRoot

# Register math_NewtonFunctionSetRoot in _math:
_math.math_NewtonFunctionSetRoot_swigregister(math_NewtonFunctionSetRoot)

class math_NewtonMinimum(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DumpToString = _swig_new_instance_method(_math.math_NewtonMinimum_DumpToString)
    GetStatus = _swig_new_instance_method(_math.math_NewtonMinimum_GetStatus)
    Gradient = _swig_new_instance_method(_math.math_NewtonMinimum_Gradient)
    IsConverged = _swig_new_instance_method(_math.math_NewtonMinimum_IsConverged)
    IsDone = _swig_new_instance_method(_math.math_NewtonMinimum_IsDone)
    Location = _swig_new_instance_method(_math.math_NewtonMinimum_Location)
    Minimum = _swig_new_instance_method(_math.math_NewtonMinimum_Minimum)
    NbIterations = _swig_new_instance_method(_math.math_NewtonMinimum_NbIterations)
    Perform = _swig_new_instance_method(_math.math_NewtonMinimum_Perform)
    SetBoundary = _swig_new_instance_method(_math.math_NewtonMinimum_SetBoundary)

    def __init__(self, *args):
        r"""
        * The tolerance required on the solution is given by Tolerance. Iteration are stopped if (!WithSingularity) and H(F(Xi)) is not definite positive (if the smaller eigenvalue of H < Convexity) or IsConverged() returns True for 2 successives Iterations. Warning: This constructor does not perform computation.
        	:param theFunction:
        	:type theFunction: math_MultipleVarFunctionWithHessian
        	:param theTolerance: default value is Precision::Confusion()
        	:type theTolerance: float
        	:param theNbIterations: default value is 40
        	:type theNbIterations: int
        	:param theConvexity: default value is 1.0e-6
        	:type theConvexity: float
        	:param theWithSingularity: default value is Standard_True
        	:type theWithSingularity: bool
        	:rtype: None
        """
        _math.math_NewtonMinimum_swiginit(self, _math.new_math_NewtonMinimum(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_NewtonMinimum

# Register math_NewtonMinimum in _math:
_math.math_NewtonMinimum_swigregister(math_NewtonMinimum)

class math_PSO(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Perform = _swig_new_instance_method(_math.math_PSO_Perform)

    def __init__(self, *args):
        r"""
        * /** * Constructor. * * @param theFunc defines the objective function. It should exist during all lifetime of class instance. * @param theLowBorder defines lower border of search space. * @param theUppBorder defines upper border of search space. * @param theSteps defines steps of regular grid, used for particle generation. This parameter used to define stop condition (TerminalVelocity). * @param theNbParticles defines number of particles. * @param theNbIter defines maximum number of iterations. */
        	:param theFunc:
        	:type theFunc: math_MultipleVarFunction *
        	:param theLowBorder:
        	:type theLowBorder: math_Vector
        	:param theUppBorder:
        	:type theUppBorder: math_Vector
        	:param theSteps:
        	:type theSteps: math_Vector
        	:param theNbParticles: default value is 32
        	:type theNbParticles: int
        	:param theNbIter: default value is 100
        	:type theNbIter: int
        	:rtype: None
        """
        _math.math_PSO_swiginit(self, _math.new_math_PSO(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_PSO

# Register math_PSO in _math:
_math.math_PSO_swigregister(math_PSO)

class math_PSOParticlesPool(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    GetBestParticle = _swig_new_instance_method(_math.math_PSOParticlesPool_GetBestParticle)
    GetParticle = _swig_new_instance_method(_math.math_PSOParticlesPool_GetParticle)
    GetWorstParticle = _swig_new_instance_method(_math.math_PSOParticlesPool_GetWorstParticle)

    def __init__(self, *args):
        r"""
        :param theParticlesCount:
        	:type theParticlesCount: int
        	:param theDimensionCount:
        	:type theDimensionCount: int
        	:rtype: None
        """
        _math.math_PSOParticlesPool_swiginit(self, _math.new_math_PSOParticlesPool(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_PSOParticlesPool

# Register math_PSOParticlesPool in _math:
_math.math_PSOParticlesPool_swigregister(math_PSOParticlesPool)

class math_Powell(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DumpToString = _swig_new_instance_method(_math.math_Powell_DumpToString)
    IsDone = _swig_new_instance_method(_math.math_Powell_IsDone)
    IsSolutionReached = _swig_new_instance_method(_math.math_Powell_IsSolutionReached)
    Location = _swig_new_instance_method(_math.math_Powell_Location)
    Minimum = _swig_new_instance_method(_math.math_Powell_Minimum)
    NbIterations = _swig_new_instance_method(_math.math_Powell_NbIterations)
    Perform = _swig_new_instance_method(_math.math_Powell_Perform)

    def __init__(self, *args):
        r"""
        * Constructor. Initialize new entity.
        	:param theFunction:
        	:type theFunction: math_MultipleVarFunction
        	:param theTolerance:
        	:type theTolerance: float
        	:param theNbIterations: default value is 200
        	:type theNbIterations: int
        	:param theZEPS: default value is 1.0e-12
        	:type theZEPS: float
        	:rtype: None
        """
        _math.math_Powell_swiginit(self, _math.new_math_Powell(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_Powell

# Register math_Powell in _math:
_math.math_Powell_swigregister(math_Powell)

class math_SVD(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DumpToString = _swig_new_instance_method(_math.math_SVD_DumpToString)
    IsDone = _swig_new_instance_method(_math.math_SVD_IsDone)
    PseudoInverse = _swig_new_instance_method(_math.math_SVD_PseudoInverse)
    Solve = _swig_new_instance_method(_math.math_SVD_Solve)

    def __init__(self, *args):
        r"""
        * Given as input an n X m matrix A with n < m, n = m or n > m this constructor performs the Singular Value Decomposition.
        	:param A:
        	:type A: math_Matrix
        	:rtype: None
        """
        _math.math_SVD_swiginit(self, _math.new_math_SVD(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_SVD

# Register math_SVD in _math:
_math.math_SVD_swigregister(math_SVD)

class math_TrigonometricFunctionRoots(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DumpToString = _swig_new_instance_method(_math.math_TrigonometricFunctionRoots_DumpToString)
    InfiniteRoots = _swig_new_instance_method(_math.math_TrigonometricFunctionRoots_InfiniteRoots)
    IsDone = _swig_new_instance_method(_math.math_TrigonometricFunctionRoots_IsDone)
    NbSolutions = _swig_new_instance_method(_math.math_TrigonometricFunctionRoots_NbSolutions)
    Value = _swig_new_instance_method(_math.math_TrigonometricFunctionRoots_Value)

    def __init__(self, *args):
        r"""
        * Given coefficients a, b, c, d , e, this constructor performs the resolution of the equation above. The solutions must be contained in [InfBound, SupBound]. InfBound and SupBound can be set by default to 0 and 2*PI.
        	:param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param C:
        	:type C: float
        	:param D:
        	:type D: float
        	:param E:
        	:type E: float
        	:param InfBound:
        	:type InfBound: float
        	:param SupBound:
        	:type SupBound: float
        	:rtype: None* Given the two coefficients d and e, it performs the resolution of d*sin(x) + e = 0. The solutions must be contained in [InfBound, SupBound]. InfBound and SupBound can be set by default to 0 and 2*PI.
        	:param D:
        	:type D: float
        	:param E:
        	:type E: float
        	:param InfBound:
        	:type InfBound: float
        	:param SupBound:
        	:type SupBound: float
        	:rtype: None* Given the three coefficients c, d and e, it performs the resolution of c*Cos(x) + d*sin(x) + e = 0. The solutions must be contained in [InfBound, SupBound]. InfBound and SupBound can be set by default to 0 and 2*PI.
        	:param C:
        	:type C: float
        	:param D:
        	:type D: float
        	:param E:
        	:type E: float
        	:param InfBound:
        	:type InfBound: float
        	:param SupBound:
        	:type SupBound: float
        	:rtype: None
        """
        _math.math_TrigonometricFunctionRoots_swiginit(self, _math.new_math_TrigonometricFunctionRoots(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_TrigonometricFunctionRoots

# Register math_TrigonometricFunctionRoots in _math:
_math.math_TrigonometricFunctionRoots_swigregister(math_TrigonometricFunctionRoots)

class math_Uzawa(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Duale = _swig_new_instance_method(_math.math_Uzawa_Duale)
    DumpToString = _swig_new_instance_method(_math.math_Uzawa_DumpToString)
    Error = _swig_new_instance_method(_math.math_Uzawa_Error)
    InitialError = _swig_new_instance_method(_math.math_Uzawa_InitialError)
    InverseCont = _swig_new_instance_method(_math.math_Uzawa_InverseCont)
    IsDone = _swig_new_instance_method(_math.math_Uzawa_IsDone)
    NbIterations = _swig_new_instance_method(_math.math_Uzawa_NbIterations)
    Value = _swig_new_instance_method(_math.math_Uzawa_Value)

    def __init__(self, *args):
        r"""
        * Given an input matrix Cont, two input vectors Secont and StartingPoint, it solves Cont*X = Secont (only = equations) with a minimization of Norme(X-X0). The maximun iterations number allowed is fixed to NbIterations. The tolerance EpsLic is fixed for the dual variable convergence. The tolerance EpsLix is used for the convergence of X. Exception ConstuctionError is raised if the line number of Cont is different from the length of Secont.
        	:param Cont:
        	:type Cont: math_Matrix
        	:param Secont:
        	:type Secont: math_Vector
        	:param StartingPoint:
        	:type StartingPoint: math_Vector
        	:param EpsLix: default value is 1.0e-06
        	:type EpsLix: float
        	:param EpsLic: default value is 1.0e-06
        	:type EpsLic: float
        	:param NbIterations: default value is 500
        	:type NbIterations: int
        	:rtype: None* Given an input matrix Cont, two input vectors Secont and StartingPoint, it solves Cont*X = Secont (the Nce first equations are equal equations and the Nci last equations are inequalities <) with a minimization of Norme(X-X0). The maximun iterations number allowed is fixed to NbIterations. The tolerance EpsLic is fixed for the dual variable convergence. The tolerance EpsLix is used for the convergence of X. There are no conditions on Nce and Nci. Exception ConstuctionError is raised if the line number of Cont is different from the length of Secont and from Nce + Nci.
        	:param Cont:
        	:type Cont: math_Matrix
        	:param Secont:
        	:type Secont: math_Vector
        	:param StartingPoint:
        	:type StartingPoint: math_Vector
        	:param Nci:
        	:type Nci: int
        	:param Nce:
        	:type Nce: int
        	:param EpsLix: default value is 1.0e-06
        	:type EpsLix: float
        	:param EpsLic: default value is 1.0e-06
        	:type EpsLic: float
        	:param NbIterations: default value is 500
        	:type NbIterations: int
        	:rtype: None
        """
        _math.math_Uzawa_swiginit(self, _math.new_math_Uzawa(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_Uzawa

# Register math_Uzawa in _math:
_math.math_Uzawa_swigregister(math_Uzawa)

class math_ValueAndWeight(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Value = _swig_new_instance_method(_math.math_ValueAndWeight_Value)
    Weight = _swig_new_instance_method(_math.math_ValueAndWeight_Weight)

    def __init__(self, *args):
        r"""
        :rtype: None:param theValue:
        	:type theValue: float
        	:param theWeight:
        	:type theWeight: float
        	:rtype: None
        """
        _math.math_ValueAndWeight_swiginit(self, _math.new_math_ValueAndWeight(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_ValueAndWeight

# Register math_ValueAndWeight in _math:
_math.math_ValueAndWeight_swigregister(math_ValueAndWeight)

class math_Vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Add = _swig_new_instance_method(_math.math_Vector_Add)
    Added = _swig_new_instance_method(_math.math_Vector_Added)
    Divide = _swig_new_instance_method(_math.math_Vector_Divide)
    Divided = _swig_new_instance_method(_math.math_Vector_Divided)
    DumpToString = _swig_new_instance_method(_math.math_Vector_DumpToString)
    Init = _swig_new_instance_method(_math.math_Vector_Init)
    Initialized = _swig_new_instance_method(_math.math_Vector_Initialized)
    Inverse = _swig_new_instance_method(_math.math_Vector_Inverse)
    Invert = _swig_new_instance_method(_math.math_Vector_Invert)
    Length = _swig_new_instance_method(_math.math_Vector_Length)
    Lower = _swig_new_instance_method(_math.math_Vector_Lower)
    Max = _swig_new_instance_method(_math.math_Vector_Max)
    Min = _swig_new_instance_method(_math.math_Vector_Min)
    Multiplied = _swig_new_instance_method(_math.math_Vector_Multiplied)
    Multiply = _swig_new_instance_method(_math.math_Vector_Multiply)
    Norm = _swig_new_instance_method(_math.math_Vector_Norm)
    Norm2 = _swig_new_instance_method(_math.math_Vector_Norm2)
    Normalize = _swig_new_instance_method(_math.math_Vector_Normalize)
    Normalized = _swig_new_instance_method(_math.math_Vector_Normalized)
    Opposite = _swig_new_instance_method(_math.math_Vector_Opposite)
    Slice = _swig_new_instance_method(_math.math_Vector_Slice)
    Subtract = _swig_new_instance_method(_math.math_Vector_Subtract)
    Subtracted = _swig_new_instance_method(_math.math_Vector_Subtracted)
    TMultiplied = _swig_new_instance_method(_math.math_Vector_TMultiplied)
    TMultiply = _swig_new_instance_method(_math.math_Vector_TMultiply)
    Upper = _swig_new_instance_method(_math.math_Vector_Upper)
    Value = _swig_new_instance_method(_math.math_Vector_Value)

    def __init__(self, *args):
        r"""
        * Contructs a non-initialized vector in the range [theLower..theUpper] 'theLower' and 'theUpper' are the indexes of the lower and upper bounds of the constructed vector.
        	:param theLower:
        	:type theLower: int
        	:param theUpper:
        	:type theUpper: int
        	:rtype: None* Contructs a vector in the range [theLower..theUpper] whose values are all initialized with the value 'theInitialValue'
        	:param theLower:
        	:type theLower: int
        	:param theUpper:
        	:type theUpper: int
        	:param theInitialValue:
        	:type theInitialValue: float
        	:rtype: None* Constructs a vector in the range [theLower..theUpper] with the 'c array' theTab.
        	:param theTab:
        	:type theTab: float *
        	:param theLower:
        	:type theLower: int
        	:param theUpper:
        	:type theUpper: int
        	:rtype: None* Constructor for converting gp_XY to math_Vector
        	:param Other:
        	:type Other: gp_XY
        	:rtype: None* Constructor for converting gp_XYZ to math_Vector
        	:param Other:
        	:type Other: gp_XYZ
        	:rtype: None* Constructs a copy for initialization. An exception is raised if the lengths of the vectors are different.
        	:param theOther:
        	:type theOther: math_Vector
        	:rtype: None
        """
        _math.math_Vector_swiginit(self, _math.new_math_Vector(*args))
    __mul__ = _swig_new_instance_method(_math.math_Vector___mul__)
    __imul_wrapper__ = _swig_new_instance_method(_math.math_Vector___imul_wrapper__)

    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self

    __add__ = _swig_new_instance_method(_math.math_Vector___add__)
    __iadd_wrapper__ = _swig_new_instance_method(_math.math_Vector___iadd_wrapper__)

    def __iadd__(self, right):
        self.__iadd_wrapper__(right)
        return self

    __neg__ = _swig_new_instance_method(_math.math_Vector___neg__)
    __sub__ = _swig_new_instance_method(_math.math_Vector___sub__)
    __isub_wrapper__ = _swig_new_instance_method(_math.math_Vector___isub_wrapper__)

    def __isub__(self, right):
        self.__isub_wrapper__(right)
        return self


    def __truediv__(self, *args):
        return _math.math_Vector___truediv__(self, *args)
    __div__ = __truediv__


    __itruediv_wrapper__ = _swig_new_instance_method(_math.math_Vector___itruediv_wrapper__)

    def __itruediv__(self, right):
        self.__itruediv_wrapper__(right)
        return self

    Set = _swig_new_instance_method(_math.math_Vector_Set)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_Vector

# Register math_Vector in _math:
_math.math_Vector_swigregister(math_Vector)

class math_FunctionSetWithDerivatives(math_FunctionSet):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Derivatives = _swig_new_instance_method(_math.math_FunctionSetWithDerivatives_Derivatives)
    Values = _swig_new_instance_method(_math.math_FunctionSetWithDerivatives_Values)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FunctionSetWithDerivatives

# Register math_FunctionSetWithDerivatives in _math:
_math.math_FunctionSetWithDerivatives_swigregister(math_FunctionSetWithDerivatives)

class math_FunctionWithDerivative(math_Function):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Derivative = _swig_new_instance_method(_math.math_FunctionWithDerivative_Derivative)
    Values = _swig_new_instance_method(_math.math_FunctionWithDerivative_Values)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FunctionWithDerivative

# Register math_FunctionWithDerivative in _math:
_math.math_FunctionWithDerivative_swigregister(math_FunctionWithDerivative)

class math_MultipleVarFunctionWithGradient(math_MultipleVarFunction):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Gradient = _swig_new_instance_method(_math.math_MultipleVarFunctionWithGradient_Gradient)
    Values = _swig_new_instance_method(_math.math_MultipleVarFunctionWithGradient_Values)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_MultipleVarFunctionWithGradient

# Register math_MultipleVarFunctionWithGradient in _math:
_math.math_MultipleVarFunctionWithGradient_swigregister(math_MultipleVarFunctionWithGradient)

class math_MultipleVarFunctionWithHessian(math_MultipleVarFunctionWithGradient):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Values = _swig_new_instance_method(_math.math_MultipleVarFunctionWithHessian_Values)

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_MultipleVarFunctionWithHessian

# Register math_MultipleVarFunctionWithHessian in _math:
_math.math_MultipleVarFunctionWithHessian_swigregister(math_MultipleVarFunctionWithHessian)

class math_TrigonometricEquationFunction(math_FunctionWithDerivative):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        :param A:
        	:type A: float
        	:param B:
        	:type B: float
        	:param C:
        	:type C: float
        	:param D:
        	:type D: float
        	:param E:
        	:type E: float
        	:rtype: None
        """
        _math.math_TrigonometricEquationFunction_swiginit(self, _math.new_math_TrigonometricEquationFunction(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_TrigonometricEquationFunction

# Register math_TrigonometricEquationFunction in _math:
_math.math_TrigonometricEquationFunction_swigregister(math_TrigonometricEquationFunction)



