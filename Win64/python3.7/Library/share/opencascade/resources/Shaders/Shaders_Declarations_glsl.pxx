// This file has been automatically generated from resource file src/Shaders/Declarations.glsl

static const char Shaders_Declarations_glsl[] =
  "\n"
  "//! @file Declarations.glsl includes definition of common uniform variables in OCCT GLSL programs\n"
  "//! @def THE_MAX_LIGHTS\n"
  "//! Specifies the length of array of lights, which is 8 by default. Defined by Shader Manager.\n"
  "// #define THE_MAX_LIGHTS 8\n"
  "\n"
  "//! @def THE_MAX_CLIP_PLANES\n"
  "//! Specifies the length of array of clipping planes, which is 8 by default. Defined by Shader Manager.\n"
  "// #define THE_MAX_CLIP_PLANES 8\n"
  "\n"
  "//! @def THE_NB_FRAG_OUTPUTS\n"
  "//! Specifies the length of array of Fragment Shader outputs, which is 1 by default. Defined by Shader Manager.\n"
  "// #define THE_NB_FRAG_OUTPUTS 1\n"
  "\n"
  "// compatibility macros\n"
  "#if (__VERSION__ >= 130)\n"
  "  #define THE_ATTRIBUTE  in\n"
  "  #define THE_SHADER_IN  in\n"
  "  #define THE_SHADER_OUT out\n"
  "  #define THE_OUT        out\n"
  "  #define occTexture1D   texture\n"
  "  #define occTexture2D   texture\n"
  "  #define occTexture3D   texture\n"
  "#else\n"
  "  #define THE_ATTRIBUTE  attribute\n"
  "  #define THE_SHADER_IN  varying\n"
  "  #define THE_SHADER_OUT varying\n"
  "  #define THE_OUT\n"
  "  #define occTexture1D   texture1D\n"
  "  #define occTexture2D   texture2D\n"
  "  #define occTexture3D   texture3D\n"
  "#endif\n"
  "\n"
  "#ifdef GL_ES\n"
  "  #define THE_PREC_ENUM lowp // enumerations should fit into lowp range\n"
  "#else\n"
  "  #define THE_PREC_ENUM\n"
  "#endif\n"
  "\n"
  "// Vertex attributes\n"
  "#ifdef VERTEX_SHADER\n"
  "  THE_ATTRIBUTE vec4 occVertex;\n"
  "  THE_ATTRIBUTE vec3 occNormal;\n"
  "  THE_ATTRIBUTE vec4 occTexCoord;\n"
  "  THE_ATTRIBUTE vec4 occVertColor;\n"
  "#elif defined(FRAGMENT_SHADER)\n"
  "  #if (__VERSION__ >= 130)\n"
  "    #ifdef OCC_ENABLE_draw_buffers\n"
  "      out vec4 occFragColorArray[THE_NB_FRAG_OUTPUTS];\n"
  "      #define occFragColorArrayAlias occFragColorArray\n"
  "      #define occFragColor0 occFragColorArray[0]\n"
  "    #else\n"
  "      out vec4 occFragColor0;\n"
  "    #endif\n"
  "  #else\n"
  "    #ifdef OCC_ENABLE_draw_buffers\n"
  "      #define occFragColorArrayAlias gl_FragData\n"
  "      #define occFragColor0 gl_FragData[0]\n"
  "    #else\n"
  "      #define occFragColor0 gl_FragColor\n"
  "    #endif\n"
  "  #endif\n"
  "\n"
  "  #if (THE_NB_FRAG_OUTPUTS >= 2)\n"
  "    #define occFragColor1 occFragColorArrayAlias[1]\n"
  "  #else\n"
  "    vec4 occFragColor1;\n"
  "  #endif\n"
  "  #if (THE_NB_FRAG_OUTPUTS >= 3)\n"
  "    #define occFragColor2 occFragColorArrayAlias[2]\n"
  "  #else\n"
  "    vec4 occFragColor2;\n"
  "  #endif\n"
  "  #if (THE_NB_FRAG_OUTPUTS >= 4)\n"
  "    #define occFragColor3 occFragColorArrayAlias[3]\n"
  "  #else\n"
  "    vec4 occFragColor3;\n"
  "  #endif\n"
  "\n"
  "  // Built-in outputs notation\n"
  "  #define occFragColor    occFragColor0\n"
  "  #define occFragCoverage occFragColor1\n"
  "\n"
  "  //! Define the main Fragment Shader output - color value.\n"
  "  void occSetFragColor (in vec4 theColor);\n"
  "#endif\n"
  "\n"
  "// Matrix state\n"
  "uniform mat4 occWorldViewMatrix;  //!< World-view  matrix\n"
  "uniform mat4 occProjectionMatrix; //!< Projection  matrix\n"
  "uniform mat4 occModelWorldMatrix; //!< Model-world matrix\n"
  "\n"
  "uniform mat4 occWorldViewMatrixInverse;    //!< Inverse of the world-view  matrix\n"
  "uniform mat4 occProjectionMatrixInverse;   //!< Inverse of the projection  matrix\n"
  "uniform mat4 occModelWorldMatrixInverse;   //!< Inverse of the model-world matrix\n"
  "\n"
  "uniform mat4 occWorldViewMatrixTranspose;  //!< Transpose of the world-view  matrix\n"
  "uniform mat4 occProjectionMatrixTranspose; //!< Transpose of the projection  matrix\n"
  "uniform mat4 occModelWorldMatrixTranspose; //!< Transpose of the model-world matrix\n"
  "\n"
  "uniform mat4 occWorldViewMatrixInverseTranspose;  //!< Transpose of the inverse of the world-view  matrix\n"
  "uniform mat4 occProjectionMatrixInverseTranspose; //!< Transpose of the inverse of the projection  matrix\n"
  "uniform mat4 occModelWorldMatrixInverseTranspose; //!< Transpose of the inverse of the model-world matrix\n"
  "\n"
  "// light type enumeration\n"
  "const int OccLightType_Direct = 1; //!< directional     light source\n"
  "const int OccLightType_Point  = 2; //!< isotropic point light source\n"
  "const int OccLightType_Spot   = 3; //!< spot            light source\n"
  "\n"
  "// Light sources\n"
  "uniform               vec4 occLightAmbient;      //!< Cumulative ambient color\n"
  "#if defined(THE_MAX_LIGHTS) && (THE_MAX_LIGHTS > 0)\n"
  "uniform THE_PREC_ENUM int  occLightSourcesCount; //!< Total number of light sources\n"
  "int   occLight_Type              (in int theId); //!< Type of light source\n"
  "int   occLight_IsHeadlight       (in int theId); //!< Is light a headlight?\n"
  "vec4  occLight_Diffuse           (in int theId); //!< Diffuse intensity for specified light source\n"
  "vec4  occLight_Specular          (in int theId); //!< Specular intensity (currently - equals to diffuse intencity)\n"
  "vec4  occLight_Position          (in int theId); //!< Position of specified light source\n"
  "vec4  occLight_SpotDirection     (in int theId); //!< Direction of specified spot light source\n"
  "float occLight_ConstAttenuation  (in int theId); //!< Const attenuation factor of positional light source\n"
  "float occLight_LinearAttenuation (in int theId); //!< Linear attenuation factor of positional light source\n"
  "float occLight_SpotCutOff        (in int theId); //!< Maximum spread angle of the spot light (in radians)\n"
  "float occLight_SpotExponent      (in int theId); //!< Attenuation of the spot light intensity (from 0 to 1)\n"
  "#endif\n"
  "\n"
  "// Front material properties accessors\n"
  "vec4  occFrontMaterial_Emission(void);     //!< Emission color\n"
  "vec4  occFrontMaterial_Ambient(void);      //!< Ambient  reflection\n"
  "vec4  occFrontMaterial_Diffuse(void);      //!< Diffuse  reflection\n"
  "vec4  occFrontMaterial_Specular(void);     //!< Specular reflection\n"
  "float occFrontMaterial_Shininess(void);    //!< Specular exponent\n"
  "float occFrontMaterial_Transparency(void); //!< Transparency coefficient\n"
  "\n"
  "// Back material properties accessors\n"
  "vec4  occBackMaterial_Emission(void);      //!< Emission color\n"
  "vec4  occBackMaterial_Ambient(void);       //!< Ambient  reflection\n"
  "vec4  occBackMaterial_Diffuse(void);       //!< Diffuse  reflection\n"
  "vec4  occBackMaterial_Specular(void);      //!< Specular reflection\n"
  "float occBackMaterial_Shininess(void);     //!< Specular exponent\n"
  "float occBackMaterial_Transparency(void);  //!< Transparency coefficient\n"
  "\n"
  "#ifdef THE_HAS_DEFAULT_SAMPLER\n"
  "#define occActiveSampler    occSampler0                //!< alias for backward compatibility\n"
  "#define occSamplerBaseColor occSampler0                //!< alias to a base color texture\n"
  "uniform               sampler2D occSampler0;           //!< current active sampler;\n"
  "#endif\n"
  "                                                       //!  occSampler1, occSampler2,... should be defined in GLSL program body for multitexturing\n"
  "uniform               vec4      occColor;              //!< color value (in case of disabled lighting)\n"
  "uniform THE_PREC_ENUM int       occDistinguishingMode; //!< Are front and back faces distinguished?\n"
  "uniform THE_PREC_ENUM int       occTextureEnable;      //!< Is texture enabled?\n"
  "uniform               vec4      occTexTrsf2d[2];       //!< 2D texture transformation parameters\n"
  "uniform               float     occPointSize;          //!< point size\n"
  "\n"
  "//! Parameters of blended order-independent transparency rendering algorithm\n"
  "uniform               int       occOitOutput;      //!< Enable bit for writing output color buffers for OIT (occFragColor, occFragCoverage)\n"
  "uniform               float     occOitDepthFactor; //!< Influence of the depth component to the coverage of the accumulated fragment\n"
  "uniform               float     occAlphaCutoff;    //!< alpha test cutoff value\n"
  "\n"
  "//! Parameters of clipping planes\n"
  "#if defined(THE_MAX_CLIP_PLANES) && (THE_MAX_CLIP_PLANES > 0)\n"
  "uniform               vec4 occClipPlaneEquations[THE_MAX_CLIP_PLANES];\n"
  "uniform THE_PREC_ENUM int  occClipPlaneChains[THE_MAX_CLIP_PLANES]; //! Indicating the number of planes in the Chain\n"
  "uniform THE_PREC_ENUM int  occClipPlaneCount;   //!< Total number of clip planes\n"
  "#endif\n"
  "//! @endfile Declarations.glsl\n";
